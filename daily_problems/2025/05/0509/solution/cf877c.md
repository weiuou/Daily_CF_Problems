**提示 1：** 先让坦克的位置变得可控。

**提示 2：** 怎么证明构造呢？

如果实在对于提示 1 没有想法，可以想想怎么找到最小值的可能的界。

如果 $n=1$ 显然是 $1$ 次，如果 $n=2$ 显然是 $3$ 次。

如果是 $n$ 呢？考虑最后两项，至少需要操作 $3$ 次，不然无法捕捉 $n-1\to n$ 或 $n\to n-1$ 中的一种移动策略。而前面的 $n-2$ 项的最小次数是范围更小的问题。

根据上述逻辑可以确定答案是不会小于 $n+\lfloor n/2\rfloor$ 的。那么能否构造呢？

其实上面提示了我们 “一半” 这件事。

我们可以通过一些操作让坦克的位置一定在某个集合中。

考虑先对所有偶数位置的格子进行操作，这样，现在坦克就一定在奇数位置的格子里了。此时再操作所有奇数位置的格子。如果坦克一开始在偶数位置，则此时已经被消灭了，否则还得再操作一遍偶数位置的格子。

计算得到，上面的过程步数恰好是之前证明给出的下界，因此完成构造。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()

    ans = []
    ans.extend(range(2, n + 1, 2))
    ans.extend(range(1, n + 1, 2))
    ans.extend(range(2, n + 1, 2))

    print(len(ans))
    print(*ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    cout << n + n / 2 << '\n';

    for (int i = 2; i <= n; i += 2)
        cout << i << ' ';

    for (int i = 1; i <= n; i += 2)
        cout << i << ' ';

    for (int i = 2; i <= n; i += 2)
        cout << i << ' ';

    return 0;
}
```