/*
如果是 1 * n 的矩阵，怎么做？直接预处理加权前缀和，再预处理普通前缀和
加权的区间和减去若干倍的普通区间和就好了
如果是一般形状的矩阵，则每行预处理加权前缀和和普通前缀和
每次询问，每行单独算，这样单次查询复杂度 O(n)
给了 3.5 秒时限，测试了一下发现过不去

考虑原矩阵中下标为 (i, j) 的元素，在 (x1, y1), (x2, y2) 子矩阵中的下标是多少？
显然是 (i - x1 + 1, j - y1 + 1)
其压平成线性数组的下标是 (i - x1) * (y2 - y1 + 1) + (j - y1 + 1)
所以求和求的是 ((i - x1) * (y2 - y1 + 1) + (j - y1 + 1)) * a[i][j] 的和
拆项：(i * (y2 - y1 + 1) - x1 * (y2 - y1 + 1) + j - y1 + 1) * a[i][j]
= (y2 - y1 + 1) * i * a[i][j] + j * a[i][j] - x1 * (y2 - y1 + 1) * a[i][j] + (1 - y1) * a[i][j]
前两项可以用加权前缀和搞一下，三四项其实就是普通前缀和
*/

LL a[M][M], s[M][M], xs[M][M], ys[M][M], n, q;

void meibao() {
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> a[i][j];
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            s[i][j] = s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1] + a[i][j];
            xs[i][j] = xs[i][j - 1] + xs[i - 1][j] - xs[i - 1][j - 1] + a[i][j] * i;
            ys[i][j] = ys[i][j - 1] + ys[i - 1][j] - ys[i - 1][j - 1] + a[i][j] * j;
        }
    }

    while (q--) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        LL s1 = xs[x2][y2] - xs[x2][y1 - 1] - xs[x1 - 1][y2] + xs[x1 - 1][y1 - 1];
        LL s2 = ys[x2][y2] - ys[x2][y1 - 1] - ys[x1 - 1][y2] + ys[x1 - 1][y1 - 1];
        LL s3 = s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1];
        cout << (y2 - y1 + 1) * s1 + s2 - x1 * (y2 - y1 + 1) * s3 + (1 - y1) * s3 << " ";
    }
    cout << "\n";
}
