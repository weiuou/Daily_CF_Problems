**提示 1：** 考虑和一个区间相交的各个其他区间应该满足什么条件。

考虑一个区间是 $[l, r]$ ，其他跟这个区间相交的区间，应该满足什么条件？

首先，最多只能一个区间包含 $l$ 这个端点，不然的话就存在了一个三元环了， $r$ 也是一样。

而其他区间只能两两不交。

于是，最终的图上，每个点引出的边，对应的端点最多只有两个可以继续连边（分别包含 $l$ 和 $r$ ），其他都不能连边了。

所以要找的图就是一条类似毛毛虫的结构，就是一条路径，加上路径上的点向外连的边。

于是这个问题很容易用树上的 DP 解决。考虑每个结点往下的一条毛毛虫链的最多结点数。枚举子节点，最大的一条，再加上当前节点可以新增的节点数量（加上当前节点及其子结点），就可以完成状态转移了。

而毛毛虫可以是这样的一条链，也可以是两棵子树的链拼到一起，因此维护下最大的两条链即可。

如果想做更多的一些毛毛虫的 DP 可以看小羊杯 Round 2 的 CD 两题。链接在这里：https://ac.nowcoder.com/acm/contest/100672 。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    inf = 10 ** 6
    outs = []
    
    for _ in range(t):
        n = II()
        path = [[] for _ in range(n)]
        
        for _ in range(n - 1):
            u, v = GMI()
            path[u].append(v)
            path[v].append(u)
        
        parent = [-1] * n
        que = [0]
        
        for u in que:
            for v in path[u]:
                if parent[u] != v:
                    parent[v] = u
                    que.append(v)
        
        ans = 0
        dp = [0] * n
        
        for u in reversed(que):
            x1, x2 = -inf, -inf
            for v in path[u]:
                if parent[v] == u:
                    if dp[v] > x1:
                        x1, x2 = dp[v], x1
                    elif dp[v] > x2:
                        x2 = dp[v]
            
            sons_count = len(path[u])
            if u > 0: sons_count -= 1
            
            dp[u] = fmax(1, x1 + 1 + (sons_count - 1))
            ans = fmax(ans, dp[u])
            ans = fmax(ans, x1 + x2 + 1 + (len(path[u]) - 2))
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    int t;
    cin >> t;

    while (t --) {
        int n;
        cin >> n;

        vector<vector<int>> path(n);
        for (int i = 0; i < n - 1; i ++) {
            int u, v;
            cin >> u >> v;
            u --, v --;
            path[u].emplace_back(v);
            path[v].emplace_back(u);
        }

        int ans = 0, inf = n;
        auto dfs = [&] (auto &self, int u, int p) -> int {
            int x1 = -inf, x2 = -inf;
            for (auto &v: path[u]) {
                if (v != p) {
                    auto res = self(self, v, u);
                    if (res > x1) swap(x1, x2), x1 = res;
                    else if (res > x2) x2 = res;
                }
            }

            int sons_count = path[u].size();
            if (u) sons_count --;

            int to_return = max(1, x1 + 1 + (sons_count - 1));
            ans = max(ans, to_return);
            ans = max(ans, x1 + x2 + 1 + ((int)path[u].size() - 2));

            return to_return;
        };

        dfs(dfs, 0, -1);
        cout << ans << '\n';
    }

    return 0;
}
```