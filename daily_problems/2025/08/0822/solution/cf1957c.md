**提示 1：** 其实只有剩下几行几列是重要的。

**提示 2：** 两种情况——对角线？其他位置？

我们把所有放了棋子的行和列都去掉，剩余的行和列才是能放东西的。而抠掉这些部分后剩余的棋盘一定还是个正方形，因为去掉的行和列编号完全一致。

设剩下了 $n'\times n'$ 的棋盘，则有多少种剩余棋子的放法呢？设为 $f(n')$ 。

我们考虑第一行的棋子，如果放在第一列，则剩下 $n'-1$ 边长的棋盘，方案为 $f(n'-1)$ 。

否则，第一行和第一列的剩余 $2(n'-1)$ 个位置可以任意放棋子，而机器人会对称地放另一个，两者一黑一白，并不是完全一致的。这种情况占据了两行两列，剩下了边长为 $n'-2$ 的正方形，所以方案数是 $2(n'-1)f(n'-2)$ 。

于是， $f(n')=f(n'-1)+2(n'-1)f(n'-2)$ 。直接递推就能解决这个问题了。

时间复杂度为 $\mathcal{O}(N)$ 预处理， $\mathcal{O}(k)$ 处理查询。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    mod = 10 ** 9 + 7
    
    dp = [0] * (3 * 10 ** 5 + 1)
    dp[0] = dp[1] = 1
    
    for i in range(2, 3 * 10 ** 5 + 1):
        dp[i] = (dp[i - 1] + 2 * (i - 1) * dp[i - 2]) % mod
    
    for _ in range(t):
        n, k = MII()
        for _ in range(k):
            x, y = MII()
            if x == y: n -= 1
            else: n -= 2
        outs.append(dp[n])
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int mod = 1e9 + 7, M = 3e5;
    vector<int> dp(M + 1);
    dp[0] = 1, dp[1] = 1;

    for (int i = 2; i <= M; i ++)
        dp[i] = (2ll * (i - 1) * dp[i - 2] + dp[i - 1]) % mod;
    
    int t;
    cin >> t;

    while (t --) {
        int n, k;
        cin >> n >> k;

        while (k --) {
            int x, y;
            cin >> x >> y;

            if (x == y) n --;
            else n -= 2;
        }

        cout << dp[n] << '\n';
    }

    return 0;
}
```