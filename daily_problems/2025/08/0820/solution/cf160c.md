**提示 1：** 先确定第一位。

**提示 2：** 如果有一堆相同的数咋办。

每个元素开头的元素对都有 $n$ 个。且相对顺序一定是满足的第一个元素越小，字典序越小，所以整体来看第一位一定是每个元素重复 $n$ 次。所以根据 $k/n$ 的整数部分可以知道第一位到底是啥。

但是可能有重复元素，所以第二位不一定满足之前的这个规律。

我们先把所有第一项严格小于我们确定的第一项的数对全部去掉。如果有 $x$ 个数严格更小，那么需要去掉 $xn$ 个数对。

而接下来，我们要找剩余元素中第 $k'$ 大的。假设元素从小到大排序是 $a_1,a_2,\dots,a_n$ ，而第一项已经保持为 $v$ 了。

设 $v$ 总共出现了 $cnt_v$ 次，那么可以形成 $cnt_v$ 组 $(v,a_1),(v,a_2),\dots,(v,a_n)$ ，而这也是这些数对从小到大的排序，因此我们只需求 $k$ 除以 $cnt_v$ 的结果即可确定到底是哪一组。

时间复杂度为 $\mathcal{O}(n\log n)$ ，因为你，不得不排序。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k = MII()
    nums = LII()
    nums.sort()
    
    k -= 1
    
    i = 0
    while i < n:
        j = i
        while j < n and nums[i] == nums[j]:
            j += 1
        
        if (j - i) * n > k:
            break
        
        k -= (j - i) * n
        i = j
    
    print(nums[i], nums[k // (j - i)])
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    long long k;
    cin >> n >> k;
    k --;

    vector<int> nums(n);
    for (auto &x: nums) cin >> x;

    sort(nums.begin(), nums.end());

    int i = 0, j;

    while (i < n) {
        j = i;
        while (j < n && nums[i] == nums[j])
            j ++;
        if (k < 1ll * (j - i) * n) break;
        k -= 1ll * (j - i) * n;
        i = j;
    }

    cout << nums[i] << ' ' << nums[k / (j - i)];

    return 0;
}
```