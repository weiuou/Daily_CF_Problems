**提示 1：** 考虑所有能交换的位置之间连边，哪些是可以交换的？

**提示 2：** 每一组元素需要替代几个元素？

对于 $a[i]$ 元素，和它可以交换的元素是 $a[n+1-i],b[i]$ ，进而可以跟 $b[n+1-i]$ 交换。

所以这四个元素变为一组。而组内一旦有两对元素相同，则可以通过交换把相同的元素安排到同一个下标的位置。

所以我们的目标是，修改 $a[i]$ 使得这些元素有两对相等的。

首先，如果已经有两对相等的，就不用改了。

否则，至少存在一对相等的，若其非 $a[i], a[n+1-i]$ ，则修改其中一个元素一定不会破坏相等对，故一次操作就够了。否则一次操作不够。

如果上述条件都不满足，至少需要两次操作。同时很容易让 $a[i]$ 变为 $b[i]$ ， $a[n+1-i]$ 变为 $b[n+1-i]$ ，所以只需两次。

对于 $n$ 为奇数的情况还需考虑最中间元素是否相等，加上对应修改次数即可。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    s1 = [ord(c) for c in I()]
    s2 = [ord(c) for c in I()]
    
    ans = 0
    
    for i in range(n // 2):
        a, b, c, d = s1[i], s1[n - 1 - i], s2[i], s2[n - 1 - i]
        if (a == b and c == d) or (a == c and b == d) or (a == d and b == c):
            ans += 0
        elif a == c or a == d or b == c or b == d or c == d:
            ans += 1
        else:
            ans += 2
    
    if n % 2: ans += s1[n // 2] != s2[n // 2]
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    string s1, s2;
    cin >> s1 >> s2;

    int ans = 0;

    for (int i = 0; i < n / 2; i ++) {
        char a = s1[i], b = s1[n - 1 - i], c = s2[i], d = s2[n - 1 - i];
        if ((a == b && c == d) || (a == c && b == d) || (a == d && b == c))
            ans += 0;
        else if (a == c || a == d || b == c || b == d || c == d)
            ans += 1;
        else
            ans += 2;
    }

    if (n & 1) ans += s1[n / 2] != s2[n / 2];

    cout << ans;

    return 0;
}
```