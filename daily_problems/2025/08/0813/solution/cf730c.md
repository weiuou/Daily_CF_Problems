**提示 1：** 显然时间越久越便宜，因为便宜的东西来得及送到了。

考虑处理查询。

首先，可以看一眼提示。所以随着时间增大，所需的成本减小，能买到的东西增多。

所以，可以二分答案。考虑 $T$ 时间内可以到达的位置。可以使用 BFS 预处理得到每个点和被查询点的距离。

买东西肯定从便宜往贵了买，所以按照价格顺序从小到大遍历，如果该物品所在的位置能够走到，则我们尽量多买。

最后可以计算总成本和购买的物品数量，如果数量够了且成本没超，则符合要求，否则不符合。根据这个信息进行二分即可。

时间复杂度为 $\mathcal{O}(q(n+m+w\log n))$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    path = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = GMI()
        path[u].append(v)
        path[v].append(u)
    
    w = II()
    cs = []
    ks = []
    ps = []
    
    for i in range(w):
        c, k, p = MII()
        c -= 1
        cs.append(c)
        ks.append(k)
        ps.append(p)
    
    st_range = sorted(range(w), key=lambda x: ps[x])
    
    q = II()
    dis = [n] * n
    outs = []
    
    for _ in range(q):
        g, r, a = MII()
        g -= 1
        
        que = [g]
        dis[g] = 0
        
        for u in que:
            for v in path[u]:
                if dis[v] == n:
                    dis[v] = dis[u] + 1
                    que.append(v)
        
        left, right = 0, n - 1
        
        while left <= right:
            mid = (left + right) // 2
            
            total = 0
            cur = r
            
            for i in st_range:
                if dis[cs[i]] <= mid:
                    val = fmin(cur, ks[i])
                    cur -= val
                    total += val * ps[i]
            
            if total <= a and cur == 0:
                right = mid - 1
            else:
                left = mid + 1
        
        outs.append(left if left < n else -1)
        
        for i in range(n):
            dis[i] = n
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<vector<int>> path(n);
    while (m --) {
        int u, v;
        cin >> u >> v;
        u --, v --;
        path[u].emplace_back(v);
        path[v].emplace_back(u);
    }

    int w;
    cin >> w;

    vector<int> cs(w), ks(w), ps(w);
    for (int i = 0; i < w; i ++)
        cin >> cs[i] >> ks[i] >> ps[i], cs[i] --;
    
    vector<int> order(w);
    iota(order.begin(), order.end(), 0);
    sort(order.begin(), order.end(), [&] (int i, int j) {return ps[i] < ps[j];});

    int q;
    cin >> q;

    while (q --) {
        int g, r, a;
        cin >> g >> r >> a;
        g --;
        vector<int> dis(n, n);
        dis[g] = 0;

        queue<int> q; q.push(g);

        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (auto &v: path[u]) {
                if (dis[v] == n) {
                    dis[v] = dis[u] + 1;
                    q.push(v);
                }
            }
        }

        int left = 0, right = n;
        while (left <= right) {
            int mid = (left + right) / 2;

            long long cost = 0;
            int cur = r;
            for (auto &i: order) {
                if (dis[cs[i]] <= mid) {
                    int val = min(cur, ks[i]);
                    cur -= val;
                    cost += 1ll * val * ps[i];
                }
            }

            if (cost <= a && cur == 0) right = mid - 1;
            else left = mid + 1;
        }

        cout << (left < n ? left : -1) << '\n';
    }

    return 0;
}
```