**提示 1：** 树上 DP，但是状态怎么设计呢？考虑子树的信息怎么传递到父节点上去。

很明显是一个 DP 算方案数的问题。但是我们应该设计什么状态呢？

我们考虑父节点在状态转移的时候应该考虑什么。

如果父节点有向当前节点连的边，则要求当前子树的根节点目前没有往两个子树连线，于是我们要存对应的情况的方案数。

如果父节点没有向当前结点连线。

- 父节点向两个子树连了边，则需要当前节点满足单独取出来这个子树的情况下，仍然满足原题条件，要存对应的方案数。

- 父节点没有向任何一个子树连线，则此时，当前结点只能选择往两个子树连线，否则将跟父节点对应的线连成一条，要存对应的方案数。

- 父节点向其中一个子树连线，则此时，当前子树也只能内部形成一系列的线，因此满足当前节点满足单独取出来这个子树的情况下，仍然满足原题条件，类似于第一种情况。

综上，实质上，每个子树有三个状态值得关心——根节点向两个子树都连了线；根节点没有向两个子树连线；当前子树单独取出来时满足要求。

分别设有 $dp0[x],dp1[x],dp2[x]$ 种方案。

接下来考虑状态转移。

**情况 0：**

对于第一种情况，需要选取两个子节点连线，因此需要选择 $v_1,v_2$ ，对应的 $dp1[v_1],dp1[v_2]$ ，而对于其他子节点，要求子树内部满足原题要求，因此都是 $dp2[v]$ 。

这件事就相当于 $k$ 个子结点中，选取两个的 $dp_1$ ，其余全取 $dp_2$ ，问总方案数有几种。可以考虑一个小型 DP ，在前缀中选取 $i$ 个的 $dp_1$ 的情况下方案数是 $smallDP[i]$ 。

则如果新来了个子节点 $x$ ，则 $smallDP[i]\times dp2[x]$ 可以转移到 $smallDP[i]$ ，而 $smallDP[i]\times dp1[x]$ 可以转移到 $smallDP[i+1]$ 去。时间复杂度是线性的。

**情况 1：**

根节点未向两棵子树连线，此时要么连一条，要么没连。

连一条时，这棵子树选取 $dp1[v]$ ，其他子树需要内部满足条件，因此是 $dp2[v]$ 。发现相当于是前一种状态计算的 $smallDP[1]$ ，直接提取下结果就行。

没连的情况，要求所有子树都向子节点连两条线，因此直接对 $dp0[v]$ 求乘积即可，实际上也是 $smallDP[0]$ 。

**情况 2：**

上述哪些情况是使得子树满足题设要求的呢？

首先，情况 0 肯定满足，因为根节点已经连了两条线了。

对于情况 1：

- 根节点未向子树连边的话，各个子树都需要满足是向底下连两条线的，因此方案数就是前面提到的 $dp0[v]$ 的乘积，也就是 $smallDP[0]$ 。

- 如果根节点向其中一棵子树连边，则其他子树必须也向底下连两条边，相当于一棵子树选 $dp1[v]$ ，其余子树选 $dp0[v]$ 。这个东西的维护前面也有类似的。

综上进行转移即可，我们最后要的答案恰好是 $dp2[1]$ 。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    mod = 10 ** 9 + 7
    path = [[] for _ in range(n)]
    
    for _ in range(n - 1):
        u, v = GMI()
        path[u].append(v)
        path[v].append(u)
    
    que = [0]
    parent = [-1] * n
    
    for u in que:
        for v in path[u]:
            if parent[u] != v:
                parent[v] = u
                que.append(v)
    
    dp0 = [0] * n
    dp1 = [0] * n
    dp2 = [0] * n
    
    for u in reversed(que):
        v1, v2, v3 = 0, 0, 1
        s1, s2 = 0, 1
        
        for v in path[u]:
            if parent[v] == u:
                v1 = (v1 * dp2[v] + v2 * dp1[v]) % mod
                v2 = (v2 * dp2[v] + v3 * dp1[v]) % mod
                v3 = v3 * dp2[v] % mod
                
                s1 = (s1 * dp0[v] + s2 * dp1[v]) % mod
                s2 = s2 * dp0[v] % mod
        
        dp0[u] = v1
        dp1[u] = (v2 + s2) % mod
        dp2[u] = (dp0[u] + s1 + s2) % mod
    
    print(dp2[0])
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, mod = 1e9 + 7;
    cin >> n;

    vector<vector<int>> path(n);
    for (int i = 0; i < n - 1; i ++) {
        int u, v;
        cin >> u >> v;
        u --, v --;
        path[u].emplace_back(v);
        path[v].emplace_back(u);
    }

    vector<int> dp0(n, 0), dp1(n, 0), dp2(n, 0);

    auto dfs = [&] (auto &self, int u, int p) -> void {
        int v1 = 0, v2 = 0, v3 = 1, s1 = 0, s2 = 1;

        for (auto &v: path[u]) {
            if (v != p) {
                self(self, v, u);

                v1 = (1ll * v1 * dp2[v] + 1ll * v2 * dp1[v]) % mod;
                v2 = (1ll * v2 * dp2[v] + 1ll * v3 * dp1[v]) % mod;
                v3 = 1ll * v3 * dp2[v] % mod;

                s1 = (1ll * s1 * dp0[v] + 1ll * s2 * dp1[v]) % mod;
                s2 = 1ll * s2 * dp0[v] % mod;
            }
        }

        dp0[u] = v1, dp1[u] = (v2 + s2) % mod, dp2[u] = ((dp0[u] + s1) % mod + s2) % mod;
    };

    dfs(dfs, 0, -1);

    cout << dp2[0];

    return 0;
}
```
