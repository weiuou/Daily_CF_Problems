**提示 1：** 尝试构造一组子集，跟数值大小无关，且其和可以直接比较。

我们先将数组进行排序。不妨从大到小排序。

两个数组的大小可以直接比较，当且仅当一个是另一个的子集 / 两个集合只差了一个元素 $x$ 。

我们基于此进行构造，使得我们能构造出一个长度为 $\frac{n(n+1)}{2}$ 的元素和从小到大的一个序列。

先选择一元子集。肯定是每个元素单独成集合。

接下来，二元子集只有包含最大值时，才能比前面所有子集大。因此至少是 $a_1+a_n$ 。接下来要取二元子集，就只能继续取 $a_1+a_{n-1},\dots,a_1+a_3,a_1+a_2$ ，因为必须包含 $a_1$ 才能保证比前一个子集大，而第二个元素有 $n-1$ 种取法。

类似的，能保证比 $a_1+a_2$ 大的三元子集是 $a_1+a_2+a_n$ ，接下来选取 $a_1+a_2+\dots+a_{n-1},\dots,a_1+a_2+a_4,a_1+a_2+a_3$ ，能选出 $n-2$ 个子集。

类似地，我们对于 $k$ 元子集，选取长度为 $k-1$ 的前缀，再选取 $n-(k-1)$ 长度后缀中的每一个元素。

这样我们选取出来的子集序列的总长度为 $n+(n-1)+\dots+1=\frac{n(n+1)}{2}$ ，因此完成了满足条件的构造。

时间复杂度为 $\mathcal{O}(nk)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k = MII()
    nums = LII()
    
    nums.sort(reverse=True)
    outs = []
    
    for i in range(n):
        for j in range(i, n):
            cur = []
            
            for idx in range(i):
                cur.append(nums[idx])
            cur.append(nums[j])
            
            outs.append(f'{len(cur)} {" ".join(map(str, cur))}')
    
    print('\n'.join(outs[:k]))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, k;
    cin >> n >> k;

    vector<int> nums(n);
    for (auto &v: nums)
        cin >> v;
    
    sort(nums.rbegin(), nums.rend());

    for (int i = 0; i < n; i ++) {
        for (int j = i; j < n; j ++) {
    
            cout << i + 1 << ' ';
            for (int k = 0; k < i; k ++) cout << nums[k] << ' ';
            cout << nums[j] << '\n';

            if (--k == 0) return 0;
        }
    }

    return 0;
}
```