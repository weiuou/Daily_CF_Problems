**提示 1：** 各个方向的运动是独立的，所以什么时候到终点呢？

**提示 2：** 先不考虑反射，再看如何映射到最后的位置。

首先，各个方向的运动相互独立，所以根据 $y$ 轴上的运动，可以快速计算出时间。

接下来，假设不发生反射，则我们可以计算到一个最终的位置。而反射相当于关于墙面做轴对称。所以我们只需不停关于墙面所在平面和墙面关于墙面所成的 “虚像” 不停做对称即可。而每一个 $a\times b$ 的区域内都只有一个像的位置，因此是可以唯一确定的。

最后发现 $(x,0,z)$ 的点可以轴对称到 $(x-2a,0,z-2b)$ ，所以直接将 $x,z$ 分别关于 $2a,2b$ 取模，接下来再对称到所需的区域内即可。

时间复杂度为 $\mathcal{O}(1)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    a, b, m = MII()
    vx, vy, vz = MII()
    
    time = -m / vy
    
    x = a / 2 + vx * time
    z = vz * time
    
    x %= 2 * a
    z %= 2 * b
    
    if x >= a: x = 2 * a - x
    if z >= b: z = 2 * b - z
    print(x, z)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    long double a, b, m, vx, vy, vz;
    cin >> a >> b >> m >> vx >> vy >> vz;

    long double t = -m / vy;

    long double x = a / 2 + vx * t, z = vz * t;

    int val_x = x / (2 * a), val_z = z / (2 * b);
    x -= val_x * 2 * a, z -= val_z * 2 * b;

    while (x < 0) x += 2 * a;
    while (x >= 2 * a) x -= 2 * a;

    while (z < 0) z += 2 * b;
    while (z >= 2 * b) z -= 2 * b;

    cout << fixed << setprecision(15);
    cout << min(x, 2 * a - x) << ' ' << min(z, 2 * b - z);

    return 0;
}
```