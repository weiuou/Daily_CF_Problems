/*
需要计算所有子序列的分数之和
事实上 0 似乎可以看成是 -1
对于一个串，分数是 max(f(v, 1, i) * f(v, i + 1, |v|))，是乘号，有可能两个负数相乘
长度为 1 的串贡献是 0
考虑到这个式子的形式，似乎就不容易直接看某个字符的贡献是多少了
max(f(v, 1, i) * f(v, i + 1, |v|)) >= 0 恒成立，因为我们总可以让某个串为空串，所以每个序列的贡献一定非负
每修改一个字符，只会影响包含这个字符的子序列的值
修改是持久化的，如果是之前预处理出来一堆值，那么每次修改都得重新维护这些值才行，似乎不容易做到
如果没有任何修改，怎么算所有子序列的分数之和？我觉得需要先会算这个东西
枚举子序列右端点？枚举中间分界点？
我们考虑枚举 i，考虑以 i 结尾的，总和为 s 的序列有多少个，和 s 至多有 2n 种可能
对 max(f(v, 1, i) * f(v, i + 1, |v|)) 的形式做一个改写
max(s[i] * (s[n] - s[i])) = max(s[i] * s[n] - s[i]^2)
但这是子序列，我们也没法用前缀和之类的东西

我注意到了 s[i] 和 s[n] - s[i] 是连续变化的，但是没有用到这个，可以均值不等式的
事实上对于一个和为 s 的子序列，s 为偶数则其贡献为 s^2 / 4
和为奇数则其贡献为 (s + 1) / 2 * (s - (s + 1) / 2) = (s^2 - 1) / 4
都是可以取到的
在不修改的情况下，问题变成了求和为 s 的子序列，s 从 -n 到 n，各有多少个
我们计算以 i 结尾的和为 s 的子序列有多少，设为 dp[i][s]，则 dp[i][s] += dp[j][s - a[i]], 0 <= j < i
这样就可以 O(n^3) 回答一次询问
考虑加速计算过程，于是需要考虑修改某个 i 会带来什么
包含该 i 的序列有 2^(n - 1) 个，将其从 0 翻转到 1，则答案从原来的 s^2 / 4 变成 (s + 2)^2 / 4
变化量是 (4 * s + 4) / 4 = s + 1，另一个是从 (s^2 - 1) / 4 变成 ((s + 2)^2 - 1) / 4，变化量也是 s + 1
不能从变化量的角度考虑，因为你最开始算的还是很慢，变化量每个序列也都不一样

首先，我们的总答案是枚举所有子序列，记其 0 的个数是 c0，1 的个数是 c1，则 (c0 - c1)^2 / 4 或者 ((c0 - c1)^2 - 1) / 4 就是其贡献
羊神提示和为奇数的子序列个数和和为偶数的子序列个数是一样的，所以有 2^(n - 1) 个序列需要减去 1 / 4
所以相当于枚举所有子序列，求 (c0 - c1)^2 / 4 求和，最后再减去 2^(n - 1) / 4
所以最关键的就是求所有 (c0 - c1)^2 的和，即求所有的 c0^2 + c1^2 - 2 * c0 * c1 的和
对于 c0^2 求和，考虑枚举子序列中 0 的个数为 i，假设整个串中有 cnt0 个 0，cnt1 个 1
则这样的子序列有 C(cnt0, i) * 2^cnt1
所以 c0^2 求和就是 i^2 * C(cnt0, i) * 2^cnt1，枚举 i 从 0 到 cnt0
c1^2 求和类似得出是 i^2 * C(cnt1, i) * 2^cnt0，枚举 i 从 0 到 cnt1
对于交叉项，考虑子序列中有 i 个 0 和 j 个 1，这样的子序列有 C(cnt0, i) * C(cnt1, j) 个
其贡献是 C(cnt0, i) * i * C(cnt1, j) * j，这个东西求和能不能快速算？
如果我们能预处理出来 C(cnt1, j) * j 的和就好了，这样二重循环里对 j 的枚举就可以省掉了
考虑 (1 + x)^cnt1 = sum(C(cnt1, j) * x^j)
对 x 求导，有 cnt1 * (1 + x)^(cnt1 - 1) = sum(C(cnt1, j) * j * x^(j - 1)), j >= 1
取 x = 1，就可得到 sum(C(cnt1, j) * j) = cnt1 * 2^(cnt1 - 1), j >= 1，由于 j = 0 时贡献是 0，所以公式不变
所以就是对 cnt1 * 2^(cnt1 - 1) * C(cnt0, i) * i 求个和，而后者也可以类似的推导出公式
所以交叉项 c0 * c1 的和为 cnt1 * 2^(cnt1 - 1) * cnt0 * 2^(cnt0 - 1)
目前，单点修改时，交叉项的贡献我们可以 O(1) 算出来，但是平方项还不行，所以我们还需要对平方项做一些化简
考虑 (1 + x)^cnt1 求二阶导，有
cnt1 * (cnt1 - 1) * (1 + x)^(cnt1 - 2) = sum(C(cnt1, j) * j * (j - 1) * x^(j - 2)), j >= 2
带入 x = 1，有 sum(C(cnt1, j) * j * (j - 1)) = cnt1 * (cnt1 - 1) * 2^(cnt1 - 2)
这个东西加上 sum(C(cnt1, j) * j)，就是 sum(C(cnt1, j) * j^2) 的值了
至此，平方项我们也可以 O(1) 维护了，这个题就只需要维护当前总共有多少 0 和 1，剩下的直接爆算就好了
*/

LL pow2[N], cnt0, cnt1, n, q, inv4;
string s;
const int mod = 998244353;

LL qpow(LL a, LL b, LL MOD) {
    LL res = 1, base = a;
    while (b) {
        if (b & 1) {
            res = res * base % MOD;
        }
        base = base * base % MOD;
        b >>= 1;
    }
    return res % MOD;
}

void meibao() {
    cin >> n >> q;
    cin >> s;

    cnt0 = 0;
    cnt1 = 0;
    for (int i = 0; i < n; i++) {
        if (s[i] == '0') {
            cnt0++;
        } else {
            cnt1++;
        }
    }

    while (q--) {
        int i;
        cin >> i;
        i--;
        if (s[i] == '0') {
            s[i] = '1';
            cnt0--;
            cnt1++;
        } else {
            s[i] = '0';
            cnt0++;
            cnt1--;
        }

        LL s_cross = 0;
        if (cnt0 != 0 && cnt1 != 0) {
            s_cross = (cnt1 * pow2[cnt1 - 1] % mod) * (cnt0 * pow2[cnt0 - 1] % mod) % mod;
        }

        LL s0 = 0, s1 = 0;
        if (cnt0 >= 1) {
            if (cnt0 >= 2)
                s0 = cnt0 * (cnt0 - 1) % mod * pow2[cnt0 - 2] % mod;
            s0 += cnt0 * pow2[cnt0 - 1] % mod;
            s0 %= mod;
            s0 *= pow2[cnt1];
            s0 %= mod;
        }

        if (cnt1 >= 1) {
            if (cnt1 >= 2)
                s1 = cnt1 * (cnt1 - 1) % mod * pow2[cnt1 - 2] % mod;
            s1 += cnt1 * pow2[cnt1 - 1] % mod;
            s1 %= mod;
            s1 *= pow2[cnt0];
            s1 %= mod;
        }

        LL res = s0 + s1 - 2 * s_cross;
        res = (res % mod + mod) % mod;
        res = res * inv4 % mod - pow2[n - 1] * inv4 % mod;
        res = (res % mod + mod) % mod;
        cout << res << "\n";
    }

}
