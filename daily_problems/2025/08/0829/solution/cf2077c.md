**提示 1：** 给的式子实际上求的是什么？最值其实很容易。

**提示 2：** 注意式子的拆分。

首先， $F$ 就是 $1$ 的个数减去 $0$ 的个数，因为 $r-l+1-\mathrm{zero}(v,l,r)$ 就是 $1$ 的个数。

所以给的两个式子的和就是区间里 $1$ 的个数减去 $0$ 的个数，不妨设为 $k$ 。

于是要求 $x(k-x)$ 的最大值，很明显当 $x=\lfloor k / 2\rfloor$ 时取到。

那么 $F(v,1,i)$ 能取到这个数值吗？答案是肯定的，因为从空串开始，这个数从 $0$ 每次加一 / 减一最后变成了 $k$ ，因此根据介值原理，这两个一个不小于目标数值，一个不大于目标数值，因此一定中间遍历到我们要的数。

所以，最终结果就是 $\lfloor k^2/4\rfloor$ 。

这个东西只有在 $k$ 是奇数的情况下需要变成 $(k^2-1)/4$ ，而长度为奇数的子串数量和长度为偶数的子序列数量是相同的（考虑一个长度为偶数的子序列可以增加 / 去掉 $s[0]$ 以得到唯一对应的长度为偶数的子序列），因此这里减去的总数值是 $2^{n-1}/4$ 。

于是，我们只需求 $k^2$ ，即 $(cnt_0-cnt_1)^2$ 。

直接求显然很乱，因为括号内相互牵制，于是考虑算 $cnt_0^2-2cnt_0cnt_1+cnt_1^2$ 。

平方项计算是一致的。考虑计算 $\sum cnt_0^2$ 。

枚举选取的 $0$ 的个数，设选了 $i$ 个，总 $0$ 个数是 $c_0$ ，于是有 $C_{c_0}^i$ 种选法，剩余 $c_1$ 任意选，所以，这里方案数是 $C_{c_0}^i\times 2^{c_1}$ 。

所以我们要求 $\sum\limits_{i=0}^{c_0} i^2 C_{c_0}^i\times 2^{c_1}$ 。

这东西咋算呢？

$\sum\limits_{i=0}^{c_0} i^2C_{c_0}^i=\sum\limits_{i=0}^{c_0} (i(i-1)C_{c_0}^i+iC_{c_0}^i)=\sum\limits_{i=0}^{c_0} ((c_0(c_0-1))C_{c_0-2}^{i-2}+c_0C_{c_0-1}^{i-1})$ （最后这一步可以把组合数展开看一下，就把 $C_x^y$ 写成 $\frac{x(x-1)\dots(x-y+1)}{y(y-1)\dots 1}$ 就会发现约分约掉了）

而这里 $\sum C_x^i$ 求和结果根据二项式定理，就是 $2^x$ 。

于是，上面的结果就是：

$c_0(c_0-1)\times 2^{c_0-2}+c_0\times 2^{c_0-1}=c_0(c_0+1)\times 2^{c0-2}$


而交叉项呢？我们也类似地计算就行，枚举选择的 $0$ 和 $1$ 的个数分别是 $i,j$ ，则要求和： 

$\sum\limits_{i}\sum\limits_{j}C_{c_0}^iC_{c_1}^jij=(\sum\limits_{i}iC_{c_0}^i)(\sum\limits_{j}jC_{c_1}^j)$

后面这个东西咋求前面写过了，就是 $c_0 2^{c_0-1}\times c_1 2^{c_1-1}$ 。

将上述结果加总即可。注意可以使用 $c_0+c_1=n$ 。

于是在修改的过程中，我们只要能维护 $c_0,c_1$ 即可。

时间复杂度为 $\mathcal{O}(n+q)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    mod = 998244353
    
    M = 2 * 10 ** 5
    pw2 = [1] * (M + 1)
    
    for i in range(1, M + 1):
        pw2[i] = 2 * pw2[i - 1] % mod
    
    t = II()
    outs = []
    
    rev4 = ((mod + 1) // 2 + mod) // 2
    
    for _ in range(t):
        n, q = MII()
        s = [int(c) for c in I()]
        c0 = s.count(0)
        c1 = s.count(1)
        
        for _ in range(q):
            idx = II() - 1
            
            if s[idx]:
                c1 -= 1
                c0 += 1
            else:
                c1 += 1
                c0 -= 1
            
            s[idx] ^= 1
            
            outs.append((c0 * (c0 + 1) // 2 + c1 * (c1 + 1) // 2 - c0 * c1 - 1) * pw2[n - 1] % mod * rev4 % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    int mod = 998244353, M = 2e5;
    vector<int> pw2(M + 1, 1);

    for (int i = 1; i <= M; i ++)
        pw2[i] = 1ll * pw2[i - 1] * 2 % mod;
    
    int rev4 = ((mod + 1) / 2 + mod) / 2;

    while (t --) {
        int n, q;
        cin >> n >> q;

        string s;
        cin >> s;

        int c0 = 0, c1 = 0;

        for (auto &c: s) {
            if (c == '0') c0 ++;
            else c1 ++;
        }

        while (q --) {
            int idx;
            cin >> idx;
            idx --;

            if (s[idx] == '0') {
                c0 --, c1 ++;
                s[idx] = '1';
            }
            else {
                c1 --, c0 ++;
                s[idx] = '0';
            }

            cout << (1ll * c0 * (c0 + 1) / 2 % mod + 1ll * c1 * (c1 + 1) / 2 % mod - 1ll * c0 * c1 % mod - 1) % mod * pw2[n - 1] % mod * rev4 % mod << '\n';
        }
    }

    return 0;
}
```