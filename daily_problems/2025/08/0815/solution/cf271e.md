**提示 1：** 两数同加，两数同除，最重要的变量是什么？

**提示 2：** 能否给出构造？

两个数可以同时加上任意大的数，而这个操作中，不变的是差值。

而一旦除以 $2$ ，差值是除以 $2$ 的。

因此，在这两种操作下，差值的最大奇因子是不变的。

而对于最后一个操作，差值相当于是原有的两个差值相加，因此只要操作钱的两个差值是这个最大奇因子的倍数，则这个最大奇因子也整除于最后差值。

综上，最后能构造出来的 $(1,x)$ 一定满足 $x-1$ 整除原有数对的最大奇因子。于是 $g=\gcd(a_1-1,a_2-1,\dots,a_n-1)$ 整除原有数对最大奇因子。

那么，对任意一组 $(x,y)$ ，设 $y-x$ 最大奇因子为 $v$ ，那么 $(1,1+kv)$ 一定能构造吗？答案是肯定的。

设 $y=x+a$ ，则 $(x,x+a)$ 可以通过同时加的操作变成 $(x+a,x+2a)$ ，再通过第三种操作变成 $(x,x+2a)$ 。

同样的，也可以用 $(x,x+a)$ 的同加操作，变为 $(x+2a,x+3a)$ ，和之前构造出来的 $(x,x+2a)$ ，变出新的 $(x,x+3a)$ 。

以此类推，我们可以得到任意的 $(x,x+ka)$ ， $k$ 为整数。

那么我们可以让 $ka$ 是一个充分大的 $2^T\times v$ ，只需使得 $2^T\times v$ 是 $a$ 的倍数且 $2^T\geq x$ ，这样 $(x,x+2^T\times v)$ 就可以先通过加操作变成 $(2^T, 2^T+2^T\times v)$ ，再两个同时除以 $2$ 共计 $T$ 次，变成 $(1,1+v)$ 。接下来再使用之前的 $(x,x+ka)$ 的构造方案，就可以构造出任意的 $(1,1+kv)$ 。

于是构造完成，命题得证。

所以只需 $y-x$ 的最大奇因子是 $g$ 的因子就行。所以我们可以找所有 $g$ 的奇因子，再不断乘以 $2$ 得到所有可能的 $y-x$ ，最后根据 $x,y$ 的范围确定对数，进行加总即可。

时间复杂度为 $\mathcal{O}(n+\sqrt{M}+d(M)\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    nums = LGMI()
    
    g = math.gcd(*nums)
    g //= g & -g
    
    ans = 0
    
    def solve(x):
        res = 0
        v = x
        while v <= m:
            res += m - v
            v *= 2
        return res
    
    for i in range(1, 100000):
        if i > g // i: break
        
        if g % i == 0:
            ans += solve(i)
            if i != g // i:
                ans += solve(g // i)
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    int g = 0;
    while (n --) {
        int x;
        cin >> x;
        g = gcd(g, x - 1);
    }

    g /= g & -g;

    long long ans = 0;

    auto solve = [&] (int x) -> long long {
        long long res = 0;
        while (x <= m) {
            res += m - x;
            x <<= 1;
        }
        return res;
    };

    for (int i = 1; i <= g / i; i ++) {
        if (g % i == 0) {
            ans += solve(i);
            if (i != g / i) ans += solve(g / i);
        }
    }

    cout << ans;

    return 0;
}
```