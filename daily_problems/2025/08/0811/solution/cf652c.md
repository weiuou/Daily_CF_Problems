**提示 1：** 右端点往右的时候，对应的左端点肯定也往右。

尽量不要使用除了数组之外的结构。

很明显的是，如果一个数组满足条件，其子数组也满足条件。同时，右端点右移时，对应的最靠左的左端点也一定单调不减。

因此，显然可以使用双指针来做。

而双指针的判断，只需考虑右端点产生的新矛盾。于是计算矛盾总数，再不断移动左端点，减去所有的左端点和右端点之间的矛盾。这个是无需任何数据结构的。直到矛盾数量减少至 $0$ 。具体可见后面的代码。

时间复杂度为 $\mathcal{O}(n+m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, q = MII()
    nums = LII()
    
    tmp = [[] for _ in range(n + 1)]
    
    for _ in range(q):
        x, y = MII()
        tmp[x].append(y)
        tmp[y].append(x)
    
    vis = [0] * (n + 1)
    
    l = 0
    ans = 0
    
    for r in range(n):
        vis[nums[r]] = 1
        
        cnt = 0
        for x in tmp[nums[r]]:
            cnt += vis[x]
        
        while cnt:
            for x in tmp[nums[l]]:
                if x == nums[r]:
                    cnt -= 1
            vis[nums[l]] = 0
            l += 1
        
        ans += r - l + 1
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<int> nums(n);
    for (auto &v: nums) cin >> v;

    vector<vector<int>> contradictions(n + 1);
    while (m --) {
        int u, v;
        cin >> u >> v;
        contradictions[u].emplace_back(v);
        contradictions[v].emplace_back(u);
    }

    vector<int> vis(n + 1, 0);
    int l = 0;
    long long ans = 0;

    for (int r = 0; r < n; r ++) {
        vis[nums[r]] = 1;

        int cnt = 0;
        for (auto &x: contradictions[nums[r]])
            cnt += vis[x];
        
        while (cnt) {
            for (auto &x: contradictions[nums[l]])
                if (x == nums[r]) cnt --;
            vis[nums[l]] = 0;
            l ++;
        }

        ans += r - l + 1;
    }

    cout << ans;

    return 0;
}
```