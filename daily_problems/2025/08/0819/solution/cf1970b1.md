**提示 1：** $n$ 并不远。距离都是偶数。

最大的距离 $n$ 并不远，如果按照对角线走，只需要走 $n/2$ ，而距离又都是偶数。

所以我们直接取 $(1,1),(2,2),\dots,(n,n)$ ，每个点至少存在距其不超过 $n$ 且为偶数的点，对于距离 $k$ ，只需考虑横坐标移动 $k/2$ 就行。所以我们就输出这些点，并找到对应距离的位置就行了。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()
    
    print('YES')
    print('\n'.join(f'{i} {i}' for i in range(1, n + 1)))
    print(' '.join(str(i + nums[i] // 2 + 1) if i + nums[i] // 2 < n else str(i - nums[i] // 2 + 1) for i in range(n)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    cout << "YES\n";
    for (int i = 1; i <= n; i ++)
        cout << i << ' ' << i << '\n';
    
    for (int i = 1; i <= n; i ++) {
        int x;
        cin >> x;
        cout << (i + x / 2 <= n ? i + x / 2 : i - x / 2) << ' ';
    }

    return 0;
}
```