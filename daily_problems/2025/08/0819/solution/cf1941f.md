**提示 1：** 只有一个间隔可以被插入。

**提示 2：** 最大的两个间隔有一个不变。

我们相当于要找到一个数插入第一个数组，使得其相邻两项之差的最大值尽可能小。

考虑目前已经有的间隔，其中只有一个间隔会被插入一个数。其余间隔保持不变。

所以，最大的两个间隔中，至少有一个会保持不变。

所以，如果最大的间隔中间没有插入新元素的话，答案就是当前最大间隔的长度。

如果最大间隔有多个，那么一定有一个变不了，所以也可以直接输出答案。

否则，我们需要在唯一的最大间隔中插入元素。最优的插入元素是两端的中点，我们相当于要用后两个数组各取一个元素的和，让它尽可能接近这个位置。

这相当于凑两数之和，使其尽可能接近目标数。于是我们枚举其中一个元素，在另一个数组二分找到使其和最接近中间元素的数，进而得到该元素的分割结果。

最后，取最优的分割结果，并注意需要和第二大的间隔（因为这个间隔没有变过）取最大值，即答案。

时间复杂度为 $\mathcal{O}(n+(m+k)\log k)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    for _ in range(t):
        n, m, k = MII()
        nums = LII()
        
        v1 = LII()
        v2 = LII()
        
        v2.sort()
        
        v = 0
        for i in range(1, n):
            v = fmax(v, nums[i] - nums[i - 1])
        
        cnt = 0
        other_v = 0
        for i in range(1, n):
            if nums[i] - nums[i - 1] == v:
                cnt += 1
            else:
                other_v = fmax(other_v, nums[i] - nums[i - 1])
        
        if cnt > 1: outs.append(v)
        else:
            for i in range(1, n):
                if nums[i] - nums[i - 1] == v:
                    # 这里 cpp 会爆 int 哦！
                    target = (nums[i] + nums[i - 1]) // 2
                    
                    ans = v
                    
                    for x in v1:
                        p = bisect.bisect_left(v2, target - x)
                        
                        for j in range(p - 1, p + 2):
                            if 0 <= j < k and nums[i - 1] <= v2[j] + x <= nums[i]:
                                ans = fmin(ans, fmax((v2[j] + x) - nums[i - 1], nums[i] - (v2[j] + x)))
                    
                    outs.append(fmax(ans, other_v))
                    break
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int n, m, k;
        cin >> n >> m >> k;

        vector<int> nums(n), v1(m), v2(k);

        for (auto &x: nums) cin >> x;
        for (auto &x: v1) cin >> x;
        for (auto &x: v2) cin >> x;

        sort(v2.begin(), v2.end());

        int max_gap = 0, max_gap_cnt = 0;

        for (int i = 1; i < n; i ++) {
            if (nums[i] - nums[i - 1] > max_gap) {
                max_gap = nums[i] - nums[i - 1];
                max_gap_cnt = 1;
            }
            else if (nums[i] - nums[i - 1] == max_gap)
                max_gap_cnt ++;
        }

        if (max_gap_cnt > 1) cout << max_gap << '\n';
        else {
            int other_gap = 0;
            for (int i = 1; i < n; i ++) {
                if (nums[i] - nums[i - 1] < max_gap) {
                    other_gap = max(other_gap, nums[i] - nums[i - 1]);
                }
            }

            for (int i = 1; i < n; i ++) {
                if (nums[i] - nums[i - 1] == max_gap) {
                    int to_search = nums[i - 1] + (nums[i] - nums[i - 1]) / 2; // 我就是不用 long long 哼
                    int ans = max_gap;

                    for (auto &x: v1) {
                        int p = lower_bound(v2.begin(), v2.end(), to_search - x) - v2.begin();
                        for (int j = p - 1; j <= p + 1; j ++) {
                            if (j >= 0 && j < k && v2[j] + x >= nums[i - 1] && v2[j] + x <= nums[i]) {
                                ans = min(ans, max((v2[j] + x) - nums[i - 1], nums[i] - (v2[j] + x)));
                            }
                        }
                    }
                    ans = max(ans, other_gap);
                    cout << ans << '\n';
                    break;
                }
            }
        }
    }

    return 0;
}
```