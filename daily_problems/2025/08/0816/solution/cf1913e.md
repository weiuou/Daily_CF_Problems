**提示 1：** 先倒回全 $0$ 的矩阵，然后再安排 $1$ 。

**提示 2：** 每个位置只能 $0/1$ 意味着选取一些行列对。这类似于匹配。

首先，我们先强行做操作，把所有 $1$ 变成 $0$ 。

接下来我们相当于在矩阵中填入部分 $1$ ，使得行列条件得到满足。即我们选取一些行列的对，使得最终完成行 / 列的对应数量。

这件事类似于匹配，因此考虑到网络流。

对于一开始是 $0$ 的位置 $(i,j)$ ，相当于匹配成本是 $1$ ，因为需要修改。否则，成本是 $-1$ ，因为我们之前强行把它们变成了 $0$ ，撤销这个操作相当于成本减去了 $1$ 。

于是有一些权，最后完成匹配，直接用 $行\to 列$ 的方式进行建图，流量等于 $1$ ，（费用）边权等于上述边权，即可构建一个网络流，我们求最小费用即可。当然我们要求流量等于行和也等于列和。

但是因为存在负数权值，所以可能会出现负环，这是我们不想看到的。但我们最终匹配的边数是完全确定的，因此给所有边权加上固定的数值，最终的费用也就增加边数乘以这个固定的数，并不影响我们的匹配方案，因此所有边的费用加一，即可保证整体费用非负数，也就可以用最小费用流的朴素模板了。

最后，根据匹配的边数和一开始的操作进行调整，即可输出答案。

时间复杂度为 $\mathcal{O}(n^2m^2\log nm)$ 。但肯定很跑不满的！

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    grid = [LII() for _ in range(n)]
    
    nums1 = LII()
    nums2 = LII()
    
    mcf = MCFGraph(n + m + 2)
    
    src = n + m
    dst = n + m + 1
    
    cur = sum(sum(x) for x in grid)
    
    for i in range(n):
        for j in range(m):
            if grid[i][j]:
                mcf.add_edge(i, j + n, 1, 0)
            else:
                mcf.add_edge(i, j + n, 1, 2)
    
    for i in range(n):
        mcf.add_edge(src, i, nums1[i], 0)
    
    for i in range(m):
        mcf.add_edge(n + i, dst, nums2[i], 0)
    
    mf, mc = mcf.flow(src, dst)
    
    if mf == sum(nums1) == sum(nums2):
        print(mc + (cur - sum(nums1)))
    else:
        print(-1)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < m; j ++) {
            cin >> grid[i][j];
        }
    }

    vector<int> nums1(n), nums2(m);
    int s1 = 0, s2 = 0;

    for (auto &x: nums1) cin >> x, s1 += x;
    for (auto &x: nums2) cin >> x, s2 += x;

    if (s1 != s2) return cout << -1, 0;

    atcoder::mcf_graph<int, int> mcf(n + m + 2);
    int src = n + m, dst = src + 1;

    for (int i = 0; i < n; i ++)
        mcf.add_edge(src, i, nums1[i], 0);
    
    for (int j = 0; j < m; j ++)
        mcf.add_edge(n + j, dst, nums2[j], 0);
    
    int total = 0;
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < m; j ++) {
            if (grid[i][j]) mcf.add_edge(i, n + j, 1, 0), total ++;
            else mcf.add_edge(i, n + j, 1, 2);
        }
    }

    auto res = mcf.flow(src, dst);

    if (res.first == s1) cout << res.second + (total - s1);
    else cout << -1;

    return 0;
}
```