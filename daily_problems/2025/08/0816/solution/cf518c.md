**提示 1：** 要读到第 $i$ 个元素要操作几次？

**提示 2：** 交换操作需要维护什么？

首先我们先确定每次读元素所需的时间。读第 $i$ 个元素需要的时间我们是可以 $\mathcal{O}(1)$ 求出的，相当于算在第几个页面中，即最小的满足 $kx\geq i$ 的 $x$ 。之后再操作一次就行。

而每次读取需要跟前一项交换，这件事也是很好维护的。因为我们只需维护数组本身和数组的位置，而每次交换相当于两个数组中分别有一对元素交换，我们执行对应的逻辑即可。

时间复杂度为 $\mathcal{O}(n+m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m, k = MII()
    cur = LGMI()
    pos = [0] * n
    
    for i in range(n):
        pos[cur[i]] = i
    
    ans = 0
    for i in GMI():
        ans += pos[i] // k + 1
        
        if pos[i]:
            p = pos[i]
            pos[cur[p]], pos[cur[p - 1]] = pos[cur[p - 1]], pos[cur[p]]
            cur[p], cur[p - 1] = cur[p - 1], cur[p]
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m, k;
    cin >> n >> m >> k;

    vector<int> cur(n);
    for (auto &x: cur) cin >> x;

    vector<int> pos(n + 1);
    for (int i = 0; i < n; i ++)
        pos[cur[i]] = i;
    
    long long ans = 0;
    while (m --) {
        int i;
        cin >> i;

        ans += pos[i] / k + 1;
        if (pos[i]) {
            int p = pos[i];
            swap(pos[cur[p]], pos[cur[p - 1]]);
            swap(cur[p], cur[p - 1]);
        }
    }

    cout << ans;

    return 0;
}
```