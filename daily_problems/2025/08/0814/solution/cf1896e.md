**提示 1：** 考虑数字向右移动到目标位置。

**提示 2：** 哪些位置不会停留？

考虑每个元素 $p[i]$ ，假设每次会移动到下一个位置。

这样我们可以得到每个元素移动的基准次数。

但有些位置不会停留——因为这个位置的元素已经到位了。这些位置可以使得答案 $-1$ 。

那么怎么数出来这些位置的数量呢？这些元素起点和终点都在 $p[i]$ 走到对应位置的路上。

而整体的向右移动到对应位置的过程在一个环形上，因此可以复制一遍数组，把所有数字的移动转化为区间 $(起始位置,终点位置)$ ，最后也就是求某个区间内包含了多少个区间。

这是典型的二维数点，即多少个区间左端点大于当前区间左端点，且右端点小于当前区间右端点。可以顺序 / 倒序遍历的过程中根据树状数组维护。

具体地，可以根据左端点从大到小遍历区间，遍历到的区间在右端点新增标记。则每个区间包含的区间个数可以用遍历到这个区间时，右端点左侧包含的标记个数确定（因为之前遍历的区间都满足左端点更大了，只需新增一个右端点更小的条件，即右端点左侧的标记），可以树状数组快速求得。后面的代码就是依据这一点。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        perm = LGMI()
        
        ans = [0] * n    
        fen = FenwickTree(2 * n)
        
        for i in range(n):
            if perm[i] >= i:
                fen.add(n + perm[i], 1)
        
        for i in range(n - 1, -1, -1):
            v = perm[i] if perm[i] >= i else perm[i] + n
            ans[perm[i]] = v - i - fen.sum(v)
            fen.add(v, 1)
    
        outs.append(' '.join(map(str, ans)))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int n;
        cin >> n;

        vector<int> perm(n);
        for (auto &x: perm) cin >> x, x --;

        vector<int> pos(n);
        for (int i = 0; i < n; i ++) pos[perm[i]] = i;

        vector<int> ans(n, 0);
        atcoder::fenwick_tree<int> fen(2 * n);

        for (int i = 0; i < n; i ++)
            if (perm[i] >= i)
                fen.add(n + perm[i], 1);
        
        for (int i = n - 1; i >= 0; i --) {
            int v = perm[i] >= i ? perm[i] : perm[i] + n;
            ans[perm[i]] = v - i - fen.sum(0, v);
            fen.add(v, 1);
        }

        for (auto &x: ans) cout << x << ' '; cout << '\n';
    }

    return 0;
}
```