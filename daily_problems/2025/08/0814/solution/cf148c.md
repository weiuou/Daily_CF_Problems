**提示 1：** 先满足什么要求呢？

首先对于非 $a$ 和 $b$ 的，直接在结尾塞上一堆 $1$ 就行了。

而如果有 $a$ 也有 $b$ 我们应该优先完成什么操作呢？注意我们的数值是有上界的。

考虑其中有两次操作是先最大值 $+1$ ，再求和 $+1$ 的，则设一开始和为 $sum$ ，最大值为 $mx$ ，则交换这两次操作后，最后一个最大的元素在交换前后分别是 $2(sum+mx+1)+1, 2sum+1$ ，显然后者更小，所以应该先做求和 $+1$ ，再做最大值 $+1$ 。

但是有时候会有问题！如果没有求和 $+1$ 的操作，那么第二个元素不得不小于第一个，此时第二项无法产生贡献。因此 $a=n-1$ 且 $a\gt 0$ 时无法构造。否则， $b=0$ 的这种情况下，从第三项开始构造就行，前两项可以填 $1,1$ 之类的。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, a, b = MII()
    
    if a and a == n - 1: print(-1)
    elif n == 1: print(1)
    else:
        ans = [1, 2]
        if b == 0: ans = [2, 1]
        else: b -= 1
        
        cur = 3
        for i in range(2, n):
            if b:
                b -= 1
                ans.append(cur + 1)
                cur = cur * 2 + 1
            elif a:
                a -= 1
                ans.append(fmax(ans[0], ans[-1]) + 1)
            else:
                ans.append(1)
        
        print(*ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, a, b;
    cin >> n >> a >> b;

    if (a && a == n - 1) cout << -1;
    else if (n == 1) cout << 1;
    else {
        if (b) b --, cout << "1 2 ";
        else cout << "2 1 ";

        int cur = 3, val = 2;
        for (int i = 2; i < n; i ++) {
            if (b) b --, val = cur + 1, cur += val;
            else if (a) a --, val = max(val + 1, 3);
            else val = 1;
            cout << val << ' ';
        }

    }

    return 0;
}
```