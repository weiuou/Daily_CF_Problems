**提示 1：** 我们只需看断了一条边后，有哪些点对不再连通。

**提示 2：** 断的一定是割边。

一开始连通的点对数量等于 $\frac{n(n-1)}{2}$ 。我们只需看断开一条边后让哪些点对不在连通就行。

如果隔开的边在某个环内，则经过这条边的路径可以转而走环上别的边，因此不影响连通性。

所以一定不在任何一个环内，也就是一条割边。而其会导致两侧连通块内的点无法相互到达。所以假设其中一个连通块大小为 $sz$ ，则会让连通点对数减小 $sz(n-sz)$ 。

也就是，我们要找所有不在环中的点，看其其中一侧的连通块内的点数。

为此，我们可以通过 DFS 找到一棵生成树，并预处理每棵子树的大小。接下来剩下的边会使得有些树上的边在环上，比如边 $(u,v)$ 会让 $u$ 到 $v$ 的路径上的边在环上，所以需要对路径上的边进行标记。而这件事可以通过树上差分快速维护。

而 DFS 树上对于树外边而言，只有一个点往其祖先连的边，所以 LCA 是不必求的。

而接下来我们只需看所有没有标记的树边，看其一段对应的子树大小就完成问题了。

时间复杂度为 $\mathcal{O}(n)$ 。下面代码中没有取 DFS 序，所以多了个 LCA 的步骤。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    for _ in range(t):
        n, m = MII()
        
        uf = UnionFind(n)
        path = [[] for _ in range(n)]
        
        us = []
        vs = []
        
        for _ in range(m):
            u, v = GMI()
            
            if uf.merge(u, v):
                path[u].append(v)
                path[v].append(u)
            else:
                us.append(u)
                vs.append(v)
        
        parent = [-1] * n
        depth = [0] * n
        
        que = [0]
        
        for u in que:
            for v in path[u]:
                if parent[u] != v:
                    parent[v] = u
                    depth[v] = depth[u] + 1
                    que.append(v)
        
        nth_parent = [[-1] * n for _ in range(20)]
        nth_parent[0] = parent
        
        for i in range(19):
            for j in range(n):
                if nth_parent[i][j] != -1:
                    nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]]
    
        diff = [0] * n
    
        for i in range(m - n + 1):
            u = us[i]
            v = vs[i]
            
            diff[u] += 1
            diff[v] += 1
            
            if depth[u] < depth[v]:
                u, v = v, u
            
            d = depth[u] - depth[v]
            for i in range(20):
                if d >> i & 1:
                    u = nth_parent[i][u]
            
            if u == v:
                diff[u] -= 2
            else:
                for i in range(19, -1, -1):
                    if nth_parent[i][u] != nth_parent[i][v]:
                        u = nth_parent[i][u]
                        v = nth_parent[i][v]
                diff[parent[u]] -= 2
        
        que.reverse()
        
        sz = [1] * n
        ans = 0
        
        for i in que:
            if i > 0:
                sz[parent[i]] += sz[i]
                diff[parent[i]] += diff[i]
                
                if diff[i] == 0:
                    ans = fmax(ans, sz[i] * (n - sz[i]))
        
        outs.append(n * (n - 1) // 2 - ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int n, m;
        cin >> n >> m;

        atcoder::dsu uf(n);
        vector<vector<int>> path(n);
        vector<pair<int, int>> edges;

        while (m --) {
            int u, v;
            cin >> u >> v;
            u --, v --;
            
            if (uf.merge(u, v)) {
                path[u].emplace_back(v);
                path[v].emplace_back(u);
            }
            else edges.emplace_back(u, v);
        }

        vector<int> parent(n, -1), depth(n, 0);

        auto dfs = [&] (auto &self, int u, int p) -> void {
            for (auto &v: path[u]) {
                if (v != p) {
                    parent[v] = u;
                    depth[v] = depth[u] + 1;
                    self(self, v, u);
                }
            }
        };

        dfs(dfs, 0, -1);

        vector<vector<int>> nth_parent(20, vector<int>(n, -1));
        nth_parent[0] = parent;

        for (int i = 0; i < 19; i ++) {
            for (int j = 0; j < n; j ++) {
                if (nth_parent[i][j] >= 0) {
                    nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]];
                }
            }
        }

        vector<int> sz(n, 1), diff(n, 0);

        for (auto &[u, v]: edges) {
            diff[u] ++, diff[v] ++;
            if (depth[u] < depth[v]) swap(u, v);
            int d = depth[u] - depth[v];

            for (int i = 0; i < 20; i ++) {
                if (d >> i & 1) {
                    u = nth_parent[i][u];
                }
            }

            if (u == v) diff[u] -= 2;
            else {
                for (int i = 19; i >= 0; i --) {
                    if (nth_parent[i][u] != nth_parent[i][v]) {
                        u = nth_parent[i][u];
                        v = nth_parent[i][v];
                    }
                }
                diff[parent[u]] -= 2;
            }
        }

        long long to_delete = 0;

        auto dfs1 = [&] (auto &self, int u, int p) -> void {
            for (auto &v: path[u]) {
                if (v != p) {
                    self(self, v, u);
                    sz[u] += sz[v];
                    diff[u] += diff[v];
                }
            }

            if (diff[u] == 0) to_delete = max(to_delete, 1ll * sz[u] * (n - sz[u]));
        };

        dfs1(dfs1, 0, -1);

        cout << 1ll * n * (n - 1) / 2 - to_delete << '\n';
    }

    return 0;
}
```