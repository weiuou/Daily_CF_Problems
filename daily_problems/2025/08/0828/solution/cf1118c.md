**提示 1：** 哪些元素不得不一样呢？

我们看对称的过程中有哪些元素是一定一样的呢？

对于不在对称轴的元素，其 $(i,j)$ 有对应的 $(n+1-i,j), (i,n+1-j), (n+1-i,n+1-j)$ 是它可以对称到达的位置，所以需要出现 $4$ 次。

而非中心点的对称轴上的元素，关于另一条对称轴有一个元素和它相同，所以出现 $2$ 次。

最中心的元素出现 $1$ 次。

所以我们统计每个数出现的次数。不妨先安排次数多的数，依次填到四个角、对称轴上、中间，依次处理 $4,2,1$ 的频次，如果不存在剩余的数，直接输出无法构造即可。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()
    
    cnt = [0] * 1001
    
    for x in nums:
        cnt[x] += 1
    
    ans = [[0] * n for _ in range(n)]
    
    pt = 0
    for i in range(n // 2):
        for j in range(n // 2):
            while pt < 1001 and cnt[pt] < 4:
                pt += 1
            
            if pt == 1001:
                exit(print('NO'))
            
            cnt[pt] -= 4
            ans[i][j] = pt
            ans[n - 1 - i][j] = pt
            ans[i][n - 1 - j] = pt
            ans[n - 1 - i][n - 1 - j] = pt
    
    if n % 2:
        pt = 0
        for i in range(n // 2):
            while pt < 1001 and cnt[pt] < 2:
                pt += 1
            
            if pt == 1001:
                exit(print('NO'))
            
            cnt[pt] -= 2
            ans[i][n // 2] = pt
            ans[n - 1 - i][n // 2] = pt
        
        for i in range(n // 2):
            while pt < 1001 and cnt[pt] < 2:
                pt += 1
            
            if pt == 1001:
                exit(print('NO'))
            
            cnt[pt] -= 2
            ans[n // 2][i] = pt
            ans[n // 2][n - 1 - i] = pt
        
        for i in range(1001):
            if cnt[i]:
                ans[n // 2][n // 2] = i
    
    print('YES')
    print('\n'.join(' '.join(map(str, x)) for x in ans))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> cnt(1001, 0);
    for (int i = 0; i < n * n; i ++) {
        int x;
        cin >> x;
        cnt[x] ++;
    }

    vector<vector<int>> ans(n, vector<int>(n));

    int pt;
    pt = 0;

    for (int i = 0; i < n / 2; i ++) {
        for (int j = 0; j < n / 2; j ++) {
            while (pt < 1001 && cnt[pt] < 4) pt ++;
            if (pt == 1001) return cout << "NO", 0;
            ans[i][j] = pt;
            ans[n - 1 - i][j] = pt;
            ans[i][n - 1 - j] = pt;
            ans[n - 1 - i][n - 1 - j] = pt;
            cnt[pt] -= 4;
        }
    }

    if (n & 1) {
        pt = 0;

        for (int i = 0; i < n / 2; i ++) {
            while (pt < 1001 && cnt[pt] < 2) pt ++;
            if (pt == 1001) return cout << "NO", 0;
            ans[i][n / 2] = pt;
            ans[n - 1 - i][n / 2] = pt;
            cnt[pt] -= 2;
        }

        for (int i = 0; i < n / 2; i ++) {
            while (pt < 1001 && cnt[pt] < 2) pt ++;
            if (pt == 1001) return cout << "NO", 0;
            ans[n / 2][i] = pt;
            ans[n / 2][n - 1 - i] = pt;
            cnt[pt] -= 2;
        }

        for (int i = 0; i <= 1000; i ++)
            if (cnt[i]) ans[n / 2][n / 2] = i;
    }

    cout << "YES\n";

    for (auto &x: ans) {
        for (auto &y: x) cout << y << ' ';
        cout << '\n';
    }

    return 0;
}
```