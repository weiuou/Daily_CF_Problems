**提示 1：** 考虑从 $x$ 位置出发，会怎么走？

从 $x$ 位置出发，考虑最后位置在 $x$ 的左侧还是右侧，整体上有这两类走法——

- 走到右侧：先往左侧走再走回 $x$ （可能不走），再往右走。

- 走到左侧：先往右侧走再走回 $x$ （可能不走），再往左走。

于是，只需考虑一个位置第一步往左 / 右侧走，回来 / 不回来的情况下能进行的最大步数。

如果需要回来，则每条边都得走偶数次。于是，只有往对应的方向边数至少为 $2$ 的情况下，才能利用前一层的结果进行转移。

如果不需要回来，考虑前一条边走 $1$ 次还是 $2$ 次，如果前一条边已经只走了 $1$ 次，那么这条边只能走奇数次；否则可以走任意次。

根据上述两个逻辑进行 DP 就行。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()
    
    left0 = [0] * n
    left1 = [0] * n
    
    for i in range(n - 1):
        if nums[i] > 1:
            left1[i + 1] = left1[i] + nums[i] // 2 * 2
        left0[i + 1] = fmax(left0[i] + nums[i] - (nums[i] + 1) % 2, left1[i] + nums[i])
    
    right0 = [0] * n
    right1 = [0] * n
    
    for i in range(n - 2, -1, -1):
        if nums[i] > 1:
            right1[i] = right1[i + 1] + nums[i] // 2 * 2
        right0[i] = fmax(right0[i + 1] + nums[i] - (nums[i] + 1) % 2, right1[i + 1] + nums[i])
    
    print(fmax(max(left0[i] + right1[i] for i in range(n)),
            max(left1[i] + right0[i] for i in range(n))))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> nums(n - 1);
    for (auto &x: nums) cin >> x;

    vector<long long> left0(n, 0), left1(n, 0), right0(n, 0), right1(n, 0);

    for (int i = 0; i < n - 1; i ++) {
        if (nums[i] > 1) left1[i + 1] = left1[i] + nums[i] / 2 * 2;
        left0[i + 1] = max(left0[i] + nums[i] - (nums[i] + 1) % 2, left1[i] + nums[i]);
    }

    for (int i = n - 2; i >= 0; i --) {
        if (nums[i] > 1) right1[i] = right1[i + 1] + nums[i] / 2 * 2;
        right0[i] = max(right0[i + 1] + nums[i] - (nums[i] + 1) % 2, right1[i + 1] + nums[i]);
    }

    long long ans = 0;

    for (int i = 0; i < n; i ++) {
        ans = max(ans, left0[i] + right1[i]);
        ans = max(ans, left1[i] + right0[i]);
    }

    cout << ans;

    return 0;
}
```