**提示 1：** 检查某个串是否满足要求只需判断某两个子串是否能匹配。

**提示 2：** 我们只需要这个判断足够快。

对于一个长度为偶数的串，我们只需看其前半段和后半段能否通过替换问号匹配上。这个要求相当于，每个相应的位置要么本来就相等，要么有一个是问号。

而对于子串是否可匹配，我们可以使用类似 LCP 的方法，考虑 $i,j$ 两个位置开头的子串的最大匹配长度，设为 $DP[i][j]$ 。

则如果两个位置无法匹配，则返回 $0$ ，否则结果是 $DP[i+1][j+1]+1$ 。

而如果两个子串的开始位置分别是 $i,j\ (i\lt j)$ ，则对应的原串长度是 $2(j-i)$ ，同时，能匹配的条件就是 $DP[i][j]\geq j-i$ 。上述 DP 和枚举都可以在平方复杂度内解决。

空间上，可以逆序遍历，就只需要 $\mathcal{O}(n)$ 空间了。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    for _ in range(t):
        s = [ord(c) - ord('a') + 1 if c != '?' else 0 for c in I()]
        n = len(s)
        lcp = [0] * (n + 1)
        
        ans = 0
        
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                if s[j] == s[i] or s[j] == 0 or s[i] == 0:
                    lcp[j] = lcp[j + 1] + 1
                else:
                    lcp[j] = 0
                if lcp[j] >= j - i:
                    ans = fmax(ans, j - i)
        
        outs.append(ans * 2)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        string s;
        cin >> s;

        int n = s.size(), ans = 0;
        vector<int> lcp(n + 1, 0);

        for (int i = n - 1; i >= 0; i --) {
            for (int j = i + 1; j < n; j ++) {
                lcp[j] = ((s[j] == s[i] || s[i] == '?' || s[j] == '?') ? lcp[j + 1] + 1 : 0);
                if (lcp[j] >= j - i) ans = max(ans, j - i);
            }
        }
        
        cout << ans * 2 << '\n';
    }

    return 0;
}
```