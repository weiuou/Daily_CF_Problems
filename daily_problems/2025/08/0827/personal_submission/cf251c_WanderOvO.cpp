/*
对于操作 1，没什么好说的
对于操作 2，考虑一直进行 a = a - a % k 这个操作，其中 k 不变，最终 a 会变成多少呢？
在执行了一次 a = a - a % k 之后，a 就可以被 k 整除了，所以不可能连续选相同的 k，这是没用的
这个时候我们 a -= 1，则又变成了a % k = k - 1，现在就又可以用刚才的 k 了
但也有可能先 a -= a % k，然后 a -= a % (k - 1)
我们一直这样操作 a，直到 a 和 b 比较接近，对于剩下的部分考虑进行一个全面的暴搜？
不会做

羊神提示：假如 a 目前是 2...k 的公倍数，则 a 肯定没法用第二种操作减小
假如 a 不是 2...k 的公倍数，则 a 经过操作 2 一定会变成 2...k 的公倍数，这是无法逾越的
假如 a 现在是 2...k 的公倍数，则 a 变成恰好比自己小的 2...k 的公倍数的操作数是固定的
因此，我们只需要分三段去做，一段是 a 变到不超过自己的最大的 2...k 的公倍数
第二段是公倍数之间的跳跃，第三段是恰好大于等于 b 的 2...k 的公倍数变成 b
lcm(2...15) = 360360，也就是说我们要看怎么快速算长度为 360360 的一段的最小操作次数

对于某个段，我们考虑从小往大算，枚举当前的数 i，先把直接 + 1 的解决掉
然后枚举模数 k，假如 k 能整除当前的数，则把 i + 1 到 i + k - 1 的所有数的步数尝试更新
如果是倍数到倍数的段，我们就从 0 更新到 360360，如果是 b 到倍数的段，我们就从 b % 360360 更新到 360360
如果是倍数到 a 的段，我们就从 0 更新到 a % 360360，注意判断 a 和 b 原本是不是已经为 360360 倍数了
*/

LL a, b, k, dp[360361];
int len = 360360;

LL calc(LL a, LL b) {
    memset(dp, 0x3f, sizeof dp);
    dp[b] = 0;
    for (int i = b; i <= a; i++) {
        if (i + 1 <= a) {
            dp[i + 1] = min(dp[i + 1], dp[i] + 1);
        }
        for (int mod = 2; mod <= k; mod++) {
            if (i % mod == 0) {
                for (int j = 1; j <= mod - 1 && i + j <= a; j++) {
                    dp[i + j] = min(dp[i + j], dp[i] + 1);
                }
            }
        }
    }
    return dp[a];
}

void meibao() {
    cin >> a >> b >> k;
    if (a / len == b / len) {
        // 同一个段里，直接 DP
        a %= len;
        b %= len;
        cout << calc(a, b) << "\n";
    } else {
        LL res1 = 0, res2 = 0, res3 = 0;
        res2 = calc(len, 0);
        if (b % len != 0) {
            res1 = calc(len, b % len);
        }

        if (a % len != 0) {
            res3 = calc(a % len, 0);
        }
        if (b % len != 0) {
            b = b - b % len;
            b += len;
        }
        if (a % len != 0) {
            a = a - a % len;
        }

        if (a >= b) {
            res2 *= ((a - b) / len);
        }
        cout << res1 + res2 + res3 << "\n";
    }
}
