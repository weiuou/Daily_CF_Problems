**提示 1：** 每个元素离最近的不同元素的距离，其实只看最近有多少跟它数值相同。

**提示 2：** 按照数值一块块地分割数组。

首先看提示 1，每个元素只需考虑包含其的一整段相同元素，所以考虑根据相同元素分段。

考虑一个最终的 $b$ 数组应该最多拆成多少段，这里的段数至少为 $k$ 段，才能使得 $1\sim k$ 每个数字都出现。

对于第一段和最后一段元素，总是递增和递减且最终到 $1$ ，因此是直接切割出来的。

而中间的段，长度为 $1,2,3,4,\dots$ 时，分别长成这样：

$[1],[1,1],[1,2,1],[1,2,2,1],\dots$

发现一旦长度超过 $3$ ，这一段就没办法用别的段凑出来了。但是长度为 $2$ 的段可以拆成两个长度为 $1$ 的。

而拆段使得段数更多，因此不妨钦定中间不允许出现长度为 $2$ 的段。

因此我们要求就是开头结尾长度任意，中间段长度不为 $2$ ，且总段数不小于 $k$ 的方案数。

为此，我们设前 $i$ 项分为 $j$ 段对应方案数为 $dp[i][j]$ ，把大于等于 $k$ 段的聚合到一起去。则转移时，只需考虑前一层的一个前缀 + 最后一段长度为 $1$ 的情况。于是用前缀和优化 DP 即可。

时间复杂度为 $\mathcal{O}(nk)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k = MII()
    mod = 998244353
    
    dp = [[0] * (n + 1) for _ in range(k + 1)]
    dp_acc = [[0] * (n + 1) for _ in range(k + 1)]
    
    for i in range(1, n + 1):
        dp[1][i] = 1
        dp_acc[1][i] = i
        
        for j in range(2, k + 1):
            dp[j][i] = dp[j - 1][i - 1]
            if i >= 3:
                dp[j][i] += dp_acc[j - 1][i - 3]
                dp[j][i] %= mod
            dp_acc[j][i] = (dp_acc[j][i - 1] + dp[j][i]) % mod
        
        dp[k][i] += dp[k][i - 1]
        dp[k][i] %= mod
        
        if i >= 3:
            dp[k][i] += dp_acc[k][i - 3]
            dp[k][i] %= mod
        
        dp_acc[k][i] = (dp_acc[k][i - 1] + dp[k][i]) % mod
    
    print((dp[k][n] + dp[k - 1][n - 2] + dp[k][n - 2]) % mod)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, k, mod = 998244353;
    cin >> n >> k;

    vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0)), dp_acc(k + 1, vector<int>(n + 1, 0));

    auto add = [&] (int &x, int y) -> void {
        x += y;
        if (x >= mod) x -= mod;
    };

    for (int i = 1; i <= n; i ++) {
        dp[1][i] = 1;
        dp_acc[1][i] = i;

        for (int j = 2; j <= k; j ++) {
            dp[j][i] = dp[j - 1][i - 1];
            if (i >= 3) add(dp[j][i], dp_acc[j - 1][i - 3]);
            dp_acc[j][i] = dp_acc[j][i - 1];
            add(dp_acc[j][i], dp[j][i]);
        }

        add(dp[k][i], dp[k][i - 1]);
        if (i >= 3) add(dp[k][i], dp_acc[k][i - 3]);

        dp_acc[k][i] = dp_acc[k][i - 1];
        add(dp_acc[k][i], dp[k][i]);
    }

    int ans = 0;
    add(ans, dp[k][n]);
    add(ans, dp[k - 1][n - 2]);
    add(ans, dp[k][n - 2]);

    cout << ans;

    return 0;
}
```