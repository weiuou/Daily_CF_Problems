**提示 1：** 两个间隔之间是互不影响的。

**提示 2：** 每段间隔咋算？

我们用已知的若干个点把时间分为若干个间隔。每个间隔能取到的最大值是互不影响的。

对于第一段，可以不停往前递增，最后一段可以不停往后递增。

对于中间的一段，如果时间差不足以达到高度差，则不可能构造。否则设最高点为 $H$ 则 $(H-h_1)+(H-h_2)\leq d_2-d_1$ ，这是很容易解出 $H$ 的上界的。

将各个段落结果取最大值即可。

时间复杂度为 $\mathcal{O}(m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()

    ds = []
    hs = []

    for _ in range(m):
        d, h = MII()
        ds.append(d)
        hs.append(h)

    ans = fmax(ds[0] - 1 + hs[0], n - ds[-1] + hs[-1])

    for i in range(1, m):
        diff_d = ds[i] - ds[i - 1]
        if abs(hs[i] - hs[i - 1]) > diff_d:
            exit(print('IMPOSSIBLE'))
        ans = fmax(ans, (hs[i] + hs[i - 1] + diff_d) // 2)

    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<pair<int, int>> notes(m);
    for (auto &[x, y]: notes) cin >> x >> y;

    int ans = max(notes[0].first - 1 + notes[0].second,
                  n - notes.back().first + notes.back().second);
    
    for (int i = 1; i < m; i ++) {
        auto [d1, h1] = notes[i - 1];
        auto [d2, h2] = notes[i];
        if (abs(h1 - h2) > d2 - d1) return cout << "IMPOSSIBLE", 0;
        ans = max(ans, (h1 + h2 + d2 - d1) / 2);
    }

    cout << ans;

    return 0;
}
```