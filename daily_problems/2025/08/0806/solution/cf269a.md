**提示 1：** 对于同一个 $k$ ，如何解决问题？

**提示 2：** 不同的 $k$ 有何影响？

假设只有一个数值的 $k$ ，则此时大箱子至少得取 $k+1$ ，因为等大的放不下。

而设我们取 $2^v$ 的箱子，则每一条边能放 $2^{v-k}$ 个， 所以总共能放 $2^{v-k}\times 2^{v-k}=4^{v-k}$ 个箱子，这个数需要大于 $a$ ，所以可以求解出最小的 $v$ 。

综合上述条件即可。

而不同的 $k$ 之间毫无影响，因为边长是倍数，不同的箱子之间不会挡住。

综上，主要是算 $4^x\geq v$ 的最小的 $x$ 这个可以 $\mathcal{O}(\log M)$ 解决，因此复杂度为 $\mathcal{O}(n\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    ans = 0
    
    for _ in range(n):
        k, a = MII()
        
        ans = fmax(ans, k + 1)
        
        while a > 1:
            a = (a + 3) // 4
            k += 1
        
        ans = fmax(ans, k)
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;
    
    int ans = 0;

    while (n --) {
        int k, a;
        cin >> k >> a;

        ans = max(ans, k + 1);
        while (a > 1) {
            a = (a + 3) / 4;
            k ++;
        }

        ans = max(ans, k);
    }

    cout << ans;

    return 0;
}
```