**提示 1：** 每个点的下一步是完全确定的。

**提示 2：** 根据上述逻辑作图。

首先，每个点如果行动，下一个点的位置是完全确定的。这个点怎么找到呢？我们从右侧遍历，维护一个当前凸包（是一个类似单调栈的东西），就可以找到每个点对应的下一个位置了。

将每个点连接到其下一步的位置，因为总共 $n-1$ 条边且都能到达 $n$ ，所以这是一棵树。

而我们其实是要总步数最小的到达一个点，那么对于 $u,v$ 而言，我们就只需求它们的 LCA 就行了，这一步不会的可以自行搜索 OI-WIKI 等资料。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    xs = []
    ys = []
    
    for _ in range(n):
        x, y = MII()
        xs.append(x)
        ys.append(y)
    
    rs = list(range(n))
    stk = [n - 1]
    
    depth = [0] * n
    
    for i in range(n - 2, -1, -1):
        while len(stk) > 1:
            x, y = xs[i], ys[i]
            x1, y1 = xs[stk[-1]], ys[stk[-1]]
            x2, y2 = xs[stk[-2]], ys[stk[-2]]
            
            if (y1 - y) * (x2 - x) < (y2 - y) * (x1 - x):
                stk.pop()
            else:
                break
        
        rs[i] = stk[-1]
        depth[i] = depth[stk[-1]] + 1
        stk.append(i)
    
    nth_parent = [[0] * n for _ in range(20)]
    nth_parent[0] = rs
    
    for i in range(19):
        for j in range(n):
            nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]]
    
    q = II()
    outs = []
    
    for _ in range(q):
        u, v = GMI()
        
        if depth[u] < depth[v]:
            u, v = v, u
        
        d = depth[u] - depth[v]
        
        while d:
            k = d & -d
            x = k.bit_length() - 1
            d -= k
            u = nth_parent[x][u]
        
        if u == v: outs.append(u + 1)
        else:
            for i in range(19, -1, -1):
                if nth_parent[i][u] != nth_parent[i][v]:
                    u = nth_parent[i][u]
                    v = nth_parent[i][v]
            
            outs.append(nth_parent[0][u] + 1)
    
    print(' '.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<long long> xs(n), ys(n);
    for (int i = 0; i < n; i ++)
        cin >> xs[i] >> ys[i];
    
    vector<int> rs(n, n - 1), depth(n, 0);
    vector<int> stk = {n - 1};

    for (int i = n - 2; i >= 0; i --) {
        while (stk.size() > 1) {
            long long x = xs[i], y = ys[i];
            long long x1 = xs[stk.back()], y1 = ys[stk.back()];
            long long x2 = xs[stk[stk.size() - 2]], y2 = ys[stk[stk.size() - 2]];

            if ((y1 - y) * (x2 - x) < (y2 - y) * (x1 - x)) stk.pop_back();
            else break;
        }

        rs[i] = stk.back();
        depth[i] = depth[stk.back()] + 1;
        stk.emplace_back(i);
    }


    vector<vector<int>> nth_parent(20, vector<int>(n));

    nth_parent[0] = rs;

    for (int i = 0; i < 19; i ++) {
        for (int j = 0; j < n; j ++) {
            nth_parent[i + 1][j] = nth_parent[i][nth_parent[i][j]];
        }
    }

    int q;
    cin >> q;

    while (q --) {
        int u, v;
        cin >> u >> v;
        u --, v --;

        if (depth[u] < depth[v]) swap(u, v);

        int d = depth[u] - depth[v];

        for (int i = 19; i >= 0; i --) {
            if (d >> i & 1) {
                u = nth_parent[i][u];
            }
        }

        if (u == v) cout << u + 1 << ' ';
        else {
            for (int i = 19; i >= 0; i --) {
                if (nth_parent[i][u] != nth_parent[i][v]) {
                    u = nth_parent[i][u];
                    v = nth_parent[i][v];
                }
            }

            cout << nth_parent[0][u] + 1 << ' ';
        }
    }

    return 0;
}
```