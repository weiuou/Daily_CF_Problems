**提示 1：** 注意 $f(x)$ 不可能很大。

虽然这里需要逐步确定 $f(x)$ 和 $g(x)$ ，但实际上没那么复杂。

因为这里的 $f(x)$ 最大只能是最大的二进制位数，也就是 $59$ 。所以考虑枚举 $f(x)$ 。

而对于每一个 $f(x)$ ，可能的 $g(x)$ 也只有 $\log_{f(x)}M$ 个，我们枚举这个 $g(x)$ ，则对应的 $x$ 需要在 $[l,r]$ 之间，且二进制位恰好有 $f(x)$ 位，且数值在 $[f(x)^{g(x)},f(x)^{g(x)+1})$ 之间。

这就是一个区间取交的问题，直接左端点取最大值，右端点取最小值，即可得到对应区间，在区间合法，即左端点小于右端点时，可以使用区间长度计算区间中元素个数，乘以 $g(x)$ 加入到结果中即可。

时间复杂度为 $\mathcal{O}(\log M\log\log M)$ ，考虑成 $\log x$ 在 $[2,\log M]$ 上的积分。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    mod = 10 ** 9 + 7
    
    for _ in range(t):
        l, r = MII()
        r += 1
        
        xl, xr = 2, 4
        ans = 0
        
        for fx in range(2, 60):
            xl *= 2
            xr *= 2
            
            vl = fmax(l, xl)
            vr = fmin(r, xr)
            
            if vl >= vr: continue
            
            nl, nr = 1, fx
            for v in range(1, 60):
                nl *= fx
                nr *= fx
                if nr <= vl: continue
                if nl >= vr: break
    
                cnt = fmin(vr, nr) - fmax(vl, nl)
                ans += cnt * v % mod
        
        outs.append(ans % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t, mod = 1e9 + 7;
    cin >> t;

    while (t --) {
        long long l, r;
        cin >> l >> r;

        r ++;
        long long xl = 2, xr = 4;
        int ans = 0;

        for (int fx = 2; fx < 60; fx ++) {
            xl <<= 1, xr <<= 1;

            long long vl = max(l, xl), vr = min(r, xr);
            if (vl >= vr) continue;

            long long nl = 1, nr = fx;

            for (int v = 1; v < 60; v ++) {
                nl = min(nl, vr / fx + 5) * fx;
                nr = min(nr, vr / fx + 5) * fx;

                if (nl >= vr) break;
                long long cnt = max(0ll, min(vr, nr) - max(vl, nl));
                ans += cnt % mod * v % mod;

                if (ans >= mod) ans -= mod;
            }
        }

        cout << ans << '\n';
    }

    return 0;
}
```