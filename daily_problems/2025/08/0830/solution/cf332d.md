**提示 1：** 这个性质看上去很神秘。如果很乱的图都可以满足要求的话，那么检查图是否满足条件就很难了。所以好好分析下图可能的形式。

先分析简单的情况。 $k=1$ 的情况下，每个单点就是所谓的 $k$ 大小的子集，每个点只能往外连出来一条边。于是每个点找其邻接边的边权即可。

$k=2$ 的情况下，考虑任意一组点 $(u,v)$ ，则其唯一对应于一个点 $w$ ，于是 $(u,w),(v,w)$ 都有边，且和点对 $(u,v)$ 一一对应。

于是考虑 $((u,w),(v,w))$ 的权值和计数。直接枚举 $w$ 即可， $u,v$ 只是选取了其邻接点。设 $w$ 度数是 $deg$ ，则对于 $(u,w)$ 而言， $v$ 有 $deg-1$ 种选法。因此，需要对答案增加 $deg\times W(u,w)$ 的贡献，最后除以 $n$ 个点选 $2$ 个的总方案数即可。

若 $k$ 更大呢？可以证明只有 $n=k+1$ 且为完全图的情况下是满足要求的。

考虑有边的两个点 $u,v$ ，则考虑包含 $u,v$ 的 $k$ 元集，可以找到 $w_1$ 和它们都有边。

进一步地，考虑包含 $u,v,w_1$ 的 $k$ 元集，可以找到 $w_2$ 和它们都有边。

这样一步步推，可以找到 $w_1,w_2,\dots,w_{k-1}$ ，形成一个完全子图。下一步这个子图就有 $k+1$ 个点了就推不下去了。

而对于任意两个点，其公共邻接点数量必须是 $k-1$ 。

- 如果不小于 $k$ ，那么，选取这些点的 $k$ 元子集，可以找到两个外侧点，不满足题设。

- 如果小于 $k-1$ ，则我们把这些点和给定的两个点组合起来，总大小不超过 $k$ ，找到一个 $k$ 元集包含它们，则存在一个新的点，使得这个点和这个 $k$ 元集的每个点都有边，即又找到了一个新的公共邻接点，矛盾。

我们先取出一个 $k+1$ 个点的完全子图，设其外侧有一个 $u$ ，则再取完全图内两点 $x_1,x_2$ ，包含 $u,x_1,x_2$ 的 $k$ 元集可以找到一个点 $x$ ，同时 $x$ 必须在完全图中，因为 $x_1,x_2$ 的公共邻接点只有 $k-1$ 个且都在完全图中。

接下来再取包含 $u,x_1,x$ 的 $k$ 元集，找到了另一个点 $y$ 。因为 $x,x_1$ 都在完全图中，所以 $y$ 也在完全图中（逻辑跟前面的类似）。

而此时， $u$ 成为了 $x,y$ 的邻接点，这与 $x,y$ 的邻接点都在完全图内矛盾。

所以原图只能是 $k+1$ 点完全图。

这样，总共就有 $n$ 种子图选法。而每条边恰好被计算两次，即选取去掉 $u$ 和去掉 $v$ 的 $k$ 元子集时。所以计算边权总和乘以 $2$ ，再除以 $n$ 即可得到答案。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k = MII()

    grid = [[-1] * n for _ in range(n)]

    for i in range(n - 1):
        nums = LII()
        
        for j in range(0, n - i - 1):
            grid[i][i + j + 1] = grid[i + j + 1][i] = nums[j]

    if k == 2:
        ans = 0
        
        for i in range(n):
            cnt = 0
            tot = 0
            
            for j in range(n):
                if grid[i][j] != -1:
                    cnt += 1
                    tot += grid[i][j]
            
            ans += (cnt - 1) * tot
        
        print(ans // (n * (n - 1) // 2))
    else:
        ans = 0
        
        for i in range(n):
            for j in range(n):
                if grid[i][j] != -1:
                    ans += grid[i][j]

        print(ans // n)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, k;
    cin >> n >> k;

    vector<vector<int>> grid(n, vector<int>(n, -1));

    for (int i = 0; i < n; i ++) {
        for (int j = i + 1; j < n; j ++) {
            cin >> grid[i][j];
            grid[j][i] = grid[i][j];
        }
    }

    if (k == 2) {
        long long ans = 0;
        for (int i = 0; i < n; i ++) {
            long long tot = 0, cnt = 0;
            for (int j = 0; j < n; j ++) {
                if (grid[i][j] != -1) {
                    cnt ++;
                    tot += grid[i][j];
                }
            }
            ans += (cnt - 1) * tot;
        }
        cout << ans / (1ll * n * (n - 1) / 2);
    }
    else {
        long long ans = 0;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < n; j ++) {
                if (grid[i][j] != -1) {
                    ans += grid[i][j];
                }
            }
        }
        cout << ans / n;
    }

    return 0;
}
```