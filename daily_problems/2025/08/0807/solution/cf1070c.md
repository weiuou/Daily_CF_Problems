**提示 1：** 每个时刻分别考虑。有哪些物品？求什么东西？

考虑顺序遍历时间点，则类似于扫描线，会有一些物品加入，一些物品离开。我们需要在这个过程中维护一些东西。

我们要找什么呢？我们显然选取最便宜的，所以需要维护一个关于价格的有序结构。同时我们要找到价格最低的总数为 $k$ 的物品。

用懒删除堆是不对的！因为你可能来很多次巨便宜、数量巨多、但是间隔着来的物品，这样，原有的堆（一些只有一个的较贵的，但是持续时间超长的物品）的东西会在两个堆之间反复横跳。

事实上，应该直接建立一个值域上的数据结构， $1,2,\dots$ 上的数值表示这个物品的数量和总价值。这样前缀就相当于选了最便宜的物品，完成了贪心。增删过程中维护有序结构都可以用类似的方式。

我们要找到其中前缀和超过 $k$ 的最小下标，这个可以通过树状数组 / 线段树的二分快速解决。而多取的物品直接根据多取了多少，再用多取的东西的单价进行调整即可。

时间复杂度为 $\mathcal{O}((n+m)\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k, m = MII()
    changed = [[] for _ in range(n + 1)]
    
    cs = []
    ps = []
    
    for idx in range(m):
        l, r, c, p = MII()
        
        changed[l - 1].append(idx)
        changed[r].append(~idx)
        
        cs.append(c)
        ps.append(p)
    
    M = 10 ** 6 + 1
    fen_cnt = FenwickTree(M)
    fen_tot = FenwickTree(M)
    
    ans = 0
    
    for i in range(n):
        for idx in changed[i]:
            if idx >= 0:
                fen_cnt.add(ps[idx], cs[idx])
                fen_tot.add(ps[idx], cs[idx] * ps[idx])
            else:
                idx = ~idx
                fen_cnt.add(ps[idx], -cs[idx])
                fen_tot.add(ps[idx], -cs[idx] * ps[idx])
        
        p = fen_cnt.bisect_min_larger(k)
        if p < M: ans += fen_tot.sum(p) - (fen_cnt.sum(p) - k) * p
        else: ans += fen_tot.sum(M - 1)
    
    print(ans)
```

C++ 做法如下——

```cpp []
typedef pair<long long, long long> node;

node e() {
    return {0, 0};
}

node op(node x, node y) {
    return {x.first + y.first, x.second + y.second};
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, k, m;
    cin >> n >> k >> m;

    vector<vector<int>> changed(n + 1);
    vector<long long> cs(m), ps(m);

    for (int i = 0; i < m; i ++) {
        int l, r;
        cin >> l >> r >> cs[i] >> ps[i];
        changed[l - 1].emplace_back(i);
        changed[r].emplace_back(~i);
    }

    int M = 1e6 + 5;
    long long ans = 0;
    atcoder::segtree<node, op, e> seg(M);

    for (int i = 0; i < n; i ++) {
        for (auto idx: changed[i]) {
            if (idx >= 0) {
                auto [tot, cnt] = seg.get(ps[idx]);
                tot += ps[idx] * cs[idx];
                cnt += cs[idx];
                seg.set(ps[idx], {tot, cnt});
            }
            else {
                idx = ~idx;
                auto [tot, cnt] = seg.get(ps[idx]);
                tot -= ps[idx] * cs[idx];
                cnt -= cs[idx];
                seg.set(ps[idx], {tot, cnt});
            }
        }

        auto p = seg.max_right(0, [&] (node v) {return v.second < k;});
        if (p == M) ans += seg.all_prod().first;
        else {
            auto [tot, cnt] = seg.prod(0, p);
            ans += tot + (k - cnt) * p;
        }
    }

    cout << ans;

    return 0;
}
```