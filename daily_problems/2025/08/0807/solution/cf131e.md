**提示 1：** 考虑所有方向上，哪两个 queen 会相互攻击？

实质上总共只有四个方向——竖着、横着、两种方向的斜着。

而我们枚举方向。考虑一个方向时，相当于这个方向上有若干条直线。而只有在同一条直线上，且相邻的点，才能相互攻击到。

所以我们先把同一直线的点找出来，再关于其坐标排序（跟初始选直线的规则要区分开），排序后相邻的点就是直线上相邻的了，分别对结果加一。

最后对上述结果统计即可。

时间复杂度为 $\mathcal{O}(n\log n)$ ，来源于排序。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    
    xs = []
    ys = []
    
    for _ in range(m):
        x, y = MII()
        xs.append(x)
        ys.append(y)
    
    cnt = [0] * m
    
    tmp = [[] for _ in range(2 * n + 1)]
    
    for i in range(2 * n + 1):
        tmp[i].clear()
    
    for i in range(m):
        tmp[xs[i]].append(i)
    
    for i in range(2 * n + 1):
        tmp[i].sort(key=lambda x: ys[x])
        
        for j in range(1, len(tmp[i])):
            cnt[tmp[i][j]] += 1
            cnt[tmp[i][j - 1]] += 1
    
    for i in range(2 * n + 1):
        tmp[i].clear()
    
    for i in range(m):
        tmp[ys[i]].append(i)
    
    for i in range(2 * n + 1):
        tmp[i].sort(key=lambda x: xs[x])
        
        for j in range(1, len(tmp[i])):
            cnt[tmp[i][j]] += 1
            cnt[tmp[i][j - 1]] += 1
    
    for i in range(2 * n + 1):
        tmp[i].clear()
    
    for i in range(m):
        tmp[xs[i] + ys[i]].append(i)
    
    for i in range(2 * n + 1):
        tmp[i].sort(key=lambda x: xs[x])
        
        for j in range(1, len(tmp[i])):
            cnt[tmp[i][j]] += 1
            cnt[tmp[i][j - 1]] += 1
    
    for i in range(2 * n + 1):
        tmp[i].clear()
    
    for i in range(m):
        tmp[xs[i] - ys[i]].append(i)
    
    for i in range(2 * n + 1):
        tmp[i].sort(key=lambda x: xs[x])
        
        for j in range(1, len(tmp[i])):
            cnt[tmp[i][j]] += 1
            cnt[tmp[i][j - 1]] += 1
    
    ans = [0] * 9
    for x in cnt:
        ans[x] += 1
    
    print(*ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<pair<int, int>> pts(m);
    for (auto &[x, y]: pts)
        cin >> x >> y;
    
    vector<int> cnt(m);
    
    {
        map<int, vector<int>> mp;
        for (int i = 0; i < m; i ++)
            mp[pts[i].first].emplace_back(i);
        
        for (auto &[k, v]: mp) {
            sort(v.begin(), v.end(), [&] (int i, int j) {
                return pts[i].second < pts[j].second;
            });

            int l = v.size(); 
            for (int i = 1; i < l; i ++)
                cnt[v[i - 1]] ++, cnt[v[i]] ++; 
        }
    }
    
    {
        map<int, vector<int>> mp;
        for (int i = 0; i < m; i ++)
            mp[pts[i].second].emplace_back(i);
        
        for (auto &[k, v]: mp) {
            sort(v.begin(), v.end(), [&] (int i, int j) {
                return pts[i].first < pts[j].first;
            });

            int l = v.size(); 
            for (int i = 1; i < l; i ++)
                cnt[v[i - 1]] ++, cnt[v[i]] ++; 
        }
    }
    
    {
        map<int, vector<int>> mp;
        for (int i = 0; i < m; i ++)
            mp[pts[i].first + pts[i].second].emplace_back(i);
        
        for (auto &[k, v]: mp) {
            sort(v.begin(), v.end(), [&] (int i, int j) {
                return pts[i].second < pts[j].second;
            });

            int l = v.size(); 
            for (int i = 1; i < l; i ++)
                cnt[v[i - 1]] ++, cnt[v[i]] ++; 
        }
    }
    
    {
        map<int, vector<int>> mp;
        for (int i = 0; i < m; i ++)
            mp[pts[i].first - pts[i].second].emplace_back(i);
        
        for (auto &[k, v]: mp) {
            sort(v.begin(), v.end(), [&] (int i, int j) {
                return pts[i].second < pts[j].second;
            });

            int l = v.size(); 
            for (int i = 1; i < l; i ++)
                cnt[v[i - 1]] ++, cnt[v[i]] ++; 
        }
    }

    vector<int> ans(9, 0);
    for (auto &x: cnt) ans[x] ++;

    for (auto &x: ans) cout << x << ' ';

    return 0;
}
```