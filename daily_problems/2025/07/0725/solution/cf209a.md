**提示 1：** 为了新增元素，子序列的重要信息是什么？以之为状态。

我们考虑维护 DP，看目前的合法子序列的计数。

此时如果新来了个元素，可能会加入之前的某些子序列。而为了判断某个子序列能否加入新元素，我们需要维护原有子序列的最后一个元素。

因此，设两种颜色分别为 $0, 1$ ，考虑当前以 $0$ 结尾的子序列个数是 $dp_0$ ，以 $1$ 结尾的子序列个数是 $dp_1$ 。

则新来了一个 $0$ 元素后，这个元素本身是以 $0$ 结尾的合法子序列。同时所有的以 $1$ 结尾的合法子序列全部可以新增这个元素变成以 $0$ 结尾的合法子序列，因此转移后的以 $0$ 结尾的合法子序列有 $dp_0+dp_1+1$ 个。

同理，新来一个 $1$ 元素后，以 $1$ 结尾的合法子序列个数应该由 $dp_0+dp_1+1$ 更新。

因此顺序遍历每一项并判断其颜色，进行对应的状态转移即可。

时间复杂度为 $\mathcal{O}(n)$ 。如果将两轮状态转移一次进行，就可以进一步使用矩阵快速幂进行优化，可以自行尝试！

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    mod = 10 ** 9 + 7
    
    dp0, dp1 = 0, 0
    
    for i in range(n):
        if i % 2 == 0:
            dp0 = (dp0 + dp1 + 1) % mod
        else:
            dp1 = (dp0 + dp1 + 1) % mod
    
    print((dp0 + dp1) % mod)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, mod = 1e9 + 7;
    cin >> n;

    int dp0 = 0, dp1 = 0;
    for (int i = 0; i < n; i ++) {
        if (i & 1) dp1 = (dp0 + dp1 + 1) % mod;
        else dp0 = (dp0 + dp1 + 1) % mod;
    }

    cout << (dp0 + dp1) % mod;

    return 0;
}
```