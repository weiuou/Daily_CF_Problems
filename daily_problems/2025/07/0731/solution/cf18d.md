**提示 1：** 不考虑 $2^v$ 的问题，这题怎么解决？

考虑到第 $i$ 次事件时，能获得的最大收益。

则如果第 $i$ 次是拿到东西，则当次无法获得收益，结果与 $i-1$ 次的情况一致。

否则，我们只需找到最近一次获得对应物品的时间，假设是 $j$ ，则最大收益为 $dp[j-1]$ 加上该物品的收益。

但这里，物品的收益会达到 $2^x$ ，这会使得整体数值很大。此时适合用 Python 的大数解决问题。不过如果你能借这个机会写一个高精度模拟也是件很好的事儿，这里需要进行加法和数字大小的比较，封装的时候可以配上减法和乘法。

时间复杂度为 $\mathcal{O}(nx)$

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    last = [-1] * 2005
    n = II()

    dp = [0] * (n + 1)

    for i in range(1, n + 1):
        s, x = LI()
        x = int(x)
        
        dp[i] = dp[i - 1]
        
        if s[0] == 'w':
            last[x] = i - 1
        else:
            if last[x] != -1:
                dp[i] = fmax(dp[i], dp[last[x]] + (1 << x))

    print(dp[n])
```