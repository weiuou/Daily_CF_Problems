**提示 1：** 考虑那些没有动过的元素，他们应该满足什么条件？

**提示 2：** 如何计算不动的元素的最大数量？

动的元素会放到最前面或者最后面，所以不动的元素一定是中间连续的一段。

也就是说，不动的元素作为原序列的一个子序列，最后得是最终序列中连续的一段。

如果我们找到了这么一个子序列，那么剩余的元素分别只需一次操作就可以排好了。假设选取的子序列的数值为 $[a,a+1,\dots,b]$ ，那么可以先将 $a-1,\dots,1$ 依次放到前面去，再把 $b+1,\dots,n$ 依次放到后面去。

这样，我们就要求最长的子序列，该子序列相邻两项差为 1 。

假设到第 $i$ 个位置时，最后一项为 $y$ 的子序列的最大长度为 $dp[i][y]$ ，那么考虑第 $i+1$ 个位置，只需更新 $dp[i+1][nums[i+1]]$ 为 $dp[i][nums[i+1]-1]+1$ 即可，其余位置无需改变。

因此实际上可以只开一个数组，且每遍历一个元素改变一个位置的对应 DP 结果就行。

最后，对所有 DP 结果取最大值，用 $n$ 减掉它就是答案了。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()

    dp = [0] * (n + 1)
    for v in nums:
        dp[v] = dp[v - 1] + 1

    print(n - max(dp))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> dp(n + 1, 0);
    for (int i = 0; i < n; i ++) {
        int x;
        cin >> x;
        dp[x] = dp[x - 1] + 1;
    }

    cout << n - *max_element(dp.begin(), dp.end());

    return 0;
}
```