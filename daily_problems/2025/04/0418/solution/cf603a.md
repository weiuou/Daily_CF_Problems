**提示 1：** 本题可以使用 DP，但是考虑子段翻转可以考虑相邻两项的关系。

**提示 2：** 有多少个“相邻两项的关系”改变了？

这题有 DP 做法，可以自行思考——取一个子段翻转等价于将串分为三段，中间的一段翻转，于是考虑到第 $i$ 个位置时，在第 $j$ 段的最优结果。

当然本题还有更容易的做法。

本题最后计算的是，将数组分为一段 $1$ 一段 $0$ 之类的一段段后，整个数组最后变成了几段。实质上，我们只在意中间段落的分割出，即 $01/10$ 出现了几次。

考虑反转后，可能多出现几个 $01/10$ 呢？新出现的位置只可能是段的边界位置，因此至多增加两个。

假设原来有 $k$ 个 $01/10$ ，现在最多有 $k+2$ 个，意味着分为了 $k+3$ 段，而答案不超过 $n$ ，因此输出 $\min(k+3, n)$ 。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    s = I()

    total = 0
    for i in range(1, n):
        if s[i] != s[i - 1]:
            total += 1
    print(fmin(total + 3, n))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    string s;
    cin >> n >> s;

    int total = 0;
    for (int i = 1; i < n; i ++)
        total += (s[i] != s[i - 1]);

    cout << min(total + 3, n);

    return 0;
}
```