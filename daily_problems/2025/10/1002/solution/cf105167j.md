**提示 1：** 先看最优解何时取到。

**提示 2：** 最小交换次数等价于求 “逆序对” 。

先求最大值，并看看何时取到。

求和式子去绝对值，有 $n-1$ 项为正， $n-1$ 项为负，且除了第一项和最后一项外，每个元素在其中出现两次。

所以不妨让正的都是大的数，负的都是小的数，即 $n,n-1,\dots,n/2+2$ 都算为正，且可使用两次， $1,2,\dots,n/2-1$ 都算为负，且可使用两次， $n/2,n/2-1$ 分别为正和负，均使用一次即可。

根据上面这件事，可以求出最值是 $n^2/2-1$ 。

什么时候取到最值呢？就是当大数隔一个出现一个的情况，且 $n/2+1$ 在边缘。

所以总共实际上只有两种配置，一种是 $n/2+1$ 在开头，一种是在结尾，剩余元素都隔一个出现一个。

我们要求最小交换次数，在求逆序对的时候我们遇到过类似的问题，所以只要我们能够给每个元素赋值，并保证最后的结果就是我们赋值后的升序，也就只需要求逆序对个数了。

我们以 $n/2+1$ 在开头为例，此时 $n/2+1$ 可以赋值为 $1$ ， $n/2$ 只能在结尾赋值为 $n$ 。对于其他大数，要间隔开来，所以赋值为 $3,5,\dots$ ，其他小数赋值为 $2,4,\dots$ 。而为了使得逆序对尽可能少，我们这些 $3,5,\dots$ 和 $2,4,\dots$ 内部不应该产生逆序对，所以顺序赋值即可。

下面是 $\mathcal{O}(n\log n)$ 的代码。

当然，因为顺序赋值，实际上逆序对是可以 $\mathcal{O}(n)$ 求解的，只需求解类似于 “我写上一个偶数 $2k$ 时，此前奇数序列写到哪里了” 的问题就行。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        ans = n * n
        tmp = [0] * n
        
        pt1 = 2
        pt2 = 1
        
        for i in range(n):
            if nums[i] == n // 2: tmp[i] = 0
            elif nums[i] == n // 2 + 1: tmp[i] = n - 1
            elif nums[i] < n // 2:
                tmp[i] = pt1
                pt1 += 2
            else:
                tmp[i] = pt2
                pt2 += 2
        
        fen = FenwickTree(n)
        
        total = 0
        for i in range(n - 1, -1, -1):
            total += fen.rsum(0, tmp[i])
            fen.add(tmp[i], 1)
        ans = fmin(ans, total)
        
        pt1 = 1
        pt2 = 2
        
        for i in range(n):
            if nums[i] == n // 2: tmp[i] = n - 1
            elif nums[i] == n // 2 + 1: tmp[i] = 0
            elif nums[i] < n // 2:
                tmp[i] = pt1
                pt1 += 2
            else:
                tmp[i] = pt2
                pt2 += 2
        
        fen.init()
        
        total = 0
        for i in range(n - 1, -1, -1):
            total += fen.rsum(0, tmp[i])
            fen.add(tmp[i], 1)
        ans = fmin(ans, total)
        
        outs.append(f'{n * n // 2 - 1} {ans}')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    auto calculate_inversions = [&] (int n, vector<int> &nums) -> long long {
        atcoder::fenwick_tree<int> fen(n + 1);
        long long ans = 0;

        for (int i = n - 1; i >= 0; i --) {
            ans += fen.sum(0, nums[i]);
            fen.add(nums[i], 1);
        }

        return ans;
    };

    int t;
    cin >> t;

    while (t --) {
        int n;
        cin >> n;

        vector<int> nums(n);
        for (auto &x: nums) cin >> x;

        int pt1, pt2;
        vector<int> tmp(n);
        long long ans = 1ll * n * n;

        pt1 = 2, pt2 = 1;

        for (int i = 0; i < n; i ++) {
            if (nums[i] == n / 2) tmp[i] = 0;
            else if (nums[i] == n / 2 + 1) tmp[i] = n - 1;
            else if (nums[i] < n / 2) tmp[i] = pt1, pt1 += 2;
            else tmp[i] = pt2, pt2 += 2;
        }


        ans = min(ans, calculate_inversions(n, tmp));

        pt1 = 1, pt2 = 2;

        for (int i = 0; i < n; i ++) {
            if (nums[i] == n / 2) tmp[i] = n - 1;
            else if (nums[i] == n / 2 + 1) tmp[i] = 0;
            else if (nums[i] < n / 2) tmp[i] = pt1, pt1 += 2;
            else tmp[i] = pt2, pt2 += 2;
        }

        ans = min(ans, calculate_inversions(n, tmp));

        cout << 1ll * n * n / 2 - 1 << ' ' << ans << '\n';
    }

    return 0;
}
```