**提示 1：** 注意数组是递增的，且值域也是 $[1,n]$ 。

**提示 2：** 可以一个个试。

我们的查询次数里面不带 $\log$ 之类的，所以二分什么的就别想了。

因为数组是递增的，所以一个元素确定可以给前后元素的确定提供方便。

考虑在数组开头加个 $1$ ，则数组仍然是单调不减的，而每个元素只需通过查询，得到比前一个数多多少就行。

而总的增加次数是不会超过值域上界 $n$ 的，所以顺序遍历下来就好。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    def query(i, x):
        print('?', i + 1, x, flush=True)
        c = I()
        return 1 if c == '<' else 0
    
    def answer(ans):
        print('!', *ans)
    
    n = II()
    ans = [0] * n
    
    cur = 1
    for i in range(n):
        while query(i, cur):
            cur += 1
        ans[i] = cur
    
    answer(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    auto query = [&] (int i, int x) -> bool {
        cout << "? " << i + 1 << ' ' << x << endl;
        char c; cin >> c;
        return c == '<';
    };

    int n;
    cin >> n;

    vector<int> ans(n);

    int cur = 1;
    for (int i = 0; i < n; i ++) {
        while (query(i, cur)) cur ++;
        ans[i] = cur;
    }

    cout << '!';
    for (auto &x: ans) cout << ' ' << x;

    return 0;
}
```