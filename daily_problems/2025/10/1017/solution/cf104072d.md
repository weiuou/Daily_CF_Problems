**提示 1：** 注意我们要考虑的是正方形的边框。如何快速锁定？

**提示 2：** 正方形本身可能很多，如何一起考虑一系列的正方形以降低时间复杂度？

我们考虑怎么快速确定一个正方形的边框。

发现只需知道左上角和右下角就好了。

而这两个角一定在一个斜线上，因此考虑枚举斜线。

对于左上角的位置，根据其往右和往下连续的 $1$ 的个数可以给出一个正方形边长的上界 $v_1[i]$ 。对于右下角的位置，根据其往左和往上连续的 $1$ 的个数可以给出一个正方形边长的上界。

则 $(i,j)\ (i\leq j)$ 能形成正方形的条件就是 $j-i+1\leq\min(v_1[i],v_2[j])$ 。这就是个比较典型的一维形式，只要我们能优化 $\mathcal{O}(n^2)$ 的算法就可以让整体问题得到解答。

我们不妨忽略 $i\leq j$ 这个条件，因为只需最后减去 $i\gt j$ 的所有 $(i,j)$ 对数即可。

而上述条件等价于 $j-i+1\leq v_1[i], j-i+1\leq v_2[j]$ ，即 $j\leq i+v_1[i]-1,j+v_2[j]\leq i-1$ ，相当于把所有 $(j,j+v_2[j])$ 看成二维平面上的点，对于所有 $i$ 求 $(i+v_1[i]-1,i-1)$ 左下角的点数。这是典型的二位数点问题，可以轻松优化成 $\mathcal{O}(n\log n)$ 。

具体的，可以把所有点和查询关于第一个维度排序，顺序遍历的过程中解答所有查询的问题。第一个维度已经满足了，我们相当于只需在新增 $j+v_2[j]$ 的过程中，数第二个维度比 $i-1$ 更小的点的数量，这件事很容易用树状数组等方式实现。

因此总共枚举 $\mathcal{O}(n)$ 条斜线，时间复杂度为 $\mathcal{O}(n^2\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    grid = [LII() for _ in range(n)]
    
    u = [x[:] for x in grid]
    d = [x[:] for x in grid]
    l = [x[:] for x in grid]
    r = [x[:] for x in grid]
    
    for i in range(1, n):
        for j in range(n):
            if u[i][j]:
                u[i][j] = u[i - 1][j] + 1
    
    for i in range(n - 2, -1, -1):
        for j in range(n):
            if d[i][j]:
                d[i][j] = d[i + 1][j] + 1
    
    for i in range(n):
        for j in range(1, n):
            if l[i][j]:
                l[i][j] = l[i][j - 1] + 1
    
    for i in range(n):
        for j in range(n - 2, -1, -1):
            if r[i][j]:
                r[i][j] = r[i][j + 1] + 1
    
    def solve(x, y):
        v1 = []
        v2 = []
        
        while x < n and y < n:
            v1.append(fmin(d[x][y], r[x][y]) - 1)
            v2.append(fmin(u[x][y], l[x][y]) - 1)
            x += 1
            y += 1
        
        k = len(v1)
        
        ans = 0
        
        fen = FenwickTree(k + 1)
        tmp = [[] for _ in range(k + 1)]
        
        for i in range(k):
            tmp[i - v2[i]].append(i)
        
        for i in range(k):
            for j in tmp[i]:
                fen.add(j, 1)
            ans += fen.sum(i + v1[i])
        return ans - k * (k - 1) // 2
    
    ans = solve(0, 0)
    for i in range(1, n):
        ans += solve(0, i) + solve(i, 0)
    
    print(ans)
```

C++ 做法如下——

```cpp []

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<vector<int>> grid(n, vector<int>(n));
	for (auto &x: grid) for (auto &y: x) cin >> y;

	vector<vector<int>> u = grid, d = grid, l = grid, r = grid;

	for (int i = 1; i < n; i ++) {
		for (int j = 0; j < n; j ++) {
			if (u[i][j]) u[i][j] = u[i - 1][j] + 1;
		}
	}

	for (int i = n - 2; i >= 0; i --) {
		for (int j = 0; j < n; j ++) {
			if (d[i][j]) d[i][j] = d[i + 1][j] + 1;
		}
	}

	for (int i = 0; i < n; i ++) {
		for (int j = 1; j < n; j ++) {
			if (l[i][j]) l[i][j] = l[i][j - 1] + 1;
		}
	}

	for (int i = 0; i < n; i ++) {
		for (int j = n - 2; j >= 0; j --) {
			if (r[i][j]) r[i][j] = r[i][j + 1] + 1;
		}
	}

	auto solve = [&] (int x, int y) -> int {
		vector<int> v1, v2;

		while (x < n & y < n) {
			v1.emplace_back(min(d[x][y], r[x][y]) - 1);
			v2.emplace_back(min(u[x][y], l[x][y]) - 1);
			x ++, y ++;
		}
		
		int k = v1.size(), ans = 0;

		atcoder::fenwick_tree<int> fen(k + 1);
		vector<vector<int>> tmp(k + 1);

		for (int i = 0; i < k; i ++)
			tmp[i - v2[i]].emplace_back(i);
		
		for (int i = 0; i < k; i ++) {
			for (auto &j: tmp[i]) fen.add(j, 1);
			ans += fen.sum(0, i + v1[i] + 1);
		}

		return ans - k * (k - 1) / 2;
	};

	long long res = solve(0, 0);
	for (int i = 1; i < n; i ++)
		res += solve(0, i) + solve(i, 0);
	cout << res;

	return 0;
}
```