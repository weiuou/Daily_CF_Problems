**提示 1：** 线性代数。

**提示 2：** 矩阵乘法有结合律。

考虑行向量 $u=(a_1,a_2,a_3,\dots,a_n),v=(b_1,b_2,b_3,\dots,b_n)$ ，则矩阵就是 $a'b$ ，其中 $a'$ 是 $a$ 的转置。

我们要求 $(a'b)^k$ ，方阵运算没那么方便，但是我们相当于求的是：

$(a'b)(a'b)(a'b)\dots(a'b)$

而矩阵乘法有结合律，所以变成：

$a'(ba')(ba')\dots(ba')b=a'(ba')^{k-1}b$

而 $ba'$ 就是向量的点乘结果，所以中间的部分做完了，也就是个标量。剩余的就只有 $a'b$ ，也就是原矩阵，原矩阵的数值和就是两个序列的数值和相乘，可以使用乘法分配律。

时间复杂度为 $\mathcal{O}(n+\log k)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k = MII()
    v1 = LII()
    v2 = LII()
    
    mod = 998244353
    tot1 = sum(v1) % mod
    tot2 = sum(v2) % mod
    dot_val = sum(v1[i] * v2[i] % mod for i in range(n)) % mod
    
    print(tot1 * tot2 % mod * pow(dot_val, k - 1, mod) % mod)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, k;
    cin >> n >> k;

    vector<int> v1(n), v2(n);
    for (auto &x: v1) cin >> x;
    for (auto &x: v2) cin >> x;

    int mod = 998244353;

    int tot1 = 0, tot2 = 0, dot = 0;

    for (auto &x: v1) tot1 += x, tot1 %= mod;
    for (auto &x: v2) tot2 += x, tot2 %= mod;

    for (int i = 0; i < n; i ++) {
        dot += 1ll * v1[i] * v2[i] % mod;
        dot %= mod;
    }

    int ans = 1ll * tot1 * tot2 % mod * quickPow(dot, k - 1, mod) % mod;

    cout << (ans + mod) % mod;

    return 0;
}
```