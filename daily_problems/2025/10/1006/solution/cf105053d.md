**提示 1：** 博弈——想想 $N$ 有哪些不同情况。

如果 $N=1$ ，输出 `'N'` 。

如果 $N$ 只有一个质因子，那么第二个人的主要目标就是让第一个人拿到 $1$ ，这种情况下如果次数是奇数就没办法了，是偶数的话就必胜。

如果 $N$ 有两个质因子，且是 $pq$ 的形式，那么第一个人先拿到 $pq$ 后随便拿到 $p$ 或者 $q$ 都赢定了。

否则，至少被一个 $pq^2$ 整除， $p,q$ 是不同的质数，那么如果总因子个数是奇数，则第二个人可以迫使第一个人拿到 $1$ ；否则，考虑两对数 $\{1,q\},\{p,p^2\}$ ，第二个人可以迫使第一个人拿到第一组数的一个和第二组数的一个，这样这两个数就互质了。所以这种情况下必输。

如果 $N$ 至少有三个质因子。类似于上面的，在因子个数奇数的情况下逼迫对方拿到 $1$ ，否则构造两对数 $\{1,p\},\{q,r\}$ ，其中质数 $p,q,r$ 是 $N$ 因子，也就完成说明，所以也必输。

时间复杂度为 $\mathcal{O}(M^{0.5})$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    if n == 1:
        exit(print('N'))
    
    pws = []
    
    for i in range(2, 10 ** 6 + 1):
        if n % i == 0:
            pws.append(0)
            
            while n % i == 0:
                pws[-1] += 1
                n //= i
    
    if n > 1:
        pws.append(1)
    
    if len(pws) > 2: print('N')
    elif len(pws) == 1: print('NY'[pws[0] % 2])
    elif max(pws) == 1: print('Y')
    else: print('N')
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    long long n;
    cin >> n;

    if (n == 1) return cout << 'N', 0;

    vector<int> pws;

    for (int i = 2; i <= 1000000; i ++) {
        if (n % i == 0) {
            pws.emplace_back(0);

            while (n % i == 0) {
                pws.back() ++;
                n /= i;
            }
        }
    }

    if (n > 1) pws.emplace_back(1);

    if (pws.size() > 2) cout << 'N';
    else if (pws.size() == 1) cout << "NY"[pws[0] & 1];
    else if (max(pws[0], pws[1]) == 1) cout << 'Y';
    else cout << 'N';

    return 0;
}
```