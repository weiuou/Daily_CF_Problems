**提示 1：** 用一个方式给排列标号。

**提示 2：** 变换相当于什么？

**提示 3：** 能否 $\mathcal{O}(n)$ 实现？

我们相当于找一个排列往后 $n !/2$ 个的排列。

那我们怎么知道目前排列是第几个呢？

我们考虑从前往后一个一个位确定。

在第一个位可以任选 $n$ 个元素，第二个位可以在剩余 $n-1$ 个元素中选，以此类推。

所以第一个位置选一个元素，后面的元素的方案数总是 $(n-1)!$ ，接下来第二位再选一个元素，后面的方案数总是 $(n-2)!$ ，以此类推。

所以考虑第 $i$ 个元素是 $[i,n]$ 中第 $K_i$ 大的 ，则当前排列是第 $v=(K_1-1)(n-1)!+(K_2-1)(n-2)!+\dots+(K_n-1)\times 0!+1$ 个。

而我们要求第 $v+n!/2$ 大的排列，然而这并不会太改变上面的这个式子：

$v=(K_1-1)(n-1)!+(K_2-1)(n-2)!+\dots+(K_n-1)\times 0!+1+n!/2$

$=(K_1-1)(n-1)!+(K_2-1+n(n-1)/2)(n-2)!+\dots+(K_n-1)\times 0!+1$

所以上述第 $K_i$ 大形成的这个数组并没有怎么变，只是从 $(K_1,K_2,\dots,K_n)$ 变换成 $(K_1,K_2+n(n-1)/2,\dots,K_n)$ 。（注意这里 $K_2-1+n(n-1)/2$ 可能比较大，只需关于 $n-1$ 取模，剩余的部分都是一些 $(n-1)!$ 的倍数，加到第一位就好）

得到了这个序列后，我们从前往后确定，每个数是剩余数中第 $K_i$ 大的，很容易用有序结构维护。

但还有复杂度更好的做法。注意到 $K_3,\dots,K_n$ 完全不变，所以后面的部分大小顺序保持不变。所以只需知道后面的数组有哪些数，从小到大一一对应起来形成映射即可。而这件事只需我们记录 $1\sim N$ 哪些数出现过，就可以快速得到排序结果。综上，是先处理前两项，后面看剩余数的一一对应。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    nums = LII()
    
    tmp = [nums[0] - 1, nums[1] - 1]
    if tmp[1] > tmp[0]:
        tmp[1] -= 1
    
    tmp[1] += n * (n - 1) // 2
    
    tmp[0] += tmp[1] // (n - 1)
    tmp[1] %= n - 1
    tmp[0] %= n
    
    ans = [tmp[0] + 1, tmp[1] + 1]
    if ans[1] >= ans[0]: ans[1] += 1
    
    vis1 = [0] * (n + 1)
    vis2 = [1] * (n + 1)
    
    for i in range(2, n):
        vis1[nums[i]] = 1
    
    for x in ans:
        vis2[x] = 0
    
    mapping = [0] * (n + 1)
    p1, p2 = 1, 1
    
    for _ in range(n - 2):
        while not vis1[p1]: p1 += 1
        while not vis2[p2]: p2 += 1
        mapping[p1] = p2
        p1 += 1
        p2 += 1
    
    for i in range(2, n):
        ans.append(mapping[nums[i]])
    
    print(' '.join(map(str, ans)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<int> nums(n);
	for (auto &v: nums) cin >> v;

	vector<long long> tmp = {nums[0] - 1, nums[1] - 1};
	if (tmp[1] > tmp[0]) tmp[1] --;

	tmp[1] += 1ll * n * (n - 1) / 2;
	tmp[0] += tmp[1] / (n - 1);
	tmp[1] %= n - 1;
	tmp[0] %= n;

	vector<int> ans = {tmp[0] + 1, tmp[1] + 1};
	if (ans[1] >= ans[0]) ans[1] ++;

	vector<int> vis1(n + 1, 0), vis2(n + 1, 1);

	for (int i = 2; i < n; i ++)
		vis1[nums[i]] = 1;
	
	for (auto &x: ans)
		vis2[x] = 0;
	
	vector<int> mapping(n + 1, 0);
	int p1 = 1, p2 = 1;

	for (int _ = 0; _ < n - 2; _ ++) {
		while (!vis1[p1]) p1 ++;
		while (!vis2[p2]) p2 ++;
		mapping[p1 ++] = p2 ++;
	}

	for (int i = 2; i < n; i ++)
		ans.emplace_back(mapping[nums[i]]);

	for (auto &x: ans) cout << x << ' ';

	return 0;
}
```