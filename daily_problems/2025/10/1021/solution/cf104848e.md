**提示 1：** 有些换位造成的数差别会很小。

**提示 2：** 可能的最大公约数有哪些？

我们注意到，如果只有最后两位数交换，且这两位差别很小的话，两个数的差别也很小。

而一旦一个数包含了两个不同的数码，我们可以把它们移动到结尾再作差。

而求最大公约数的过程可以使用辗转相除法，类似的也可以一步步做减法，所以最大公约数一定是这两个数的差的约数。

此时这两个数只有最后两位不同，所以最大公约数一定不超过 $100$ 。

因此，对于不小于 $100$ 的输入，只可能有数码完全相同的解。而对于这些解， $S(x)=x$ 。因此，如果输入大于等于 $100$ ，只需判断是否由同个数码构成，如果是，输出原数；否则，输出 $-1$ 。

接下来考虑小于 $100$ 的情况。

首先对于只使用一种数码的数字，我们直接用前面的结果就行。

此时我们可以把任意两个不同的数码挪到数字的最后面，再考虑最后两位不同的两个数 $\dots ab,\dots ba$ ，这两个数的差是 $(10a+b)-(10b+a)=9(a-b)$ 。

所以我们需要构造的是所有 $9(a-b)$ 的二位数约数，其中 $|a-b|\leq 9$ 。

我们发现最多只要构造 $12,15,18,21,24,27,36,45,54,63,72,81$ 的情况。

欸，怎么还是有点多？

那我们先暴力搜一下比较小的数，比方说 $10^5/10^6$ 以内的数。

我们可以找到 $S(48)=12,S(5055)=15,S(288)=18,S(7077)=21,S(8088)=24,S(27)=3699,S(36)=48888,S(63)=111888$ 。

还剩下了 $45,54,72,81$ 。

对于 $45$ ，结尾只能是 $0$ 或 $5$ 。而数字中的任意两个数码 $a,b$ 均需要满足 $45|9(a-b)$ ，也就是 $a-b$ 是 $5$ 的倍数。因此整个数里只能有 $5$ 和 $0$ 。而整体又要是 $9$ 的倍数， $9$ 的倍数数码和也得是 $9$ 的倍数，因此最少要凑 $9$ 个 $5$ 。所以这种情况下的最优解是 $5055555555$ 。

对于 $54$ ，数字中的任意两个数码 $a,b$ 都能移动到末尾，因此均需要满足 $54|9(a-b)$ ，所以 $a-b$ 是 $6$ 的倍数。而 $a,b$ 又不得不是偶数，所以只能选 $2,8/0,6$ 作为备选的数码。接下来再用类似 BFS 的方式暴力搜索两种情况很容易得到 $22288888$ 。

这里说的类似 BFS 的方式是，从 $0$ 作为起点开始，备选的数字是 $d_1,d_2$ ，每个数 $X$ 连向 $10X+d_1,10X+d_2$ ，这样能保证是按照从小到大的顺序遍历各个可能的答案，同时搜出来的第一个满足 $54|X'$ 就是答案，因为相邻数码两个交换的数值该变量一定是 $54$ 的倍数，于是每个数都是 $54$ 的倍数，同时因为 $9(a-b)\leq 54$ ，此时的最大公约数也不可能超过 $54$ ，也就找到了 $X'$ 作为答案。

（如果你没有暴力搜到 $63$ 也能用类似的方式分析到至少得用 $0,7/1,8/2,9$ 来凑答案，也是类似 BFS）

对于 $72$ ，数字中的任意两个数码 $a,b$ 都能移动到末尾，因此均需要满足 $72|9(a-b)$ ，所以 $a-b$ 是 $8$ 的倍数。而 $a,b$ 又都是偶数，所以只能用 $0,8$ 来凑。又是 $9$ 的倍数，所以需要至少 $9$ 个 $8$ ，于是答案是 $8088888888$ 。

对于 $81$ ，数字中的任意两个数码 $a,b$ 都能移动到末尾，因此均需要满足 $81|9(a-b)$ ，所以 $a-b$ 是 $9$ 的倍数，于是用 $0,9$ 来凑答案，直接使用类似 BFS 的方式就可以找到答案 $9099999999$ 。（也可以先除以 $9$ ，就相当于用 $0,1$ 凑 $9$ 的倍数，至少需要 $9$ 个 $1$ ）。

综上讨论完了所有特殊情况。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    d = {
        12: 48,
        15: 5055,
        18: 288,
        21: 7077,
        24: 8088,
        27: 3699,
        36: 48888,
        45: 5055555555,
        54: 222888888,
        63: 111888,
        72: 8088888888,
        81: 9099999999,
    }
    
    for _ in range(t):
        n = II()
        
        if len(set(str(n))) == 1:
            outs.append(n)
        elif n in d:
            outs.append(d[n])
        else:
            outs.append(-1)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int t;
	cin >> t;

	map<long long, long long> mp;
	mp[12] = 48;
	mp[15] = 5055;
	mp[18] = 288;
	mp[21] = 7077;
	mp[24] = 8088;
	mp[27] = 3699;
	mp[36] = 48888;
	mp[45] = 5055555555ll;
	mp[54] = 222888888;
	mp[63] = 111888;
	mp[72] = 8088888888ll;
	mp[81] = 9099999999ll;

	while (t --) {
		long long n;
		cin >> n;

		auto pt = mp.find(n);
		if (pt != mp.end()) cout << pt->second << '\n';
		else {
			set<int> st;
			long long x = n;
			while (x) {
				st.insert(x % 10);
				x /= 10;
			}
			cout << (st.size() == 1 ? n : -1) << '\n';
		}
	}

	return 0;
}
```