**提示 1：** 枚举一个分割点，枚举哪个？

**提示 2：** 其他的怎么办？

总共有三个分割点，为了使得剩余的两个不互相影响，我们枚举中间的那个分割点。

前面部分怎么选呢？我们应该选择最能平分前面一段的位置，这样可以使得最大值尽可能小而最小值尽可能大。后面部分也是类似的。

因此可以二分找到对应位置，也可以选择双指针移动维护最靠后的不过半位置。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, l = MII()
    nums = [0] + LII() + [l]
    
    ans = l
    p1 = p2 = 0
    
    for i in range(2, n - 1):
        while nums[p1 + 1] <= nums[i] - nums[p1 + 1]:
            p1 += 1
        while nums[p2 + 1] - nums[i] <= l - nums[p2 + 1]:
            p2 += 1
        
        for d1 in range(p1, p1 + 2):
            for d2 in range(p2, p2 + 2):
                ma = max(nums[d1], nums[i] - nums[d1], nums[d2] - nums[i], l - nums[d2])
                mi = min(nums[d1], nums[i] - nums[d1], nums[d2] - nums[i], l - nums[d2])
                ans = fmin(ans, ma - mi)
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	long long l;
	cin >> n >> l;

	vector<long long> nums(n + 1);
	nums[0] = 0, nums[n] = l;

	for (int i = 1; i <= n - 1; i ++)
		cin >> nums[i];

	int p1 = 0, p2 = 0;
	long long ans = l;

	for (int i = 2; i <= n - 2; i ++) {
		while (nums[p1 + 1] <= nums[i] - nums[p1 + 1]) p1 ++;
		while (nums[p2 + 1] - nums[i] <= l - nums[p2 + 1]) p2 ++;

		for (int d1 = p1; d1 <= p1 + 1; d1 ++) {
			for (int d2 = p2; d2 <= p2 + 1; d2 ++) {
				long long ma = max({nums[d1], nums[i] - nums[d1], nums[d2] - nums[i], l - nums[d2]});
				long long mi = min({nums[d1], nums[i] - nums[d1], nums[d2] - nums[i], l - nums[d2]});
				ans = min(ans, ma - mi);
			}
		}
	}

	cout << ans;

	return 0;
}
```