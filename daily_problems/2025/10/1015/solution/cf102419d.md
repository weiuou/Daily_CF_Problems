**提示 1：** 一条边两侧的数相同的情况是更难凑的。

**提示 2：** 分别怎么凑？

如果一条边两侧数相同，那只能一个数操作一个数不操作。

所以考虑所有这样的边，则一定没有奇数环，否则这个环上没法找到合法的操作方式，因此一定是二分图。所以用这件事决定哪些数操作就行。

那我们操作的数如何选呢？我们需要使得别的边不会产生新的矛盾，因此只要选的数不等于任何一组边对应的端点的异或即可，这样无论怎么操作都到不了 $0$ 。这件事可以用求 MEX 的类似方法解决。

时间复杂度为 $\mathcal{O}(n+m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    nums = LII()
    vis = [0] * (1 << 20)
    
    path = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = GMI()
        if nums[u] == nums[v]:
            path[u].append(v)
            path[v].append(u)
        else:
            vis[nums[u] ^ nums[v]] = 1
    
    col = [-1] * n
    
    for i in range(n):
        if col[i] == -1:
            col[i] = 0
            
            stk = [i]
            while stk:
                u = stk.pop()
                
                for v in path[u]:
                    if col[v] == -1:
                        col[v] = col[u] ^ 1
                        stk.append(v)
                    elif col[u] == col[v]:
                        exit(print(-1))
    
    chosen = 1
    while vis[chosen]:
        chosen += 1
    
    print(sum(col), chosen)
    print(*(i + 1 for i in range(n) if col[i]))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	vector<int> nums(n), vis(1 << 20);
	for (auto &v: nums) cin >> v;

	vector<vector<int>> path(n);
	while (m --) {
		int u, v;
		cin >> u >> v;
		u --, v --;
		if (nums[u] == nums[v]) {
			path[u].emplace_back(v);
			path[v].emplace_back(u);
		}
		else vis[nums[u] ^ nums[v]] = 1;
	}

	vector<int> col(n, -1);

	auto dfs = [&] (auto &self, int u) -> void {
		for (auto &v: path[u]) {
			if (col[v] == -1) col[v] = col[u] ^ 1, self(self, v);
			else if (col[v] == col[u]) cout << -1, exit(0);
		}
	};

	for (int i = 0; i < n; i ++) {
		if (col[i] == -1) {
			col[i] = 0;
			dfs(dfs, i);
		}
	}

	int total = 0;
	for (int i = 0; i < n; i ++) total += col[i];

	int val = 1;
	while (vis[val]) val ++;

	cout << total << ' ' << val << '\n';
	for (int i = 0; i < n; i ++)
		if (col[i]) cout << i + 1 << ' ';

	return 0;
}
```