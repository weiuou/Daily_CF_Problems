**提示 1：** 不妨枚举 GPS 失效的时刻。

**提示 2：** 此前此后有何要求？

坏了的 GPS 相当于要求我们走了某一条边。此前我们在某一条 $s$ 到 $t$ 的最短路上，此后是按照最短路走到 $t$ 。

如果 $L$ 刚好等于 $s$ 到 $t$ 的最短路长度，那么就相当于歪打正着，直接求最短路径条数就行。转移是根据边来的，所以转移次数是 $\mathcal{O}(m)$ 的。

否则，我们枚举失效的那条边。设边从 $u$ 到 $v$ ，则 $u$ 必须得在 $s$ 到 $t$ 的某条最短路上，于是 $dis(s,u)=dis(s,t)-dis(u,t)$ ，而从 $v$ 到终点的距离是 $dis(v,t)$ ，所以可以计算这种情况下的总路程并跟 $L$ 对比。

此时只需看前半部分和后半部分分别的方案数，再相乘即可。

前半部分是 $s$ 开始的路径个数，转移需要满足转移过程中的每个点都在 $s,t$ 的最短路上。

后半部分是从某个点到 $t$ 的路径个数，直接从 $t$ 的位置开始往外 DP 推答案就行。

需要注意的细节：如果你到了终点，那就没法折返了。

时间复杂度为 $\mathcal{O}(n\log m+m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    s, t, l = MII()
    s -= 1
    t -= 1
    
    path = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v, w = MII()
        u -= 1
        v -= 1
        path[u].append(w * n + v)
        path[v].append(w * n + u)
    
    inf = 10 ** 15
    mod = 10 ** 9 + 7
    
    dis = [inf] * n
    dis[t] = 0
    
    pq = [t]
    nodes = []
    
    while pq:
        d, u = divmod(heappop(pq), n)
        
        if dis[u] == d:
            nodes.append(u)
            
            for msk in path[u]:
                nd, v = divmod(msk, n)
                if dis[v] > nd + d:
                    dis[v] = nd + d
                    heappush(pq, dis[v] * n + v)
    
    from_s_dp = [0] * n
    from_s_dp[s] = 1
    
    nodes.reverse()
    
    for u in nodes:
        for msk in path[u]:
            d, v = divmod(msk, n)
            
            if dis[u] - dis[v] == d:
                from_s_dp[v] += from_s_dp[u]
                from_s_dp[v] %= mod
    
    if dis[s] == l:
        print(from_s_dp[t])
        exit()
    
    from_t_dp = [0] * n
    from_t_dp[t] = 1
    
    nodes.reverse()
    
    for u in nodes:
        for msk in path[u]:
            d, v = divmod(msk, n)
            
            if dis[v] - dis[u] == d:
                from_t_dp[v] += from_t_dp[u]
                from_t_dp[v] %= mod
    
    ans = 0
    
    for u in range(n):
        if from_s_dp[u]:
            for msk in path[u]:
                d, v = divmod(msk, n)
                
                if dis[s] - dis[u] + d + dis[v] == l and u != t:
                    ans += from_s_dp[u] * from_t_dp[v] % mod
                    ans %= mod
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m, s, t;
    long long l;

    cin >> n >> m >> s >> t >> l;
    s --, t --;

    vector<vector<pair<int, int>>> path(n);

    while (m --) {
        int u, v, w;
        cin >> u >> v >> w;

        u --, v --;
        path[u].emplace_back(v, w);
        path[v].emplace_back(u, w);
    }

    long long inf = 1e15;
    int mod = 1e9 + 7;

    vector<long long> dis(n, inf);
    dis[t] = 0;

    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;
    pq.push({0, t});
    vector<int> nodes;

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        if (dis[u] == d) {
            nodes.emplace_back(u);
            for (auto &[v, w]: path[u]) {
                if (dis[v] > dis[u] + w) {
                    dis[v] = dis[u] + w;
                    pq.push({dis[v], v});
                }
            }
        }
    }

    vector<int> from_s_dp(n, 0), from_t_dp(n, 0);

    auto add = [&] (int &x, int y) -> void {
        x += y;
        if (x >= mod) x -= mod;
    };

    from_s_dp[s] = 1, from_t_dp[t] = 1;

    reverse(nodes.begin(), nodes.end());

    for (auto &u: nodes) {
        for (auto &[v, w]: path[u]) {
            if (dis[u] - dis[v] == w) {
                add(from_s_dp[v], from_s_dp[u]);
            }
        }
    }

    if (dis[s] == l) return cout << from_s_dp[t], 0;

    reverse(nodes.begin(), nodes.end());

    for (auto &u: nodes) {
        for (auto &[v, w]: path[u]) {
            if (dis[v] - dis[u] == w) {
                add(from_t_dp[v], from_t_dp[u]);
            }
        }
    }

    int ans = 0;

    for (int u = 0; u < n; u ++) {
        if (from_s_dp[u]) {
            for (auto &[v, w]: path[u]) {
                if (dis[s] - dis[u] + w + dis[v] == l && u != t) {
                    add(ans, 1ll * from_s_dp[u] * from_t_dp[v] % mod);
                }
            }
        }
    }

    cout << ans;

    return 0;
}
```