**提示 1：** 你取的 $x$ 只需要考虑那些质数。

**提示 2：** 需要检查的有哪些？

首先，如果一个 $x$ 可以达成目标，那么对其质因子也一定是可以的。所以只需考虑质数就行。

为此，我们先统计每个质数能被多少个数组中的数整除。

我们只需挑选其中出现次数过半的进行检查，接下来相当于将树上的点根据是否被该质数整除分为两类，不能整除的染为黑色，能整除的染为白色，问是否存在一条长度超过 $n/2$ 的路径，这件事可以直接使用 DP 完成检查，维护每个点往下的最长的白色路径长度。而每个白色结点又可以挑选两条向下的路径拼到一起，再看看能否凑出长度超过 $n/2$ 的路径即可。

这样做时间复杂度如何呢？时间复杂度为 $\mathcal{O}(n\log M + M)$ ，因为每个数的质因子的总次数之和不超过 $\mathcal{O}(n\log M)$ ，因此频率至少为 $n/2$ 的至多只有 $\mathcal{O}(\log M)$ 个，所以只需跑 $\mathcal{O}(\log M)$ 轮 DP 就行。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    M = 10 ** 7
    prime_factor = list(range(M + 1))
    
    for i in range(2, M + 1):
        if prime_factor[i] == i:
            for j in range(i, M + 1, i):
                prime_factor[j] = i
    
    n = II()
    nums = LII()
    
    path = [[] for _ in range(n)]
    
    for _ in range(n - 1):
        u, v = GMI()
        path[u].append(v)
        path[v].append(u)
    
    cnt = [0] * (M + 1)
    
    for x in nums:
        while x > 1:
            p = prime_factor[x]
            cnt[p] += 1
            while x % p == 0:
                x //= p
    
    parent = [-1] * n
    que = [0]
    
    for u in que:
        for v in path[u]:
            if parent[u] != v:
                parent[v] = u
                que.append(v)
    
    que.reverse()
    dp = [0] * n
    
    for i in range(M + 1):
        if cnt[i] * 2 > n:
            total = 0
    
            for u in que:
                if nums[u] % i == 0: dp[u] = 1
                else: dp[u] = 0
                
                if dp[u]:
                    v1, v2 = 0, 0
                    for v in path[u]:
                        if parent[v] == u:
                            if dp[v] > v1: v1, v2 = dp[v], v1
                            elif dp[v] > v2: v2 = dp[v]
                    
                    dp[u] = v1 + 1
                    total = fmax(total, v1 + v2 + 1)
            
            if total * 2 > n:
                exit(print('YES'))
    
    print('NO')
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int M = 1e7;
    vector<int> prime_factor(M + 1);
    iota(prime_factor.begin(), prime_factor.end(), 0);

    for (int i = 2; i <= M; i ++) {
        if (prime_factor[i] == i) {
            for (int j = i; j <= M; j += i) {
                prime_factor[j] = i;
            }
        }
    }

    int n;
    cin >> n;

    vector<int> nums(n);
    for (auto &x: nums) cin >> x;

    vector<vector<int>> path(n);
    for (int i = 0; i < n - 1; i ++) {
        int u, v;
        cin >> u >> v;
        u --, v --;
        path[u].emplace_back(v);
        path[v].emplace_back(u);
    }

    vector<int> cnt(M + 1, 0);

    for (auto &x: nums) {
        int vx = x;
        while (vx > 1) {
            int p = prime_factor[vx];
            cnt[p] ++;
            while (vx % p == 0) vx /= p;
        }
    }

    int to_check, max_len;
    vector<int> dp(n);

    auto dfs = [&] (auto &self, int u, int p) -> void {
        int v1 = 0, v2 = 0;

        for (auto &v: path[u]) {
            if (v != p) {
                self(self, v, u);
                if (dp[v] > v1) swap(v1, v2), v1 = dp[v];
                else if (dp[v] > v2) v2 = dp[v];
            }
        }

        if (nums[u] % to_check == 0) {
            max_len = max(max_len, v1 + v2 + 1);
            dp[u] = v1 + 1;
        }
    };

    for (int i = 0; i <= M; i ++) {
        if (cnt[i] * 2 > n) {
            to_check = i, max_len = 0;
            dfs(dfs, 0, -1);
            if (max_len * 2 > n) return cout << "YES", 0;
        }
    }

    cout << "NO";

    return 0;
}
```