**提示 1：** 给一个很显然的 $a,b$ 需要满足的条件。

**提示 1：** 先只满足或条件，需要怎么调整？

**提示 2：** 好调整吗？

首先所有数的二进制位都只能是 $a$ 的子集，因此 $b$ 如果在别的位有数，则直接返回无法构造。否则，讨论如下。

首先，或条件相对来说好控制很多，我们取所有二进制位是 $a$ 的子集的数字。

这样算出来的异或和结果和 $b$ 计算差别。差别一定也是 $a$ 的子集。

如果差别是 $0$ ，则啥都不用调整，返回就好了。

否则我们删去差别对应的那个数，一定也是在原先选出的数中出现过（因为所有 $a$ 的子集都被选出来了）。此时再检查或和是否满足条件即可（因为异或和已经满足条件了）。

这样为何是优的呢？因为这样会使得或和的条件尽可能仍然被满足。因为每个位都是尽可能更少地减少出现次数，如果这样都让或和不满足条件，只能删去更多的位，也就更不满足要求了。

时间复杂度为 $\mathcal{O}(M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    for _ in range(t):
        a, b = MII()
        
        if a | b != a: outs.append('-1')
        else:
            vals = [i for i in range(a + 1) if i & a == i]
            xor_val = reduce(xor, vals) ^ b
            
            if xor_val: vals.remove(xor_val)
            
            if reduce(ior, vals) == a:
                outs.append(str(len(vals)))
                outs.append(' '.join(map(str, vals)))
            else:
                outs.append('-1')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int a, b;
        cin >> a >> b;

        if ((a | b) != a) cout << -1 << '\n';
        else if ((a & -a) == a && b == 0 && a) cout << -1 << '\n';
        else {
            vector<int> ans;
            int xor_val = b;

            for (int i = 0; i <= a; i ++) {
                if ((i & a) == i) {
                    ans.emplace_back(i);
                    xor_val ^= i;
                }
            }

            int ans_len = ans.size();
            if (!xor_val) xor_val = -1;
            else ans_len --;

            cout << ans_len << '\n';
            for (auto &x: ans) if (x != xor_val) cout << x << ' '; cout << '\n';
        }
    }

    return 0;
}
```