**提示 1：** 想想一些特殊的边。

**提示 2：** 如何把一个点和 $2$ 连到一起？

看提示 2 吧。如果这个数本身是 $2$ 的倍数，那么直接跟 $2$ 相连。

这个数一定和它最小的质因子 $p$ 相连，而如果 $2p$ 不超过 $N$ ，则 $p-2p-2$ 也就跟 $2$ 连通了。

所以一个数只要有一个质因子 $p$ 使得 $2p$ 不超过 $N$ ，则与 $2$ 连通。

所以与 $2$ 不连通只能是超过 $N/2$ 的质因子个数。所以本题相当于求 $N/2\sim N$ 之间的质数个数，直接用质数筛与前缀和即可。

注意在 $N$ 比较小的情况下会是特殊的情况，可以手动分类讨论处理。

时间复杂度为 $\mathcal{O}(M)$ 的预处理和 $\mathcal{O}(1)$ 的查询。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    M = 10 ** 7
    is_prime = [1] * (M + 1)
    is_prime[0] = 0
    is_prime[1] = 0
    
    for i in range(2, M + 1):
        if is_prime[i]:
            for j in range(i * 2, M + 1, i):
                is_prime[j] = 0
    
    for i in range(1, M + 1):
        is_prime[i] += is_prime[i - 1]
    
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        if n <= 3: outs.append(n - 2)
        else: outs.append(is_prime[n] - is_prime[n // 2])
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int M = 1e7;

    vector<int> is_prime(M + 1, 1);
    is_prime[0] = 0, is_prime[1] = 0;

    for (int i = 2; i <= M; i ++) {
        if (is_prime[i]) {
            for (int j = i * 2; j <= M; j += i) {
                is_prime[j] = 0;
            }
        }
    }

    for (int i = 1; i <= M; i ++) {
        is_prime[i] += is_prime[i - 1];
    }

    int t;
    cin >> t;

    while (t --) {
        int n;
        cin >> n;

        if (n <= 3) cout << n - 2 << '\n';
        else cout << is_prime[n] - is_prime[n / 2] << '\n';
    }

    return 0;
}
```