**提示 1：** 找到一种确认上界的方法。

**提示 2：** 根据上述上界构造。

我们考虑一条路径，长度为 $L$ 。考虑其顺着走和逆着走的权值和，原先是 $2L$，而最多经过 $L+1$ 次操作（这点容易漏 $1$），最少为 $L+L-(L+1)=L-1$ ，所以答案不可能小于 $\lceil\frac{L-1}{2}\rceil$ ，即这两种走法的最大值。

而最长的路径是直径。考虑直径。

我们直径上一半安排一个方向。考虑直径中点，让所有边全部指向直径中点。

这个构造合法吗？答案是肯定的，任意两个点之间路径的权值等于其相对中点的深度差。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    n = II()
    
    us = []
    vs = []
    path = [[] for _ in range(n)]
    
    for i in range(n - 1):
        u, v = GMI()
        us.append(u)
        vs.append(v)
        path[u].append(i)
        path[v].append(i)
    
    parent = [-1] * n
    que = [0]
    
    for u in que:
        for eid in path[u]:
            v = us[eid] + vs[eid] - u
            if parent[u] != v:
                parent[v] = u
                que.append(v)
    
    dp1 = [0] * n
    
    for i in reversed(que):
        if i: dp1[parent[i]] = fmax(dp1[parent[i]], dp1[i] + 1)
    
    dp2 = [0] * n
    
    for u in que:
        v1, v2 = dp2[u], 0
        
        for eid in path[u]:
            v = us[eid] + vs[eid] - u
            if parent[v] == u:
                val = dp1[v] + 1
                if val > v1: v1, v2 = val, v1
                elif val > v2: v2 = val
        
        for eid in path[u]:
            v = us[eid] + vs[eid] - u
            if parent[v] == u:
                val = dp1[v] + 1
                if val == v1: dp2[v] = v2 + 1
                else: dp2[v] = v1 + 1
    
    ans = n
    x, y = -1, -1
    
    for i in range(1, n):
        v = fmax(dp1[i], dp2[i] - 1)
        if v < ans:
            ans = v
            x = i
            y = parent[i]
    
    print(ans)
    
    for i in range(n):
        parent[i] = -1
    
    parent[x] = y
    parent[y] = x
    
    que = [x, y]
    
    for u in que:
        for eid in path[u]:
            v = us[eid] + vs[eid] - u
            if parent[v] == -1:
                parent[v] = u
                que.append(v)
    
    ans = [0] * n
    
    for u in range(n):
        for eid in path[u]:
            v = us[eid] + vs[eid] - u
            if parent[u] == v:
                ans[u] = eid + 1
    
    print(*ans)
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	vector<vector<pair<int, int>>> path(n);
	vector<int> parent(n);

	for (int i = 1; i <= n - 1; i ++) {
		int u, v;
		cin >> u >> v;
		u --, v --;
		path[u].emplace_back(i, v);
		path[v].emplace_back(i, u);
	}

	vector<int> dp_down(n, 0), dp_up(n, 0);

	auto dfs1 = [&] (auto &self, int u, int p) -> void {
		parent[u] = p;
		for (auto &[i, v]: path[u]) {
			if (v != p) {
				self(self, v, u);
				dp_down[u] = max(dp_down[u], dp_down[v] + 1);
			}
		}
	};

	auto dfs2 = [&] (auto &self, int u, int p) -> void {
		int v1 = dp_up[u], v2 = 0;
		for (auto &[i, v]: path[u]) {
			if (v != p) {
				int val = dp_down[v] + 1;
				if (val > v1) swap(v1, v2), v1 = val;
				else if (val > v2) v2 = val;
			}
		}

		for (auto &[i, v]: path[u]) {
			if (v != p) {
				int val = dp_down[v] + 1;
				if (val == v1) dp_up[v] = v2 + 1;
				else dp_up[v] = v1 + 1;
				self(self, v, u);
			}
		}
	};

	dfs1(dfs1, 0, -1);
	dfs2(dfs2, 0, -1);

	int ans = n, chosen = -1;

	for (int i = 1; i < n; i ++) {
		int res = max(dp_down[i], dp_up[i] - 1);
		if (res < ans) ans = res, chosen = i;
	}

	vector<int> chosen_edge(n);

	auto dfs = [&] (auto &self, int u, int p) -> void {
		for (auto &[i, v]: path[u]) {
			if (v != p) {
				chosen_edge[v] = i;
				self(self, v, u);
			}
		}
	};

	for (auto &[i, v]: path[chosen]) {
		if (v == parent[chosen]) {
			chosen_edge[v] = i;
			chosen_edge[chosen] = i;
			dfs(dfs, v, chosen);
			dfs(dfs, chosen, v);
		}
	}

	cout << ans << '\n';
	for (auto &x: chosen_edge) cout << x << ' ';
 
	return 0;
}
```