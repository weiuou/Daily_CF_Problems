**提示 1：** 第 $i$ 行第 $j$ 个元素是什么？

**提示 2：** 注意值域并不大。

首先，根据杨辉三角，第 $i$ 行第 $j$ 个元素是 $C_{i-1}^{j-1}$ 。

如果枚举 $j$ ，可以发现最多有 $\mathcal{O}(M^{1/{j-1}})$ 个数可以使得这个组合数不超过 $M$ 。

所以对于 $j\geq 3$ ，我们只需枚举 $\mathcal{O}(M^{1/2})$ 个数就行，因此考虑这些数为底的不超过 $M$ 的组合数，数量也不超过 $\mathcal{O}(M^{1/2}+M^{1/3}+\dots)=\mathcal{O}(M^{1/2})$ 量级。将上述结果存下来，查询时候用。

如果不在上述存储结果中，直接输出 $x+1$ 即可，因为只可能是 $C_x^1$ 了。

时间复杂度为 $\mathcal{O}(M^{1/2})$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    d = {}
    bound = 10 ** 9
    
    for i in range(10 ** 5, -1, -1):
        cur = 1
        for j in range(i + 1):
            if cur > bound: break
            d[cur] = i + 1
            cur = cur * (i - j) // (j + 1)
    
    t = II()
    outs = []
    
    for _ in range(t):
        x = II()
        if x in d: outs.append(d[x])
        else: outs.append(x + 1)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	map<int, int> mp;
	int bound = 1e9;

	for (int i = 100000; i >= 0; i --) {
		long long val = 1;
		for (int j = 0; j <= i; j ++) {
			if (val > bound) break;
			mp[val] = i + 1;
			val = val * (i - j) / (j + 1);
		}
	}

	int t;
	cin >> t;

	while (t --) {
		int x;
		cin >> x;
		auto pt = mp.find(x);

		if (pt != mp.end()) cout << pt->second << '\n';
		else cout << x + 1 << '\n';
	}

	return 0;
}
```