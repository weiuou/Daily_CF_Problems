**提示 1：** 先排除一些没办法选到的数。

**提示 2：** 剩余的可以任选吗？

首先，假设前面和后面分别空出来了 $x,y$ 个位置，则最后的 $\min(x,y)$ 个数无论如何进不了区间，所以直接排除。

对于剩余的元素，取其中前 $r-l+1$ 大的，结果显然是一个上界，下面只需说明这件事可以取到。

我们可以把前面的元素形成以下的形式：前面是所选元素，后面是其他元素；或者前面是其他元素，后面是所选元素。在这种情况下，剩余的 $\min(x,y)$ 个元素总能让所选元素移动到 $[l,r]$ 的位置。

时间复杂度为 $\mathcal{O}(n\log n)$ ，当然用求第 $k$ 大的方法可以进一步优化。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, l, r = MII()
    nums = LII()
    
    v = fmin(l - 1, n - r)
    nums = nums[:n - v]
    print(sum(nlargest(r - l + 1, nums)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, l, r;
    cin >> n >> l >> r;

    vector<int> nums(n);
    for (auto &v: nums) cin >> v;

    int x = min(n - r, l - 1);
    while (x --)
        nums.pop_back();
    
    sort(nums.rbegin(), nums.rend());

    long long ans = 0;
    for (int i = 0; i <= r - l; i ++)
        ans += nums[i];
    
    cout << ans;

    return 0;
}
```