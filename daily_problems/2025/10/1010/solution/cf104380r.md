**提示 1：** 只需求每个元素的贡献。检查贡献有没有算错可以使用 Q 题。

**提示 2：** 加速贡献计算：同底数的组合数没法直接优化计算，只能找相关关系。

考虑第 $i$ 个元素出现在 $[L,R]$ 的方案数，这就是第 $i$ 个元素对于结果的贡献。

如果第 $i$ 个元素是从左侧加入的，那么前 $i-1$ 个元素有 $2^{i-1}$ 种方案（怎么加入对于第 $i$ 个元素毫无影响）。而剩余的 $n-i$ 个元素而言，需要有 $[L-1,R-1]$ 个元素从左侧加入，因此，权重是 $2^{i-1}\sum\limits_{k=L-1}^{R-1}C_{n-i}^k$ 。

如果第 $i$ 个元素是从右侧加入的，那么前 $i-1$ 个元素仍然有 $2^{i-1}$ 种方案。剩余的 $n-i$ 个元素需要有 $[L-i,R-i]$ 个元素从左侧加入，因此权重是 $2^{i-1}\sum\limits_{k=L-i}^{R-i}C_{n-i}^k$ 。

两者相加即为总权重。

这足够完成 Easy Version 。但这些权重的计算如果一个个算就太慢了，怎么优化呢？

这里是一个比较经典的技巧，下面底数一样的情况下，相邻的底数的结果有数量关系。

以 $\sum\limits_{k=L-1}^{R-1}C_{n-i}^k$ 为例：

$2\sum\limits_{k=L-1}^{R-1}C_{n-i}^k=\sum\limits_{k=L-1}^{R-1}(C_{n-i}^k+C_{n-i}^{k-1})-C_{n-i}^{L-2}+C_{n-i}^{R-1}=\sum\limits_{k=L-1}^{R-1}C_{n-(i-1)}^k-C_{n-i}^{L-2}+C_{n-i}^{R-1}$

也就发现了相邻的两个权重之间存在很方便的转移关系，因此利用这种转移关系计算权重即可。

主要使用的组合恒等式是 $C_x^y=C_{x-1}^y+C_{x-1}^{y-1}$ ，所以考虑将组合求和式用这种形式进行组合，并进而化简。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    mod = 10 ** 9 + 7
    
    n, l, r = MII()
    nums = LII()
    
    f = Factorial(n, mod)
    
    pw2 = 1
    rev2 = (mod + 1) // 2
    
    ans = 0
    weight_left = 0
    
    for i in range(l - 1, r):
        weight_left += f.combi(n - 1, i)
        weight_left %= mod
    
    weight_right = weight_left
    
    ans += (weight_left + weight_right) * nums[0] % mod
    
    for i in range(1, n):
        pw2 = pw2 * 2 % mod
        
        weight_left = (weight_left + f.combi(n - i - 1, l - i - 1) - f.combi(n - i - 1, r - i)) % mod * rev2 % mod
        weight_right = (weight_right - f.combi(n - i - 1, l - 2) + f.combi(n - i - 1, r - 1)) % mod * rev2 % mod
        
        ans += (weight_left + weight_right) * nums[i] % mod * pw2 % mod
    
    print(ans % mod)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, l, r;
    cin >> n >> l >> r;

    vector<int> nums(n);
    for (auto &v: nums) cin >> v;

    int mod = 1e9 + 7;

    vector<int> f(n + 1, 1), g(n + 1);

    for (int i = 1; i <= n; i ++)
        f[i] = 1ll * i * f[i - 1] % mod;
    
    g[n] = quickPow(f[n], mod - 2, mod);

    for (int i = n; i >= 1; i --)
        g[i - 1] = 1ll * i * g[i] % mod;
    
    auto comb = [&] (int x, int y) -> int {
        if (x < y || x < 0 || y < 0) return 0;
        return 1ll * f[x] * g[y] % mod * g[x - y] % mod;
    };

    int ans = 0;
    int pw2 = 1, rev2 = (mod + 1) / 2;
    int weight_left = 0, weight_right;

    for (int i = l - 1; i <= r - 1; i ++)
        weight_left += comb(n - 1, i), weight_left %= mod;
    
    weight_right = weight_left;
    ans += 1ll * (weight_left + weight_right) * nums[0] % mod;

    for (int i = 1; i < n; i ++) {
        pw2 = pw2 * 2 % mod;

        weight_left = (0ll + weight_left + comb(n - i - 1, l - i - 1) - comb(n - i - 1, r - i)) * rev2 % mod;
        weight_right = (0ll + weight_right - comb(n - i - 1, l - 2) + comb(n - i - 1, r - 1)) * rev2 % mod;

        ans += 1ll * (weight_left + weight_right) * nums[i] % mod * pw2 % mod;
        ans %= mod;
    }

    cout << (ans + mod) % mod;

    return 0;
}
```