**提示 1：** 只有两个字母怎么办？

**提示 2：** 其实是一段段的处理。

可以自己随机几组数据试试。

首先，如果是两个字母，则满足严格的大小可比。此时相当于一个 $01$ 数组冒泡 $j$ 轮。则每个 $0$ 最多往前的距离就是 $j$ ，其位置不能小于前一个 $0$ 的位置，根据这件事就可以快速得到结果了。

而事实上，我们可以从前往后把序列分成若干段只有不超过两种字母的段落，且保证下一段的第一个字母不会出现在本段。保证除了最后一段，字母的种类数都是 $2$ 。

可以证明，段落之间不会相互影响。

假设第一段包含了 PS，则第二段开头就是 R。

在第一轮冒泡排序走到第一段的末尾后，最后一项一定是 S，因为最后一个 S 一定会不断往后移到段落尾部。此后，如果不和第二段交换将一直保持是 S。

而第二段开头只可能是 R 或者 S，因为开头是 R，不可能跟后面的 P 交换位置。无论是哪个，都不可能跟前面的 S 交换位置。所以证明出来了段落间不会交换。

所以直接按照两种元素的逻辑模拟每一段就行。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k = MII()
    d = {
        'R': 0,
        'P': 1,
        'S': 2
    }
    
    s = [d[c] for c in I()]
    
    l = 0
    msk = 0
    
    def solve(l, r):
        tmp = [[] for _ in range(3)]
        for i in range(l, r):
            tmp[s[i]].append(i)
        
        if len(tmp[0]) == 0:
            for i in range(l, r):
                s[i] = 2
            
            cur = l - 1
            for i in tmp[1]:
                cur = fmax(cur + 1, i - k)
                s[cur] = 1
        
        elif len(tmp[1]) == 0:
            for i in range(l, r):
                s[i] = 0
            
            cur = l - 1
            for i in tmp[2]:
                cur = fmax(cur + 1, i - k)
                s[cur] = 2
        
        else:
            for i in range(l, r):
                s[i] = 1
            
            cur = l - 1
            for i in tmp[0]:
                cur = fmax(cur + 1, i - k)
                s[cur] = 0
    
    for i in range(n):
        msk |= (1 << s[i])
        if msk == 7:
            solve(l, i)
            l = i
            msk = 1 << s[i]
    
    solve(l, n)
    
    print(''.join('RPS'[i] for i in s))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

	int n, t;
	cin >> n >> t;

	string s;
	cin >> s;

	set<char> st;
	int l = 0;

	auto solve = [&] (int l, int r) -> void {
		map<char, vector<int>> mp;

		for (int i = l; i < r; i ++)
			mp[s[i]].emplace_back(i);
		
		if (mp.find('P') == mp.end()) {
			for (int i = l; i < r; i ++) s[i] = 'R';
			int cur = l - 1;
			for (auto &p: mp['S']) {
				cur = max(cur + 1, p - t);
				s[cur] = 'S';
			}
		}

		else if (mp.find('R') == mp.end()) {
			for (int i = l; i < r; i ++) s[i] = 'S';
			int cur = l - 1;
			for (auto &p: mp['P']) {
				cur = max(cur + 1, p - t);
				s[cur] = 'P';
			}
		}

		else {
			for (int i = l; i < r; i ++) s[i] = 'P';
			int cur = l - 1;
			for (auto &p: mp['R']) {
				cur = max(cur + 1, p - t);
				s[cur] = 'R';
			}
		}
	};

	for (int i = 0; i < n; i ++) {
		st.insert(s[i]);
		if (st.size() == 3) {
			solve(l, i);
			l = i;
			st = {s[i]};
		}
	}

	solve(l, n);

	cout << s;

    return 0;
}
```