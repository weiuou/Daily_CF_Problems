**提示 1：** 横着和竖着的配置是 $1+2$ 或者 $0+3$ ，枚举少的的那边。

**提示 2：** 怎么快速找到另一侧的最优选择。

先看提示。如果是 $0+3$ 的配置，显然取某个方向的三条值最大的直线就好了。

否则就只可能是 $1+2$ 的配置了。

下面讨论删除某一行的情况。

此时各个列的权值相当于原本的权值减去该列在这一行的权值之和。

我们相当于要求这个权值的前二大数值。

一种方式是用一个有序结构（如有序集合）维护。只需将该行的点对应列进行更新，找到前二大数值再恢复回来就行。

另一种方式是，我们假设删除了 $k$ 个点，则我们只需考虑 “删除前” 最大的 $k+2$ 个列。因为如果选择的列至多只比一个没删的列小，否则不如选择没被删的最大两列，因此至少排序为前 $k+2$ 。

因此枚举这 $k+2$ 列，取最大的两列就行。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    xs = []
    ys = []
    vs = []
    
    for _ in range(n):
        x, y, v = MII()
        xs.append(x)
        ys.append(y)
        vs.append(v)
    
    def solve():
        cnt = [0] * (10 ** 6 + 1)
        for i in range(n):
            cnt[ys[i]] += vs[i]
    
        higher_ys_order = sorted((i for i in range(10 ** 6 + 1) if cnt[i]), key=lambda x: -cnt[x]) + [i for i in range(10 ** 6 + 1) if cnt[i] == 0]
        
        res = 0
        for i in range(3):
            res += cnt[higher_ys_order[i]]
        
        tmp = [[] for _ in range(10 ** 6 + 1)]
        for i in range(n):
            tmp[xs[i]].append(i)
        
        for x in range(10 ** 6 + 1):
            cur = 0
            for idx in tmp[x]:
                cur += vs[idx]
                cnt[ys[idx]] -= vs[idx]
            
            v1, v2 = 0, 0
            for idx in range(len(tmp[x]) + 2):
                val = cnt[higher_ys_order[idx]]
                if val > v1: v1, v2 = val, v1
                elif val > v2: v2 = val
            
            res = fmax(res, cur + v1 + v2)
            
            for idx in tmp[x]:
                cnt[ys[idx]] += vs[idx]
        
        return res
    
    ans = solve()
    
    for i in range(n):
        xs[i], ys[i] = ys[i], xs[i]
    
    ans = fmax(ans, solve())
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

	int n, M = 1e6;
	cin >> n;

	vector<int> xs(n), ys(n), vs(n);
	for (int i = 0; i < n; i ++)
		cin >> xs[i] >> ys[i] >> vs[i];

	auto solve = [&] () -> int {
		vector<int> cnt(M + 1, 0);

		for (int i = 0; i < n; i ++)
			cnt[ys[i]] += vs[i];
		
		vector<int> order(M + 1);
		iota(order.begin(), order.end(), 0);
		sort(order.begin(), order.end(), [&] (int i, int j) {return cnt[i] > cnt[j];});

		int ans = cnt[order[0]] + cnt[order[1]] + cnt[order[2]];

		map<int, vector<int>> mp;
		for (int i = 0; i < n; i ++)
			mp[xs[i]].emplace_back(i);
		
		for (auto &[k, v]: mp) {
			int cur = 0;
			for (auto &idx: v) {
				cur += vs[idx];
				cnt[ys[idx]] -= vs[idx];
			}

			int v1 = 0, v2 = 0;
			for (int i = 0; i < v.size() + 2; i ++) {
				int val = cnt[order[i]];
				if (val > v1) swap(v1, v2), v1 = val;
				else if (val > v2) v2 = val;
			}

			ans = max(ans, cur + v1 + v2);

			for (auto &idx: v)
				cnt[ys[idx]] += vs[idx];
		}
		
		return ans;
	};

	int res = solve();

	for (int i = 0; i < n; i ++)
		swap(xs[i], ys[i]);
	
	res = max(res, solve());
	cout << res;

    return 0;
}
```