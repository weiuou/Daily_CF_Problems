**提示 1：** 把题目条件转化好。

**提示 2：** 枚举什么？

直接用 $pb$ 表示 $a$ ，那么 $b+1|pb+1,b+2|pb+2$ 。

而 $pb+1=(p-1)b+(b+1), pb+2=(p-1)b+(b+2)$ 。

所以 $(p-1)b$ 是 $b+1$ 和 $b+2$ 的倍数。

而 $(p-1)b\bmod (b+1)=-(p-1), (p-1)b\bmod(b+2)=-2(p-1)$ 。

所以要求 $p-1$ 是 $b+1$ 的倍数，且 $2(p-1)$ 是 $b+2$ 的倍数。

因此 $2(p-1)$ 是 $b+1,b+2$ 的倍数，而 $b+1,b+2$ 是互质的，所以也就是 $(b+1)(b+2)$ 的倍数。不妨设 $2(p-1)=k(b+1)(b+2)$ 。

因为 $p$ 的范围是 $10^{18}$ ，所以 $k,b+1,b+2$ 中至少有一个元素是不超过 $(2\times 10^{18})^{1/3}$ ，所以枚举这个元素，剩余元素也都求出来了，再确认前面的条件是否满足即可（就是 $p-1$ 是 $b+1$ 的倍数，且 $2(p-1)$ 是 $b+2$ 的倍数）。

时间复杂度为 $\mathcal{O}(M^{1/3})$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    for _ in range(t):
        p = II()
        possible_bs = set()
        
        for b in range(1, 10 ** 6 + 1):
            if (p - 1) % (b + 1) == 0 and 2 * (p - 1) % (b + 2) == 0:
                possible_bs.add(b)
        
        for k in range(1, 2 * 10 ** 6 +  1):
            if 2 * (p - 1) % k == 0:
                v = 2 * (p - 1) // k
                b = (math.isqrt(4 * v + 1) - 1) // 2 - 1
                if b > 0 and (p - 1) % (b + 1) == 0 and 2 * (p - 1) % (b + 2) == 0:
                    possible_bs.add(b)
        
        possible_bs = sorted(possible_bs)
        outs.append(str(len(possible_bs)))
        outs.append(' '.join(map(str, possible_bs)))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        long long p;
        cin >> p;

        vector<int> ans;
        
        for (int b = 1; b <= 1'000'000; b ++) {
            if ((p - 1) % (b + 1) == 0 && 2 * (p - 1) % (b + 2) == 0) {
                ans.emplace_back(b);
            }
        }
        
        for (int k = 1; k <= 2'000'000; k ++) {
            if (2 * (p - 1) % k == 0) {
                long long v = 2 * (p - 1) / k;
                long long b = sqrtl(4 * v + 1);

                while (b * b < 4 * v + 1) b ++;
                while (b * b > 4 * v + 1) b --;

                b = (b - 1) / 2 - 1;
                if (b > 0 && (p - 1) % (b + 1) == 0 && 2 * (p - 1) % (b + 2) == 0) {
                    ans.emplace_back(b);
                }
            }
        }

        sort(ans.begin(), ans.end());
        int k = unique(ans.begin(), ans.end()) - ans.begin();
        cout << k << '\n';
        for (int i = 0; i < k; i ++) cout << ans[i] << ' '; cout << '\n';
    }

    return 0;
}
```