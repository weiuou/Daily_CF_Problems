**提示 1：** 首先什么情况下可以构造呢？

**提示 2：** 可以构造的情况下，给后面的数对留空间。

首先，所有数的和是 $N(2N+1)$ ，其奇偶性与 $N$ 相同。同时，其拆分的有 ${cnt}_O$ 个奇数对，所以也与 ${cnt}_O$ 奇偶性相同。

因此，至少需要 ${cnt}_O,N$ 奇偶性相同。

事实上，在这个条件下总能构造。

为了给后面的数对留出空间，我们每次选择最小的满足条件的数对即可。

实现过程可以维护还没有被取到过的最小奇数和最小偶数。

如果新的数对和为奇数，则各取一个就行。否则，取最小奇数和最小偶数之间更小的一个 $x$ 以及 $x+2$ 。

这样取可以保证取的奇数个数和取的偶数个数不超过 $2$ 。比较容易验证上述构造合法。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    for _ in range(t):
        n = II()
        s = I()
        if s.count('E') % 2: outs.append('NO')
        else:
            outs.append('YES')
            pt1 = 1
            pt2 = 2
            
            for i in range(n):
                if s[i] == 'O':
                    outs.append(f'{pt1} {pt2}')
                    pt1 += 2
                    pt2 += 2
                elif pt1 < pt2:
                    outs.append(f'{pt1} {pt1 + 2}')
                    pt1 += 4
                else:
                    outs.append(f'{pt2} {pt2 + 2}')
                    pt2 += 4
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int n;
        string s;
        cin >> n >> s;

        int ce = 0;
        for (auto &c: s) {
            if (c == 'E') {
                ce ^= 1;
            }
        }

        if (ce) cout << "NO\n";
        else {
            cout << "YES\n";
            int pt1 = 1, pt2 = 2;
            for (auto &c: s) {
                if (c == 'O') {
                    cout << pt1 << ' ' << pt2 << '\n';
                    pt1 += 2;
                    pt2 += 2;
                }
                else {
                    if (pt1 < pt2) cout << pt1 << ' ' << pt1 + 2 << '\n', pt1 += 4;
                    else cout << pt2 << ' ' << pt2 + 2 << '\n', pt2 += 4;
                }
            }
        }
    }

    return 0;
}
```