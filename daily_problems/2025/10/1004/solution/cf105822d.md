**提示 1：** 先给出构造，再看看是否合法。

假设我们有一组构造，则我们可以在这个构造的基础上，加入 $(1,x_1),(x_1,x_2),\dots,(x_{k-1},x_k)$ 这些边，其结果仍然合法。

于是我们去掉原构造的所有边，距离不会变短，构造仍然合法。

所以我们只需检查 $(1,x_1),(x_1,x_2),\dots,(x_{k-1},x_k)$ 是否是合法的构造就行。注意 $x_1$ 可能为 $1$ ，这种情况下少加一条边即可。

时间复杂度为 $\mathcal{O}(n+m+k)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    for _ in range(t):
        n, m, k = MII()
        visits = LGMI()
        
        path = [[] for _ in range(n)]
        
        for _ in range(m):
            u, v = GMI()
            path[u].append(v)
            path[v].append(u)
        
        cur = 0
        for x in visits:
            if x != cur:
                path[x].append(cur)
                path[cur].append(x)
                cur = x
        
        dis = [-1] * n
        dis[0] = 0
        
        que = [0]
        
        for u in que:
            for v in path[u]:
                if dis[v] == -1:
                    dis[v] = dis[u] + 1
                    que.append(v)
        
        flg = True
        for i in range(1, k):
            if dis[visits[i]] <= dis[visits[i - 1]]:
                flg = False
        
        if flg:
            outs.append(str(k if visits[0] else k - 1))
            cur = 0
            for x in visits:
                if x != cur:
                    outs.append(f'{cur + 1} {x + 1}')
                    cur = x
        else:
            outs.append('-1')
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int n, m, k;
        cin >> n >> m >> k;

        vector<int> nodes(k);
        for (auto &x: nodes) cin >> x;

        vector<vector<int>> path(n + 1);
        while (m --) {
            int u, v;
            cin >> u >> v;
            path[u].emplace_back(v);
            path[v].emplace_back(u);
        }

        int cur = 1;
        for (auto &x: nodes) {
            if (cur != x) {
                path[cur].emplace_back(x);
                path[x].emplace_back(cur);
                cur = x;
            }
        }

        vector<int> dis(n + 1, -1);
        dis[1] = 0;

        queue<int> que;
        que.push(1);

        while (!que.empty()) {
            auto u = que.front(); que.pop();
            for (auto &v: path[u]) {
                if (dis[v] == -1) {
                    dis[v] = dis[u] + 1;
                    que.push(v);
                }
            }
        }

        bool flg = true;
        for (int i = 1; i < k; i ++) {
            if (dis[nodes[i]] <= dis[nodes[i - 1]]) {
                flg = false;
            }
        }

        if (flg) {
            cout << (nodes[0] == 1 ? k - 1 : k) << '\n';
            cur = 1;
            for (auto &x: nodes) {
                if (cur != x) {
                    cout << cur << ' ' << x << '\n';
                    cur = x;
                }
            }
        }
        else cout << "-1\n";
    }

    return 0;
}
```