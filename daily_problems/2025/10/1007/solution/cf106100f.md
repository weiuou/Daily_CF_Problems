**提示 1：** 简化一下题中的操作。

**提示 2：** 最小交换次数 —— 想想逆序对。

题中相当于把 $(x,y)$ 变成了 $(y-1,x+1)$ ，这个 $1$ 很怪异，怎么处理掉呢？

我们把每个位置的数减去下标，发现操作就等价于交换相邻元素。

所以经过上述处理后，如果两个数组不同，则无法通过操作实现转换。

对于两个数组，最少要交换多少次才能到达对方呢？交换问题可以考虑赋值后算逆序对。

具体地，只需要想办法按照数字在另一个数组中的出现顺序给数组赋值，那么交换次数等于赋值结果的逆序对个数。

如果一个数字出现多次，则越前面的数字赋值的下标应该越小，因为这样才能让逆序对更少。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    v1 = LII()
    v2 = LII()
    
    for i in range(n):
        v1[i] -= i
        v2[i] -= i
    
    if sorted(v1) != sorted(v2):
        print(-1)
    else:
        rnd = random.getrandbits(30)
        d = defaultdict(list)
        
        for i, v in enumerate(v1):
            d[v ^ rnd].append(i)
        
        for i in range(n - 1, -1, -1):
            v2[i] = d[v2[i] ^ rnd].pop()
        
        fen = FenwickTree(n)
        
        ans = 0
        for i in range(n):
            ans += fen.rsum(v2[i], n - 1)
            fen.add(v2[i], 1)
        
        print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> v1(n), v2(n);
    for (auto &x: v1) cin >> x;
    for (auto &x: v2) cin >> x;

    for (int i = 0; i < n; i ++) {
        v1[i] -= i;
        v2[i] -= i;
    }

    map<int, vector<int>> mp1;

    for (int i = 0; i < n; i ++) {
        mp1[v1[i]].emplace_back(i);
    }

    for (int i = n - 1; i >= 0; i --) {
        auto pt = mp1.find(v2[i]);
        if (pt == mp1.end() || pt->second.empty()) return cout << -1, 0;
        v2[i] = pt->second.back();
        pt->second.pop_back();
    }

    atcoder::fenwick_tree<int> fen(n);
    long long ans = 0;

    for (int i = 0; i < n; i ++) {
        ans += fen.sum(v2[i], n);
        fen.add(v2[i], 1);
    }

    cout << ans;

    return 0;
}
```