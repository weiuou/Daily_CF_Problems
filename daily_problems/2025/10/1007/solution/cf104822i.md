**提示 1：** 先转化条件。

**提示 2：** 如何更快速地得到备选答案？

$(a+b)|ab$ ， 而同时 $(a+b)|a(a+b)$ ，两个相减可以得到 $(a+b)|a^2$ 。

所以只需得到 $a^2$ 的大于 $a$ 的最小因子就行。

首先你可以快速得到 $a$ 的质因数分解。

接下来一种方式是，直接根据 $a^2$ 的质因数分解得到其所有因子，枚举即可。但效率相对较低。

你也可以认为，最后的结果是选取了两个 $a$ 的因子相乘了。这样你只需要枚举其中一个因子，另一个因子选的是刚好使得两者乘积大于 $a$ 的最小因子。因此将因子列表排序后，使用类似双指针的维护就行。

下面的逻辑略有不同，求的是小于 $a$ 的最大因子。还利用了一个事实：因子排序后，对称的位置的乘积等于 $a$ ，这样可以快速锁定乘积恰好为 $a$ 的位置，进而很方便地得到乘积小于或大于 $a$ 的位置。

时间复杂度为 $\mathcal{O}(\sqrt{M}/\log M+d(M)\log d(M))$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    M = 40000
    is_prime = [1] * (M + 1)
    prs = []
    
    for i in range(2, M + 1):
        if is_prime[i]:
            prs.append(i)
            for j in range(i * 2, M + 1, i):
                is_prime[j] = 0
    
    t = II()
    outs = []
    
    for _ in range(t):
        a = II()
        
        va = a
        vals = {}
        for p in prs:
            if p * p > va: break
            if va % p == 0:
                vals[p] = 0
                while va % p == 0:
                    vals[p] += 1
                    va //= p
        
        if va > 1:
            vals[va] = 1
        
        factors = [1]
        
        for x in vals:
            c = vals[x]
            k = len(factors)
            for i in range(c * k):
                factors.append(factors[i] * x)
    
        factors.sort()
        
        ans = a * a - a
        
        for i in range(len(factors) - 1):
            val = factors[i] * factors[len(factors) - 2 - i]
            ans = fmin(ans, a * a // val - a)
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int M = 40000;
    vector<int> isPrime(M + 1, 1), primes;

    for (int i = 2; i <= M; i ++) {
        if (isPrime[i]) {
            primes.emplace_back(i);
            for (int j = i * 2; j <= M; j += i) {
                isPrime[j] = 0;
            }
        }
    }

    int t;
    cin >> t;

    while (t --) {
        int a;
        cin >> a;

        map<int, int> prs;

        int va = a;
        for (auto &pr: primes) {
            if (pr * pr > va) break;
            while (va % pr == 0) {
                prs[pr] ++;
                va /= pr;
            }
        }

        if (va > 1) prs[va] ++;

        vector<int> factors = {1};

        for (auto &[p, x]: prs) {
            int c = x * factors.size();

            for (int i = 0; i < c; i ++) {
                factors.emplace_back(factors[i] * p);
            }
        }

        sort(factors.begin(), factors.end());

        long long ans = 1ll * a * a;

        for (int i = 0; i < factors.size() - 1; i ++) {
            int val = factors[i] * factors[factors.size() - 2 - i];
            ans = min(ans, 1ll * a * a / val - a);
        }

        cout << ans << '\n';
    }

    return 0;
}
```