**提示 1：** 正难则反。

**提示 2：** 删数，删哪个好呢？

正着加很难看清楚当前的状态和结尾的联系，考虑从结果倒退。

最后一次加入数字的位置一定满足 $a_i=i$ 。

如果有多个满足要求的位置我们最后一步操作应该操作在哪里呢？

应该操作最靠后的那个位置。否则的话后面的那些原有的备选元素下标只能不断变小，永远小于数值，也就不可能是一组合法的解。

在这种情况下，模拟 $n$ 轮找最靠后的不动点进行删除即可。如果某一时刻找不到，直接输出 `'NO'` 。否则，最后将删去的数逆序输出。

时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()
    
    ans = []
    
    for i in range(n - 1, -1, -1):
        for j in range(i, -1, -1):
            if nums[j] == j + 1:
                ans.append(nums.pop(j))
                break
        else:
            exit(print('NO'))
    
    ans.reverse()
    print('YES')
    print(' '.join(map(str, ans)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> nums(n), ops;
    for (auto &x: nums) cin >> x;

    for (int i = n - 1; i >= 0; i --) {
        bool flg = false;
        for (int j = i; j >= 0; j --) {
            if (nums[j] == j + 1) {
                flg = true;
                ops.emplace_back(nums[j]);
                nums.erase(nums.begin() + j);
                break;
            }
        }
        if (!flg) return cout << "NO", 0;
    }

    reverse(ops.begin(), ops.end());

    cout << "YES\n";
    for (auto &op: ops) cout << op << ' ';

    return 0;
}
```