**提示 1：** 每个 $f(i)$ 可以单独求。

**提示 2：** 对于每个 $i$ 而言，左右的选择是相互独立的。

考虑对每个 $i$ 求解。

首先左右端点分别可以取到哪里呢？就是前一个更大的位置后，后一个更大的位置前，显然用单调栈可以很容易维护这件事。

接下来求和。首先这个元素本身计算了几次呢？只需看有多少个子数组。子数组个数等于左端点的方案数乘右端点的方案数。

而左侧的子数组的总贡献如何呢？

首先，无论取哪个子数组，右侧的子数组是任选的，所以只需求出左侧的各种方案的和，最后乘以右侧的方案数就是答案了。

而左侧的选法相当于是求 $[],[a_{i-1}],[a_{i-2},a_{i-1}],\dots,[a_{left[i]+1},\dots,a_{i-1}]$ 的子数组和的和。

考虑 $a_j$ 在上述求和中的权重，是 $j-left[i]$ 。

所以我们只需求 $\sum\limits_{j=left[i]+1}^{i-1}(j-left[i])nums[j]=\sum\limits_{j=left[i]+1}^{i-1}j\times nums[j]-left[i]\sum\limits_{j=left[i]+1}^{i-1}nums[j]$ 。

于是只需维护 $nums[j]$ 和 $j\times nums[j]$ 的前缀和即可。

右侧的逻辑也是类似的。

总感觉题目变成，“对所有子数组，求子数组的和乘子数组中最大值的出现频率。将上述结果相加，答案如何？”是更好看的题目。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()
    mod = 10 ** 9 + 7
    
    acc1 = list(accumulate(nums, initial=0))
    acc2 = list(accumulate((i * nums[i] % mod for i in range(n)), initial=0))
    
    left = [0] * n
    stk = [-1]
    
    for i in range(n):
        while stk[-1] != -1 and nums[stk[-1]] <= nums[i]:
            stk.pop()
        left[i] = stk[-1]
        stk.append(i)
    
    right = [0] * n
    stk = [n]
    
    for i in range(n - 1, -1, -1):
        while stk[-1] != n and nums[stk[-1]] <= nums[i]:
            stk.pop()
        right[i] = stk[-1]
        stk.append(i)
    
    ans = 0
    
    for i in range(n):
        ans += nums[i] * (i - left[i]) % mod * (right[i] - i) % mod
        ans %= mod
        
        ans += (acc2[i] - acc2[left[i] + 1] - (acc1[i] - acc1[left[i] + 1]) * left[i]) % mod * (right[i] - i) % mod
        ans %= mod
        
        ans += ((acc1[right[i]] - acc1[i + 1]) * right[i] - (acc2[right[i]] - acc2[i + 1])) % mod * (i - left[i]) % mod
        ans %= mod
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, mod = 1e9 + 7;
    cin >> n;

    vector<int> nums(n);
    for (auto &x: nums)
        cin >> x;

    vector<int> acc1(n + 1, 0), acc2(n + 1, 0);

    for (int i = 0; i < n; i ++) {
        acc1[i + 1] = (acc1[i] + nums[i]) % mod;
        acc2[i + 1] = (acc2[i] + 1ll * nums[i] * i % mod) % mod;
    }

    vector<int> left(n), right(n), stk;

    stk = {-1};

    for (int i = 0; i < n; i ++) {
        while (stk.back() != -1 && nums[stk.back()] <= nums[i])
            stk.pop_back();
        left[i] = stk.back();
        stk.emplace_back(i);
    }

    stk = {n};

    for (int i = n - 1; i >= 0; i --) {
        while (stk.back() != n && nums[stk.back()] <= nums[i])
            stk.pop_back();
        right[i] = stk.back();
        stk.emplace_back(i);
    }

    int ans = 0;

    for (int i = 0; i < n; i ++) {
        ans += 1ll * nums[i] * (i - left[i]) % mod * (right[i] - i) % mod;
        ans %= mod;

        ans += 1ll * ((acc2[i] - acc2[left[i] + 1]) % mod - 1ll * (acc1[i] - acc1[left[i] + 1]) * left[i] % mod) % mod * (right[i] - i) % mod;
        ans %= mod;

        ans += 1ll * (1ll * (acc1[right[i]] - acc1[i + 1]) * right[i] % mod - (acc2[right[i]] - acc2[i + 1]) % mod) % mod * (i - left[i]) % mod;
        ans %= mod;
    }

    cout << (ans + mod) % mod;

    return 0;
}
```