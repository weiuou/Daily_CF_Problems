**提示 1：** 如果用了超过 $k$ 条边，则我们可以怎么做？

**提示 2：** 否则？

如果我们用了超过 $k$ 条边，那么我们不妨走遍这个连通块内所有的边，再取其中最小的 $k$ 条，这样结果一定更小。

否则，我们相当于选择了若干条边，每条边权都要算入答案，且这些边能让 $1,n$ 连通。显然最优选边方法是 $1$ 到 $n$ 的最短路。

于是将上述两种情况取最小值即可。

时间复杂度为 $\mathcal{O}(n+m\log m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m, k = MII()
    
    us = []
    vs = []
    ws = []
    
    path = [[] for _ in range(n)]
    dsu = UnionFind(n)
    
    for _ in range(m):
        u, v, w = GMI()
        w += 1
        us.append(u)
        vs.append(v)
        ws.append(w)
        
        path[u].append(w * n + v)
        path[v].append(w * n + u)
        
        dsu.merge(u, v)
    
    tmp = []
    for i in range(m):
        if dsu.find(us[i]) == dsu.find(0):
            tmp.append(ws[i])
    
    ans = sum(nsmallest(k, tmp))
    
    inf = 10 ** 15
    
    dis = [inf] * n
    dis[0] = 0
    
    pq = [0]
    
    while pq:
        d, u = divmod(heappop(pq), n)
        if dis[u] == d:
            for msk in path[u]:
                nd, v = divmod(msk, n)
                if dis[v] > dis[u] + nd:
                    dis[v] = dis[u] + nd
                    heappush(pq, dis[v] * n + v)
    
    print(fmin(ans, dis[-1]))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m, k;
    cin >> n >> m >> k;

    vector<array<int, 3>> edges(m);
    vector<vector<pair<int, int>>> path(n);
    atcoder::dsu uf(n);

    for (auto &[u, v, w]: edges) {
        cin >> u >> v >> w;
        u --, v --;
        path[u].emplace_back(v, w);
        path[v].emplace_back(u, w);
        uf.merge(u, v);
    }

    long long ans = 0;
    vector<int> chosen;

    for (auto &[u, v, w]: edges) {
        if (uf.leader(u) == uf.leader(0)) {
            chosen.emplace_back(w);
        }
    }

    sort(chosen.begin(), chosen.end());

    for (int i = 0; i < chosen.size(); i ++) {
        if (i < k) {
            ans += chosen[i];
        }
    }

    long long inf = 1e15;
    vector<long long> dis(n, inf);
    dis[0] = 0;

    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;
    pq.push({0, 0});

    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();

        if (dis[u] == d) {
            for (auto &[v, w]: path[u]) {
                if (dis[u] + w < dis[v]) {
                    dis[v] = dis[u] + w;
                    pq.push({dis[v], v});
                }
            }
        }
    }

    ans = min(ans, dis[n - 1]);

    cout << ans << '\n';

    return 0;
}
```