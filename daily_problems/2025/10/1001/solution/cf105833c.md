**提示 1：** 每个位置会受到哪些攻击的影响？

**提示 2：** 攻击总量没必要太大。

对于位置 $x$ ，不小于 $x$ 位置的攻击都能对它产生影响。

因此对于 $x$ ，关键的是后缀的总攻击量。

设在第 $i$ 个位置往后，总攻击量为 $v$ 情况下的最优结果是 $dp[i][v]$ 。

$v$ 没必要超过 $5000$ ，因为最大产生的伤害也就这么多，因此可以直接跟 $5000$ 取最小值。

于是，我们每个位置先进行总攻击量的转移，再根据当前总攻击量计算当前位置造成的伤害即可。

时间复杂度为 $\mathcal{O}(nM)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    hs = LII()
    ds = LII()
    cs = LII()
    
    inf = 10 ** 9
    dp = [-inf] * 5001
    
    dp[0] = 0
    
    for i in range(n - 1, -1, -1):
        for j in range(5000, -1, -1):
            nj = fmin(j + ds[i], 5000)
            dp[nj] = fmax(dp[nj], dp[j] - cs[i])
        
        for j in range(5001):
            dp[j] += fmin(j, hs[i])
    
    print(max(dp))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> hs(n), ds(n), cs(n);
    for (auto &h: hs) cin >> h;
    for (auto &d: ds) cin >> d;
    for (auto &c: cs) cin >> c;

    int inf = 1e9;

    vector<int> dp(5001, -inf);

    dp[0] = 0;

    for (int i = n - 1; i >= 0; i --) {
        for (int j = 5000; j >= 0; j --) {
            int nj = min(j + ds[i], 5000);
            dp[nj] = max(dp[nj], dp[j] - cs[i]);
        }

        for (int j = 0; j <= 5000; j ++)
            dp[j] += min(j, hs[i]);
    }

    cout << *max_element(dp.begin(), dp.end());

    return 0;
}
```