**提示 1：** 答案可能是什么形式？

**提示 2：** 其实备选不多。

答案的每个质因子的次数不需要大于 $1$ ，因为如果次数 $\geq 2$ 成立的话，等于 $1$ 也仍然不互质。

所以答案一定是一系列质数的乘积。而 $1\sim 50$ 范围内只有 $15$ 个质数（也是本题标题），所以直接枚举 $2^15$ 种答案就行。

判断的过程中不需要完整遍历数组，只需看 $1\sim 50$ 的数哪些出现过，哪些没出现，考虑那些出现过的数和备选答案的最大公约数即可。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    t = II()
    outs = []
    
    prs = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
    
    to_check = [1]
    for x in prs:
        for i in range(len(to_check)):
            to_check.append(to_check[i] * x)
    
    to_check.sort()
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        vis = [0] * 51
        for x in nums:
            vis[x] = 1
        
        for v in to_check:
            for i in range(51):
                if vis[i] and math.gcd(i, v) == 1:
                    break
            else:
                outs.append(v)
                break
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	vector<int> prs = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};
	vector<long long> to_check = {1};

	for (auto &x: prs) {
		int k = to_check.size();
		for (int i = 0; i < k; i ++) {
			to_check.emplace_back(to_check[i] * x);
		}
	}

	sort(to_check.begin(), to_check.end());

	int t;
	cin >> t;

	while (t --) {
		int n;
		cin >> n;

		vector<int> vis(51, 0);
		while (n --) {
			int x;
			cin >> x;
			vis[x] = 1;
		}

		for (auto &v: to_check) {
			bool flg = true;
			for (int i = 0; i <= 50; i ++) {
				if (vis[i] && gcd(i, v) == 1) {
					flg = false;
					break;
				}
			}
			if (flg) {
				cout << v << '\n';
				break;
			}
		}
	}

	return 0;
}
```