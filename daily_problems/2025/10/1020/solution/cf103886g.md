**提示 1：** 尝试将问题转化为规模更小的问题。

**提示 2：** 组内问题之后讨论，组间不呈等差数列。怎么弄？

将数字分为奇数偶数两组，奇数在前，偶数在后。

这样两组之间就无法形成等差数列了。

接下来递归分别解决前面和后面的问题。因为可以把整数 $1,2,\dots,k$ 直接映射到 $1,3,\dots,2k-1$ 或者 $2,4,\dots,2k$ 。

时间复杂度为 $\mathcal{O}(n\log n)$ ，如果加上记忆化就可以进一步到 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main(): 
    def solve(x):
        if x == 1: return [1]
        even = x // 2
        odd = x - x // 2
        return [x * 2 for x in solve(even)] + [x * 2 - 1 for x in solve(odd)]
    
    n = II()
    print(*solve(n))
```

C++ 做法如下——

```cpp []
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	auto solve = [&] (auto &self, int x) -> vector<int> {
		if (x == 1) return {1};
		vector<int> ans;
		for (auto &v: self(self, x / 2)) ans.emplace_back(2 * v);
		for (auto &v: self(self, x - x / 2)) ans.emplace_back(2 * v - 1);
		return ans;
	};

	for (auto &v: solve(solve, n)) cout << v << ' ';

	return 0;
}
```