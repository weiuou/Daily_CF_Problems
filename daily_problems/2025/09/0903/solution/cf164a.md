**提示 1：** 路径的开头和结尾有条件，所以应该从这两个位置入手。

每条路径重要条件是 $1$ 开头， $2$ 结尾，中间是 $0$ 或者 $2$ 。所以关键点一定是开头和结尾。

因此路径中可以经过的店一定可以从 $1$ 出发到达，并从这个点出发到达一个 $2$ 。前者是原图可计算，后者是反图可计算。

具体地，我们从标记为 $1$ 的点出发，看走 $0$ 或者 $2$ 标记的点，能到达的位置。再在反图中，从标记为 $2$ 的点出发，并走到 $1$ 时不继续走，看能到达的店的位置。

这样两次遍历后，我们取交集就是能在路径上的点。

时间复杂度为 $\mathcal{O}(n+m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    vals = LII()
    
    path = [[] for _ in range(n)]
    rev_path = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v = GMI()
        path[u].append(v)
        rev_path[v].append(u)
    
    vis1 = [0] * n
    que = []
    
    for i in range(n):
        if vals[i] == 1:
            vis1[i] = 1
            que.append(i)
    
    for u in que:
        for v in path[u]:
            if not vis1[v] and (vals[v] == 0 or vals[v] == 2):
                vis1[v] = 1
                que.append(v)
    
    vis2 = [0] * n
    que = []
    
    for i in range(n):
        if vals[i] == 2:
            vis2[i] = 1
            que.append(i)
    
    for u in que:
        if vals[u] == 1: continue
        
        for v in rev_path[u]:
            if not vis2[v]:
                vis2[v] = 1
                que.append(v)
    
    print('\n'.join(str(vis1[i] & vis2[i]) for i in range(n)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<int> nums(n);
    for (auto &x: nums) cin >> x;

    vector<vector<int>> path(n), rev_path(n);
    for (int i = 0; i < m; i ++) {
        int u, v;
        cin >> u >> v;
        u --, v --;
        path[u].emplace_back(v);
        rev_path[v].emplace_back(u);
    }

    vector<int> vis1(n, 0), vis2(n, 0);

    auto dfs1 = [&] (auto &self, int u) -> void {
        vis1[u] = 1;
        for (auto &v: path[u]) {
            if (!vis1[v] && nums[v] != 1) {
                self(self, v);
            }
        }
    };

    for (int i = 0; i < n; i ++)
        if (nums[i] == 1) dfs1(dfs1, i);
    
    auto dfs2 = [&] (auto &self, int u) -> void {
        vis2[u] = 1;
        if (nums[u] == 1) return ;

        for (auto &v: rev_path[u]) {
            if (!vis2[v]) {
                self(self, v);
            }
        }
    };

    for (int i = 0; i < n; i ++)
        if (nums[i] == 2) dfs2(dfs2, i);
    
    for (int i = 0; i < n; i ++)
        cout << (vis1[i] & vis2[i]) << '\n';

    return 0;
}
```