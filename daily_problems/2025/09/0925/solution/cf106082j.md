**提示 1：** 可以认为是个完全图中，找到最短的路径。

**提示 2：** 想想每个元素在不同的权值下可以走到的位置。

我们认为是 $n$ 个点两两相连，路径权值等于路径上最长边的权值，最后查询两两最短路。

考虑 $u,v$ 两点最短路怎么求。我们可以按照边权从小到大遍历各条边，遍历的过程中，把相互可达的点用并查集合并到一起去，直到 $u,v$ 连通。

这件事其实正是最小生成树，所以我们只需求最小生成树，再在最小生成树中找答案就行。但上面边数太多可能会 TLE（至少如果出题人正常的话会卡你 TLE），怎么办呢？

注意使用 Prim 算法可以轻松地在稠密图中以 $\mathcal{O}(n^2)$ 的时间复杂度求解最小生成树。

而接下来我们可以以每一个点为起点进行树上结点的遍历，进而以 $n\times\mathcal{O}(n)=\mathcal{O}(n^2)$ 的复杂度进行答案的预处理，于是后面的查询就无需使用 LCA、树链剖分等技巧了。

时间复杂度为 $\mathcal{O}(n^2+q)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    xs = []
    ys = []
    
    for _ in range(n):
        x, y = MII()
        xs.append(x)
        ys.append(y)
    
    inf = 10 ** 15
    
    vis = [0] * n
    prev = [-1] * n
    mi_dis = [inf] * n
    
    vis[0] = 1
    mi_dis[0] = 0
    cur = 0
    
    edges = []
    
    for _ in range(n - 1):
        ncur = -1
        
        for i in range(n):
            if not vis[i]:
                nd = (xs[i] - xs[cur]) * (xs[i] - xs[cur]) + (ys[i] - ys[cur]) * (ys[i] - ys[cur])
                if nd < mi_dis[i]:
                    mi_dis[i] = nd
                    prev[i] = cur
                
                if ncur == -1 or mi_dis[i] < mi_dis[ncur]:
                    ncur = i
        
        cur = ncur
        vis[cur] = 1
        
        edges.append((mi_dis[cur] * n + prev[cur]) * n + cur)
    
    edges.sort()
    tmp = [[i] for i in range(n)]
    uf = list(range(n))
    
    ans = [[0] * n for _ in range(n)]
    
    for edge in edges:
        msk, v = divmod(edge, n)
        w, u = divmod(msk, n)
        
        u = uf[u]
        v = uf[v]
        
        for x in tmp[u]:
            for y in tmp[v]:
                ans[x][y] = w
                ans[y][x] = w
        
        for x in tmp[u]:
            tmp[v].append(x)
            uf[x] = v
        
        tmp[u].clear()
    
    outs = []
    q = II()
    
    for _ in range(q):
        u, v = GMI()
        outs.append(math.sqrt(ans[u][v]))
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<pair<int, int>> pts(n);
    for (auto &[x, y]: pts) cin >> x >> y;

    vector<int> vis(n, 0), prev(n, -1);
    long long inf = 1e15;
    vector<long long> cur_mi(n, inf);

    int cur = 0;
    vis[cur] = 1, cur_mi[cur] = 0;

    auto dis = [&] (int i, int j) -> long long {
        return 1ll * (pts[i].first - pts[j].first) * (pts[i].first - pts[j].first) + 
               1ll * (pts[i].second - pts[j].second) * (pts[i].second - pts[j].second);
    };

    vector<vector<pair<int, long long>>> path(n);

    for (int i = 0; i < n - 1; i ++) {
        int ncur = -1;
        for (int j = 0; j < n; j ++) {
            if (!vis[j]) {
                long long nd = dis(cur, j);
                if (nd < cur_mi[j]) {
                    cur_mi[j] = nd;
                    prev[j] = cur;
                }
                if (ncur == -1 || cur_mi[j] < cur_mi[ncur])
                    ncur = j;
            }
        }

        cur = ncur;
        vis[cur] = 1;
        path[cur].emplace_back(prev[cur], cur_mi[cur]);
        path[prev[cur]].emplace_back(cur, cur_mi[cur]);
    }

    vector<vector<long long>> ans(n, vector<long long>(n));

    auto dfs = [&] (auto &self, int start, int u, int p, long long cur) -> void {
        ans[start][u] = cur;
        for (auto &[v, w]: path[u]) {
            if (v != p) {
                self(self, start, v, u, max(cur, w));
            }
        }
    };

    for (int i = 0; i < n; i ++)
        dfs(dfs, i, i, -1, 0);

    int q;
    cin >> q;

    cout << fixed << setprecision(12);
    while (q --) {
        int u, v;
        cin >> u >> v;
        u --, v --;
        cout << sqrtl(ans[u][v]) << '\n';
    }

    return 0;
}
```
