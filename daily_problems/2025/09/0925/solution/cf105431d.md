**提示 1：** 实际上是 LIS 问题。在一般情况下是 $\mathcal{O}(n^2)$ 的问题，这里怎么进一步优化呢？特殊性在于每个元素出现次数不多。

先看提示 1 。

考虑第一个序列取第 $i$ 个元素的情况下的最长公共子序列。

则这个元素只能跟第二个序列的 $k$ 个出现的位置匹配。

因此，我们只需考虑第一个序列在只选择 $i-1$ 位置往前的位置时，和第二个序列到第 $p$ 个位置的最长公共子序列。

这样我们只需枚举这 $k$ 个位置，假设枚举到 $p_i$ ，再查询在 $p_i-1$ 往前的位置能和 $i-1$ 匹配的最大 LIS 长度，再加上当前匹配的 $1$ ，就是 $p_i$ 处应当更新的数值了。

具体而言，就是依次遍历第一个数组的每一个位置，然后数据结构维护第二个数组的每一个位置对应的当前的最长 LIS 长度。遍历位置的过程中更新第二个数组。

发现这里只涉及了单点更新和前缀查询，所以甚至可以使用树状数组。

可以想想为啥下面的代码是逆序遍历第二个数组的位置的。

时间复杂度为 $\mathcal{O}(nk^2\log(nk))$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k = MII()
    v1 = LII()
    v2 = LII()
    
    pos = [[] for _ in range(n + 1)]
    
    for i in range(n * k - 1, -1, -1):
        pos[v2[i]].append(i)
    
    fen = MaxFenwickTree(n * k + 1)
    
    for i in range(n * k):
        for j in pos[v1[i]]:
            fen.set(j + 1, fen.prefmax(j) + 1)
    
    print(fen.prefmax(n * k))
```

C++ 做法如下——

```cpp []
int op(int x, int y) {return max(x, y);}
int e() {return 0;}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, k;
    cin >> n >> k;

    vector<int> v1(n * k), v2(n * k);
    for (auto &x: v1) cin >> x;
    for (auto &x: v2) cin >> x;

    vector<vector<int>> pos(n + 1);
    for (int i = n * k - 1; i >= 0; i --)
        pos[v2[i]].emplace_back(i);
    
    atcoder::segtree<int, op, e> seg(n * k);
    for (int i = 0; i < n * k; i ++) {
        for (auto &j: pos[v1[i]]) {
            seg.set(j, max(seg.get(j), seg.prod(0, j) + 1));
        }
    }

    cout << seg.all_prod();

    return 0;
}
```
