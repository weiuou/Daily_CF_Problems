**提示 1：** 考虑相邻两个点。

**提示 2：** 向量们需要满足什么条件。

题目相当于要我们在新的坐标系下，给出的点是严格递增的序列。

在有答案的情况下，我们一定能让第一个维度两两不同且相对关系仍然成立。

考虑一个满足条件但第一个维度有重复的情况，此时我们小幅旋转坐标系的话，不会改变原有的横坐标不同的点的相对关系；而原有的横坐标相同的点会按照纵坐标的顺序重新排列，因此也顺时针 / 逆时针旋转总有一个方向符合要求。

所以我们只需满足在新坐标系下 $x_i\lt x_{i+1}$ 就好了。

而设新坐标系的 $x$ 轴单位方向向量是 $\overrightarrow{v_x}$ ，则点 $P$ 的横坐标是 $\overrightarrow{OP}·\overrightarrow{v_x}$ 。

所以 $P_i,P_{i+1}$ 横坐标递增，等价于 $\overrightarrow{OP_i}·\overrightarrow{v_x}\lt\overrightarrow{OP_{i+1}}·\overrightarrow{v_x}$ ，移项后使用乘法分配律有 $\overrightarrow{P_iP_{i+1}}·\overrightarrow{v_x}\gt 0$ 。

所以我们先得到所有 $\overrightarrow{P_iP_{i+1}}$ ，则我们要找一个方向，使得任何一个前面得到的向量在它的投影上都是正数。

对于任意一个方向，投影为正数的向量与它所成的角度都是锐角 / 0 度角，所以整体方向不会超过半平面。

因此，我们将向量按照辐角排序，其两端角度不能大于等于平角。

考虑两端的向量，因为中间的方向都可以用它们非负地线性表示，因此只要两端的投影为正，中间向量的投影也为正数。接下来只需根据这两个向量构造就行。

如果这两个向量成锐角，则这两个向量本身 / 它们的和都满足要求。

如果这两个向量成钝角或直角，设它们分别是 $\overrightarrow{a},\overrightarrow{b}$ ，我们找到跟 $\overrightarrow{a}$ 垂直且在 $\overrightarrow{b}$ 上投影为正的向量 $\overrightarrow{v_a}$ ，以及跟 $\overrightarrow{b}$ 垂直且在 $\overrightarrow{a}$ 上投影为正的向量 $\overrightarrow{v_b}$ ，那么 $\overrightarrow{v_a}+\overrightarrow{v_b}$ 一定符合要求。而这个向量的坐标也不会超过数据范围要求。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    x, y = MII()
    
    if n == 1:
        print('YES')
        print(1, 0)
        print(0, 1)
        exit()
    
    xs = []
    ys = []
    
    for _ in range(n - 1):
        nx, ny = MII()
        xs.append(nx - x)
        ys.append(ny - y)
        x, y = nx, ny
    
    def cmp(i, j):
        xi, yi = xs[i], ys[i]
        xj, yj = xs[j], ys[j]
    
        v = xi * yj - yi * xj
        if v > 0: return 1
        if v < 0: return -1
        return 0
    
    st_range = sorted(range(n - 1), key=cmp_to_key(cmp))
    
    i1 = st_range[0]
    i2 = st_range[-1]
    
    x1, y1 = xs[i1], ys[i1]
    x2, y2 = xs[i2], ys[i2]
    
    if x1 * x2 + y1 * y2 >= 0:
        vx, vy = x1 + x2, y1 + y2
    else:
        vx1, vy1 = y1, -x1
        if vx1 * x2 + vy1 * y2 < 0: vx1, vy1 = -vx1, -vy1
        vx2, vy2 = y2, -x2
        if vx2 * x1 + vy2 * y1 < 0: vx2, vy2 = -vx2, -vy2
        vx, vy = vx1 + vx2, vy1 + vy2
    
    for i in range(n - 1):
        if vx * xs[i] + vy * ys[i] <= 0:
            exit(print('NO'))
    
    print('YES')
    print(vx, vy)
    print(-vy, vx)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    int x, y;
    cin >> x >> y;

    overrightarrowtor<pair<int, int>> pts;

    for (int i = 0; i < n - 1; i ++) {
        int nx, ny;
        cin >> nx >> ny;

        pts.emplace_back(nx - x, ny - y);
        x = nx, y = ny;
    }

    if (n == 1) {
        cout << "YES\n";
        cout << "1 0\n";
        cout << "0 1\n";
        return 0;
    }

    stable_sort(pts.begin(), pts.end(), [&] (pair<int, int> x, pair<int, int> y) {
        return 1ll * x.first * y.second < 1ll * x.second * y.first;
    });

    auto [x1, y1] = *pts.begin();
    auto [x2, y2] = *pts.rbegin();

    int vx, vy;

    if (1ll * x1 * x2 + 1ll * y1 * y2 >= 0)
        vx = x1 + x2, vy = y1 + y2;
    else {
        int vx1 = y1, vy1 = -x1;
        if (1ll * vx1 * x2 + 1ll * vy1 * y2 < 0) vx1 = -vx1, vy1 = -vy1;
        int vx2 = y2, vy2 = -x2;
        if (1ll * vx2 * x1 + 1ll * vy2 * y1 < 0) vx2 = -vx2, vy2 = -vy2;
        vx = vx1 + vx2, vy = vy1 + vy2;
    }

    for (auto &[x, y]: pts) {
        if (1ll * vx * x + 1ll * vy * y <= 0) {
            return cout << "NO", 0;
        }
    }

    cout << "YES\n";
    cout << vx << ' ' << vy << '\n';
    cout << -vy << ' ' << vx << '\n';

    return 0;
}
```
