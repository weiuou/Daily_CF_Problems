**提示 1：** 找到一种凑数的方法。

我们的数码和至少得是 $d$ ，所以不得不有很多位数。而如果过于杂乱，其实是不利于我们最后凑数的。

所以我们不妨让每个数字都一样，形成 $10^x-1$ 的结构。

这个结构的问题在于， $2$ 的倍数和 $5$ 的倍数凑不出来。而这很好办，直接在结尾加上足够多的 $0$ 就行。

考虑对于一个跟 $10$ 互质的数，根据费马小定理推广得到的欧拉定理，有 $10^{\phi(x)}≡1\ (\bmod x)$ ，其中 $\phi(x)$ 表示不超过 $x$ 的跟 $x$ 互质的数的个数。所以 $10^{\phi(d)}≡1\ (\bmod d)$

而 $10^x-1$ 中有 $x$ 个 $9$ ，所以只要 $x$ 是 $d$ 的倍数，数码和也是 $d$ 的倍数。

根据上述讨论， $d\times\phi(d)$ 是满足条件的，因为 $10^{d\phi(d)}≡(10^{\phi(d)})^d≡1^d≡1\ (\bmod d)$ ，而其数码中有 $d\phi (d)$ 个 $9$ ，因此也是 $d$ 的倍数。

于是我们找到了构造方法。具体实现只需枚举尝试多少个 $9$ 凑出答案就行。

时间复杂度为 $\mathcal{O}(d^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    d = II()
    saved = d
    
    while d % 2 == 0:
        d //= 2
    
    while d % 5 == 0:
        d //= 5
    
    cur = 0
    tot = 0
    
    for i in range(1, 10 ** 6):
        cur = (cur * 10 + 9) % d
        tot = (tot + 9) % saved
        
        if cur == 0 and tot == 0:
            print('9' * i + '0' * 13)
            break
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int d, saved;
    cin >> d;

    saved = d;

    while (d % 2 == 0) d /= 2;
    while (d % 5 == 0) d /= 5;

    int cur = 0, tot = 0;

    for (int i = 1; i <= 1000000; i ++) {
        cur = (10ll * cur + 9) % d;
        tot = (tot + 9) % saved;

        if (cur == 0 && tot == 0)
            return cout << string(i, '9') << string(10, '0'), 0;
    }

    return 0;
}
```
