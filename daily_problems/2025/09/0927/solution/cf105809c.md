**提示 1：** 考虑矛盾的点连边，这个图有啥性质？

**提示 2：** 相当于一个什么问题？

将所有一步可达的点对之间连边，这个图有啥性质吗？

这个图是个二分图，为什么呢？因为相连的两个点的三个坐标和加起来的奇偶性一定不同。所以可以根据坐标和将点分为两类，同类点间没有边。

接下来我们要求的就是二分图的最大独立集就好，为此我们求二分图最大匹配，再用总点数减去它即可。

时间复杂度为 $\mathcal{O}(A^{2.5}B^{2.5}C^{2.5})$ ，因为边数是 $A^2B^2C^2$ 量级的，而这里是二分图匹配，所以可以得到复杂度。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    a, b, c = MII()
    blocked = [0] * (a * b * c)
    
    def f(x, y, z):
        return (x * b + y) * c + z
    
    k = II()
    for _ in range(k):
        x, y, z = GMI()
        blocked[f(x, y, z)] = 1
    
    mf = MFGraph(a * b * c + 2)
    dirs = []
    
    for i in range(-2, 3):
        for j in range(-2, 3):
            if abs(i) + abs(j) == 3:
                dirs.append((0, i, j))
                dirs.append((i, 0, j))
                dirs.append((i, j, 0))
    
    cnt = a * b * c
    
    src = a * b * c
    dst = src + 1
    
    for i in range(a):
        for j in range(b):
            for k in range(c):
                if not blocked[f(i, j, k)]:
                    if (i + j + k) % 2 == 0:
                        mf.add_edge(src, f(i, j, k), 1)
                        for di, dj, dk in dirs:
                            ni = i + di
                            nj = j + dj
                            nk = k + dk
                            
                            if 0 <= ni < a and 0 <= nj < b and 0 <= nk < c and not blocked[f(ni, nj, nk)]:
                                mf.add_edge(f(i, j, k), f(ni, nj, nk), 1)
                    else:
                        mf.add_edge(f(i, j, k), dst, 1)
                else:
                    cnt -= 1
    
    print(cnt - mf.flow(src, dst))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int a, b, c;
    cin >> a >> b >> c;

    vector<int> blocked(a * b * c, 0);

    auto f = [&] (int x, int y, int z) -> int {
        return (x * b + y) * c + z;
    };

    int k;
    cin >> k;

    while (k --) {
        int x, y, z;
        cin >> x >> y >> z;
        x --, y --, z --;
        blocked[f(x, y, z)] = 1;
    }

    atcoder::mf_graph<int> mf(a * b * c + 2);
    int cnt = a * b * c, src = a * b * c, dst = src + 1;

    vector<array<int, 3>> dirs;

    for (int i = -2; i <= 2; i ++) {
        for (int j = -2; j <= 2; j ++) {
            if (abs(i) + abs(j) == 3) {
                dirs.push_back({0, i, j});
                dirs.push_back({i, 0, j});
                dirs.push_back({i, j, 0});
            }
        }
    }

    for (int i = 0; i < a; i ++) {
        for (int j = 0; j < b; j ++) {
            for (int k = 0; k < c; k ++) {
                if (!blocked[f(i, j, k)]) {
                    if ((i + j + k) % 2) {
                        mf.add_edge(src, f(i, j, k), 1);
                        for (auto &[di, dj, dk]: dirs) {
                            int ni = i + di;
                            int nj = j + dj;
                            int nk = k + dk;
                            if (ni >= 0 && ni < a && nj >= 0 && nj < b && nk >= 0 && nk < c && !blocked[f(ni, nj, nk)])
                                mf.add_edge(f(i, j, k), f(ni, nj, nk), 1);
                        }
                    }
                    else mf.add_edge(f(i, j, k), dst, 1);
                }
                else cnt --;
            }
        }
    }

    cout << cnt - mf.flow(src, dst);

    return 0;
}
```
