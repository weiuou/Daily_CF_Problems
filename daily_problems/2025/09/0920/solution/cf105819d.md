**提示 1：** 按照位考虑问题。

**提示 2：** 有了边之后，哪些点可达如何判断？

按照位考虑，即 $u, v$ 能否通过第 $i$ 位相连。

一条边有用当且仅当其两个端点的数值第 $i$ 位都是 $1$ 。

于是我们只需考虑第 $i$ 位产生的图。该图中有若干条无向边，我们要判断哪些点可达。无向图的连通性直接用并查集就好了。

时间复杂度为 $\mathcal{O}((n^2+m)\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    nums = LII()
    
    us = []
    vs = []
    
    for _ in range(m):
        u, v = GMI()
        us.append(u)
        vs.append(v)
    
    uf = UnionFind(n)
    
    ans = [[0] * n for _ in range(n)]
    
    for i in range(30):
        uf.init()
        
        for j in range(m):
            u, v = us[j], vs[j]
            if nums[u] >> i & 1 and nums[v] >> i & 1:
                uf.merge(u, v)
        
        for x in range(n):
            for y in range(n):
                if uf.find(x) == uf.find(y):
                    ans[x][y] = 1
    
    print('\n'.join(''.join(map(str, x)) for x in ans))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<int> nums(n);
    for (auto &x: nums) cin >> x;

    vector<pair<int, int>> edges(m);
    for (auto &[u, v]: edges)
        cin >> u >> v, u --, v --;
    
    atcoder::dsu uf(n);
    vector<string> ans(n, string(n, '0'));

    for (int i = 0; i < 30; i ++) {
        uf.init();
        for (auto &[u, v]: edges) {
            if ((nums[u] >> i & 1) && (nums[v] >> i & 1)) {
                uf.merge(u, v);
            }
        }
        for (int u = 0; u < n; u ++) {
            for (int v = 0; v < n; v ++) {
                if (uf.leader(u) == uf.leader(v)) {
                    ans[u][v] = '1';
                }
            }
        }
    }

    for (auto &x: ans) cout << x << '\n';

    return 0;
}
```
