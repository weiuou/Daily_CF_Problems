**提示 1：** $i$ 是关键的，感性理解是内部的一个点。

**提示 2：** 任何一个内部的点都能找到答案吗？

$p_i$ 在其他点内部，所以要找一个“里面的”点。

为此，我们可以先求凸包。如果凸包内没有点，则无法构造。

否则，内部至少存在一点。我们取出任何一个点都可以构造吗？

答案是肯定的，因为我们可以把多边形拆成若干个三角形，这个点肯定在其中一个三角形的内部。

所以取出内部下标最小的点即可。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    def check(x1, y1, x2, y2, x3, y3):
        dx1, dy1 = x2 - x1, y2 - y1
        dx2, dy2 = x3 - x1, y3 - y1
        return dx1 * dy2 < dx2 * dy1
    
    for _ in range(t):
        n = II()
        pts = [tuple(MII()) for _ in range(n)]
        
        cv = convex_hull(pts[:])
        chosen = set(cv)
        
        pos = {v: i for i, v in enumerate(pts)}
        
        if len(cv) == n: outs.append('-1')
        else:
            for idx, pt in enumerate(pts):
                if pt not in chosen:
                    x, y = pt
                    
                    for i in range(2, len(cv)):
                        x1, y1 = cv[0]
                        x2, y2 = cv[i - 1]
                        x3, y3 = cv[i]
                        
                        if check(x1, y1, x2, y2, x, y) and check(x2, y2, x3, y3, x, y) and check(x3, y3, x1, y1, x, y):
                            outs.append(f'{idx + 1} {pos[(x1, y1)] + 1} {pos[(x2, y2)] + 1} {pos[(x3, y3)] + 1}')
                            break
                    break
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
typedef array<int, 2> vec;
vec dir(vec x1, vec x2) {return {x2[0] - x1[0], x2[1] - x1[1]};}
bool sgn(vec x) {return x[0] > 0 || (x[0] == 0 && x[1] > 0);}
long long cross(vec x1, vec x2) {return 1ll * x1[0] * x2[1] - 1ll * x1[1] * x2[0];}
long long dot(vec x1, vec x2) {return 1ll * x1[0] * x2[0] + 1ll * x1[1] * x2[1];}

vector<vec> convex_hull(vector<vec> pts) {
    sort(pts.begin(), pts.end());
    vector<vec> up, down;
    
    for (auto &pt: pts) {
        while (up.size() > 1) {
            auto v1 = up[up.size() - 2], v2 = up[up.size() - 1];
            if (cross(dir(v1, v2), dir(v1, pt)) >= 0) up.pop_back();
            else break;
        }
        up.emplace_back(pt);
    }

    for (auto &pt: pts) {
        while (down.size() > 1) {
            auto v1 = down[down.size() - 2], v2 = down[down.size() - 1];
            if (cross(dir(v1, v2), dir(v1, pt)) <= 0) down.pop_back();
            else break;
        }
        down.emplace_back(pt);
    }

    down.pop_back();
    down.insert(down.end(), up.rbegin(), up.rend());
    down.pop_back();
    return down;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int n;
        cin >> n;

        vector<vec> pts(n);
        for (auto &[x, y]: pts) cin >> x >> y;

        auto cv = convex_hull(pts);
        set<vec> chosen(cv.begin(), cv.end());

        map<vec, int> pos;
        for (int i = 0; i < n; i ++)
            pos[pts[i]] = i;
        
        auto check = [&] (int x1, int y1, int x2, int y2, int x3, int y3) -> bool {
            int dx1 = x2 - x1, dy1 = y2 - y1;
            int dx2 = x3 - x1, dy2 = y3 - y1;
            return 1ll * dx1 * dy2 > 1ll * dx2 * dy1;
        };

        if (cv.size() == n) cout << -1 << '\n';
        else {
            for (int idx = 0; idx < n; idx ++) {
                if (chosen.find(pts[idx]) == chosen.end()) {
                    auto [x, y] = pts[idx];

                    for (int i = 2; i < cv.size(); i ++) {
                        auto [x1, y1] = cv[0];
                        auto [x2, y2] = cv[i - 1];
                        auto [x3, y3] = cv[i];

                        if (check(x1, y1, x2, y2, x, y) &&
                            check(x2, y2, x3, y3, x, y) && 
                            check(x3, y3, x1, y1, x, y)) {
                            cout << idx + 1 << ' ' << pos[{x1, y1}] + 1 << ' ' << pos[{x2, y2}] + 1 << ' ' << pos[{x3, y3}] + 1 << '\n';
                            break;
                        }
                    }
                    break;
                }
            }
        }
    }

    return 0;
}
```
