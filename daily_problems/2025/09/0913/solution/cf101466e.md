**提示 1：** 选的前缀越长匹配次数越少。

我们要找到最长的在第一个串中匹配超过 $cnt$ 次的第二个串的前缀。

前缀越长，出现次数显然越少。所以可以考虑使用二分。

每次检查某个长度的前缀在第一个字符串内的出现次数，这件事可以使用 KMP 等字符串匹配算法解决。

如果出现次数达到了，则可能可以取更长的串，否则只能取更短的。根据这个逻辑进行二分即可。

时间复杂度为 $\mathcal{O}((|s|+|t|)\log |t|)$ 。

本题也可以使用后缀数组，进一步优化时间复杂度，但显然是不必要的。同时注意这里是按照行输入，又可能包含空格，所以需要学习对应的按照行读入的方法。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    s = I()
    t = I()
    cnt = II()
    
    l, r = 1, len(t)
    
    while l <= r:
        mid = (l + r) // 2
        
        if prep(t[:mid] + '#' + s).count(mid) >= cnt:
            l = mid + 1
        else:
            r = mid - 1
    
    print(t[:r] if r else 'IMPOSSIBLE')
```

C++ 做法如下——

```cpp []
vector<int> prep(string s) {
    int n = s.size();
    vector<int> pi(n, 0);

    int j = 0;
    for (int i = 1; i < n; i ++) {
        while (j && s[j] != s[i]) j = pi[j - 1];
        if (s[j] == s[i]) j ++;
        pi[i] = j;
    }

    return pi;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    string s, t;
    int cur;

    getline(cin, s);
    getline(cin, t);
    cin >> cur;

    int n = s.size(), m = t.size();

    int l = 1, r = m;
    while (l <= r) {
        int mid = (l + r) / 2;

        string tmp = t.substr(0, mid) + "#" + s;
        auto kmp = prep(tmp);

        int cnt = 0;
        for (auto &v: kmp) cnt += (v == mid);

        if (cnt >= cur) l = mid + 1;
        else r = mid - 1;
    }

    if (r) cout << t.substr(0, r);
    else cout << "IMPOSSIBLE";

    return 0;
}
```