**提示 1：** 其实查询的过程都是慢慢移动的，所以没必要真的反转子串。

**提示 2：** 打标记。

我们的指针是一点点慢慢动的，所以不会查询特别无关的位置，所以没必要真的反转子串。

我们用一个栈维护开头的部分，一个栈维护结尾的部分，一个双端队列维护中间的部分。

对于反转操作，我们直接打标记，记录当前子串是否需要反转，反转两次等于不需要反转，用一个 0-1 变量即可维护。

那么我们移动指针怎么办呢？

在中间子串无需反转的情况下，正常维护。

否则，把队头队尾反向理解，进行字符的转移即可。

时间复杂度为 $\mathcal{O}(n+q)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, l, r = MII()
    s = I()
    
    stk_left = list(s[:l-1])
    que_mid = deque(s[l-1:r])
    stk_right = list(s[r:])
    stk_right.reverse()
    
    q = II()
    flg = 1
    outs = []
    
    for _ in range(q):
        query = LI()
        
        if query[0] == 'Q':
            outs.append(que_mid[0] if (query[1] == 'L') == flg else que_mid[-1])
        elif query[0] == 'R':
            flg ^= 1
        else:
            if query[1] == 'L':
                if query[2] == 'L':
                    if flg:
                        que_mid.appendleft(stk_left.pop())
                    else:
                        que_mid.append(stk_left.pop())
                else:
                    if flg:
                        stk_left.append(que_mid.popleft())
                    else:
                        stk_left.append(que_mid.pop())
            else:
                if query[2] == 'L':
                    if flg:
                        stk_right.append(que_mid.pop())
                    else:
                        stk_right.append(que_mid.popleft())
                else:
                    if flg:
                        que_mid.append(stk_right.pop())
                    else:
                        que_mid.appendleft(stk_right.pop())
    
    print(''.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, l, r;
    cin >> n >> l >> r;

    string s;
    cin >> s;

    vector<char> stk_left(s.begin(), s.begin() + l - 1), stk_right(s.begin() + r, s.end());
    deque<char> que_mid(s.begin() + l - 1, s.begin() + r);

    reverse(stk_right.begin(), stk_right.end());

    int q;
    cin >> q;

    int flg = 1;
    
    while (q --) {
        char t;
        cin >> t;

        if (t == 'Q') {
            char c;
            cin >> c;
            cout << (((c == 'L') == flg) ? que_mid.front() : que_mid.back());
        }
        else if (t == 'R') flg ^= 1;
        else {
            char c1, c2;
            cin >> c1 >> c2;

            if (c1 == 'L') {
                if (c2 == 'L') {
                    auto v = stk_left.back(); stk_left.pop_back();
                    if (flg) que_mid.emplace_front(v);
                    else que_mid.emplace_back(v);
                }
                else {
                    char v;
                    if (flg) v = que_mid.front(), que_mid.pop_front();
                    else v = que_mid.back(), que_mid.pop_back();
                    stk_left.emplace_back(v);
                }
            }
            else {
                if (c2 == 'L') {
                    char v;
                    if (flg) v = que_mid.back(), que_mid.pop_back();
                    else v = que_mid.front(), que_mid.pop_front();
                    stk_right.emplace_back(v);
                }
                else {
                    auto v = stk_right.back(); stk_right.pop_back();
                    if (flg) que_mid.emplace_back(v);
                    else que_mid.emplace_front(v);
                }
            }
        }
    }

    return 0;
}
```
