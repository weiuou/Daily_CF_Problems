**提示 1：** 先从小情况入手。可以怎么做？

首先， $n=2k+1$ 比 $n=2k$ 只多了一个元素，但却能多查询一次，因此不妨让这次查询查 $n$ 这个位置，这样我们接下来就只需考虑偶数的情况。

如果你读到这里了，不妨试试看 $6$ 咋查。

方案是，先查 $[1,3]$ ，这样就知道哪些元素在前一半，哪些元素在后一半；接下来，对称地查询 $[1,5],[2,4]$ ，这样和 $[1,6]$ 的结果进行对比可以得到 $1,6$ ， $2,5$ 与 $3,4$ 有哪些元素，进一步根据哪些元素在前面，哪些元素在后面，可以确定每一个位置对应的元素。

于是对于其他偶数 $n$ 也是类似的，直接查询 $[1,n/2]$ ，确认前后两半部分分别是什么元素，接下来查询 $[2,n-1],[3,n-2],\dots,[n/2,n/2+1]$ 即可。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    def query(l, r):
        print('Q', l, r, flush=True)
        return LII()
    
    def answer(nums):
        print('A', *nums, flush=True)
    
    n = II()
    
    ans = [0] * n
    to_find = set(range(1, n + 1))
    
    if n % 2:
        ans[n - 1] = query(n, n)[0]
        to_find.remove(ans[n - 1])
        n -= 1
    
    if n:
        left = set(query(1, n // 2))
        right = to_find - left
        
        for i in range(2, n // 2 + 1):
            mid = set(query(i, n + 1 - i))
            ans[i - 2] = (left - mid).pop()
            ans[n - i + 1] = (right - mid).pop()
            
            left &= mid
            right &= mid
        
        ans[n // 2 - 1] = left.pop()
        ans[n // 2] = right.pop()
    
    answer(ans)
```

C++ 做法如下——

```cpp []
set<int> query(int l, int r) {
    cout << "Q " << l << ' ' << r << endl;
    set<int> st;
    for (int i = l; i <= r; i ++) {
        int x;
        cin >> x;
        st.insert(x);
    }
    return st;
}

void answer(vector<int> &ans) {
    cout << 'A';
    for (auto &x: ans) cout << ' ' << x;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> ans(n);

    set<int> to_fill;
    for (int i = 1; i <= n; i ++)
        to_fill.insert(i);
    
    if (n & 1) {
        auto res = query(n, n);
        ans[n - 1] = *res.begin();
        to_fill.erase(ans[n - 1]), n --;
    }

    if (n > 1) {
        auto left = query(1, n / 2);
        set<int> right;

        for (auto &v: to_fill)
            if (left.find(v) == left.end())
                right.insert(v);
        
        for (int i = 2; i <= n / 2; i ++) {
            auto mid = query(i, n + 1 - i);
            
            for (auto v: left) {
                if (mid.find(v) == mid.end()) {
                    left.erase(v);
                    ans[i - 2] = v;
                    break;
                }
            }

            for (auto v: right) {
                if (mid.find(v) == mid.end()) {
                    right.erase(v);
                    ans[n - i + 1] = v;
                    break;
                }
            }
        }

        ans[n / 2 - 1] = *left.begin();
        ans[n / 2] = *right.begin();
    }

    answer(ans);

    return 0;
}
```
