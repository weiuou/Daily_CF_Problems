**提示 1：** 操作的子数组需要满足什么条件。

**提示 2：** 对应子数组的数量计算如何进行？

我们数组可能不变，这种情况自动记为一个结果。

对于改变数组的情况，考虑对 $[l,r]$ 排序。

如果 $l$ 位置数值等于子数组最小值，那么对 $[l+1,r]$ 排序产生的结果是一致的。

如果 $r$ 位置数值等于子数组最小值，那么对 $[l,r-1]$ 排序产生的结果是一样的。

不断这样操作，直到 $l$ 无法继续增大 $r$ 无法继续变小。我们只对此时最后结果的 $[l',r']$ 的不同可能进行计数。

对于不同的排序结果，其唯一对应于第一个与原数组不同的位置 $l'$ 和最后一个与原数组不同的 $r'$ 。

因此，我们只需计算 $[l,r]$ 的个数，使得 $l$ 位置不是区间最小值，且 $r$ 位置不是区间最大值。

发现直接计算困难，我们可以考虑使用容斥原理。这样我们就只需计算以下三件事：

第一， $l$ 是区间最小值的区间的个数，可以直接从后往前使用单调栈，找到下一个严格更小的位置。

第二， $r$ 是区间最大值的区间的个数，可以直接从前往后使用单调栈，找到前一个更大的位置。

第三， $l$ 是最小值且 $r$ 是最大值的区间的个数。如果枚举 $l$ ，我们可以通过单调栈，找到其后更小的位置，则我们选择的 $r$ 一定比这个位置 $pos$ 更靠前。

而此时，所有可选的 $r'$ ，必须是从 $l$ 开始不断 “再创新高” 的位置，其实也就相当于从后往前的最大栈内的元素，我们只需看这个单调栈内有多少个元素比 $pos$ 小，这件事很容易通过二分得到。

综上，容斥原理计数完成。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()
    
    ans = 1 + n * (n + 1) // 2
    
    stk = [-1]
    for i in range(n):
        while stk[-1] != -1 and nums[i] >= nums[stk[-1]]:
            stk.pop()
        ans -= i - stk[-1]
        stk.append(i)
    
    stk = [n]
    for i in range(n - 1, -1, -1):
        while stk[-1] != n and nums[i] <= nums[stk[-1]]:
            stk.pop()
        ans -= stk[-1] - i
        stk.append(i)
    
    stk1 = [n]
    stk2 = [n]
    
    for i in range(n - 1, -1, -1):
        while stk1[-1] != n and nums[i] > nums[stk1[-1]]:
            stk1.pop()
        
        while stk2[-1] != n and nums[i] <= nums[stk2[-1]]:
            stk2.pop()
        
        l, r = 0, len(stk1) - 1
        while l <= r:
            mid = (l + r) // 2
            if stk1[mid] >= stk2[-1]: l = mid + 1
            else: r = mid - 1
        
        ans += len(stk1) - l + 1
        
        stk1.append(i)
        stk2.append(i)
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> nums(n);
    for (auto &x: nums) cin >> x;

    long long ans = 1ll * n * (n + 1) / 2 + 1;

    vector<int> stk = {-1};
    for (int i = 0; i < n; i ++) {
        while (stk.back() != -1 && nums[i] >= nums[stk.back()])
            stk.pop_back();
        ans -= i - stk.back();
        stk.emplace_back(i);
    }

    stk = {n};
    for (int i = n - 1; i >= 0; i --) {
        while (stk.back() != n && nums[i] <= nums[stk.back()])
            stk.pop_back();
        ans -= stk.back() - i;
        stk.emplace_back(i);
    }

    vector<int> stk1 = {n}, stk2 = {n};

    for (int i = n - 1; i >= 0; i --) {
        while (stk1.back() != n && nums[i] > nums[stk1.back()])
            stk1.pop_back();
        
        while (stk2.back() != n && nums[i] <= nums[stk2.back()])
            stk2.pop_back();
        
        int l = 0, r = stk1.size() - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (stk1[mid] >= stk2.back()) l = mid + 1;
            else r = mid - 1;
        }

        ans += stk1.size() - l + 1;
        stk1.emplace_back(i);
        stk2.emplace_back(i);
    }

    cout << ans;

    return 0;
}
```
