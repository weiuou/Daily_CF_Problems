**提示 1：** 想想拿数的条件。

假设我们取了一个子序列，则我们一定是按照顺序一个个取的，这样就可以避免我们拿完后面的东西后，前面的东西被对方拿走了。

可以发现，前 $2k-1$ 个东西里你最多拿 $k$ 个。

于是顺序遍历，考虑到第 $i$ 个位置能拿到的最大总价值。

如果到第 $i$ 个位置时，突然可以多拿一个，那就拿过来。

否则，看我们当前拿的最小价值的东西，看能否替换为新物品。相当于反悔贪心。

上述过程可以用堆维护。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()
    
    having = []
    
    for i in range(n):
        cur = i // 2 + 1
        
        if len(having) < cur:
            heappush(having, nums[i])
        elif having[0] < nums[i]:
            heapreplace(having, nums[i])
    
    v = sum(having)
    print(v, sum(nums) - v)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    priority_queue<int, vector<int>, greater<int>> pq;
    long long chosen = 0, total = 0;

    for (int i = 0; i < n; i ++) {
        int x;
        cin >> x;

        int cur = i / 2 + 1;
        if (cur > pq.size()) {
            chosen += x;
            pq.push(x);
        }
        else if (pq.top() < x) {
            chosen -= pq.top();
            pq.pop();
            chosen += x;
            pq.push(x);
        }
        total += x;
    }

    cout << chosen << ' ' << total - chosen;

    return 0;
}
```
