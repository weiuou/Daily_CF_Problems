**提示 1：** 每一次查询相当于把数字分为两类——一类在查询中，一类不在。

**提示 2：** 为了使得位置之间两两能区分，需要多少次查询？根据上面的说法可以怎么查？

每次查询有一些位置在查询内，有些数字不在查询内，因此实际上把位置分为了两类。

而如果有两个位置的分类结果始终一样，那么这两个位置的数值是可以互换的——因此这种情况绝不能发生。

我们可以直接分，即把当前同一个组别的元素均分为两组查询，类似于下面这样：

$[1,2,3,4,5,6]$ 查询 $1,2,3$

新的分组是 $[1,2,3],[4,5,6]$ 查询 $1,2,4,5$  

新的分组时 $[1,2],[3],[4,5],[6]$ 查询 $1,4$

最后达到每组只有一个元素。

也可以用二进制表示位置，每次查询某一位是 $1$ 的全部位置。任意两个不同的数至少一个二进制位不同，所以任意两个位置一定可以被区分开来。

而每个位置在不同查询里是否出现的情况，也可以用一个二进制数表示；同时，每一个在查询结果中出现的数字，也可以用二进制表示其在哪几次查询结果中。而这两个二进制数应当一一对应，于是就找到了位置和值的一一映射。

这个一一映射有了，也就可以输出答案了。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    pos = [0] * (n + 1)
    
    for i in range(10):
        tmp = []
        for j in range(1, n + 1):
            if j >> i & 1:
                tmp.append(j)
        
        if len(tmp):
            print(len(tmp), *tmp, flush=True)
            
            nums = LII()
            for v in nums:
                pos[v] |= 1 << i
    
    ans = [0] * (n + 1)
    for i in range(n + 1):
        ans[pos[i]] = i
    
    print('!', *ans[1:])
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> pos(n + 1);

    for (int i = 0; i < 10; i ++) {
        vector<int> idxs;
        for (int j = 1; j <= n; j ++) {
            if (j >> i & 1) {
                idxs.emplace_back(j);
            }
        }

        if (idxs.size()) {
            cout << idxs.size() << ' ';
            for (auto &idx: idxs) cout << idx << ' ';
            cout << endl;

            vector<int> vals;
            for (int i = 0; i < idxs.size(); i ++) {
                int x;
                cin >> x;
                vals.emplace_back(x);
            }

            for (auto &v: vals) pos[v] |= 1 << i;
        }
    }

    vector<int> ans(n + 1);
    for (int i = 1; i <= n; i ++)
        ans[pos[i]] = i;

    cout << "! ";
    for (int i = 1; i <= n; i ++)
        cout << ans[i] << ' ';

    return 0;
}
```