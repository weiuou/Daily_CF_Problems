**提示 1：** 一步步考虑问题——先放第一个人，再考虑剩下的人选什么位置，最后考虑剩下人的顺序。

第一个人有 $m$ 个位置可选。

而接下来相当于要分配空位。总共 $n$ 个人，会有 $n$ 组空位，而空位的数量为 $m-n$ ，所以设每一组空位长度为 $x_1,\dots,x_n$ ，则

$x_1+x_2+\dots+x_n=m-n$

于是 $1\leq x_1\lt x_1+x_2\lt\dots\lt x_1+x_2+\dots+x_{n-1}\lt m-n$

于是只需在 $1,2,\dots, m-n-1$ 中选取 $n-1$ 个数，作为 $x_1,x_1+x_2,\dots,x_1+x_2+\dots+x_{n-1}$ 的数值就行，共有 $C_{m-n-1}^{n-1}$ 组。

而后面 $n-1$ 个人可以任选顺序，因此这里方案数是 $(n-1)!$ 。

综上，答案是 $mC_{m-n-1}^{n-1}\times (n-1)!$ 。

注意 $m=n=1$ 时是有方案的，这里漏了的可以想想前面是哪里推导跳过了这个。（其实在于前面有空格这件事的默认）

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    mod = 10 ** 9 + 7
    f = Factorial(10 ** 5, mod)
    
    t = II()
    outs = []
    
    for _ in range(t):
        n, m = MII()
        
        if n == m == 1:
            outs.append(1)
        elif 2 * n <= m:
            ans = m
            # x1 + x2 + ... + xn = n - m
            ans = ans * f.combi(m - n - 1, n - 1) % mod
            ans = ans * f.fac(n - 1) % mod
            outs.append(ans)
        else:
            outs.append(0)
    
    print(*outs, sep='\n')
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int mod = 1e9 + 7, N = 1e5 + 5;
    
    vector<int> f(N, 1), g(N);

    for (int i = 1; i < N; i ++)
        f[i] = 1ll * i * f[i - 1] % mod;
    
    g[N - 1] = quickPow(f[N - 1], mod - 2, mod);
    for (int i = N - 1; i > 0; i --)
        g[i - 1] = 1ll * i * g[i] % mod;
    
    int t;
    cin >> t;

    auto comb = [&] (int x, int y) -> int {
        return 1ll * f[x] * g[y] % mod * g[x - y] % mod;
    };

    while (t --) {
        int n, m;
        cin >> n >> m;

        if (n == 1 && m == 1) cout << 1 << '\n';
        else if (2 * n > m) cout << 0 << '\n';
        else cout << 1ll * m * comb(m - n - 1, n - 1) % mod * f[n - 1] % mod << '\n';
    }

    return 0;
}
```