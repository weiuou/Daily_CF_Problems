**提示 1：** 我们每次做的是区间加一个数的操作。加的数有何特点。

每个灯的影响可以拆分为左右两个部分。

加和减的两种操作是类似的，相当于 $x$ 和 $-x$ ，我们下面以加为例。

假设对 $idx$ 位置进行加 $x$ 的操作，那么对于左侧的 $i$ 位置，需要加 $x\times (1-p)^{idx-i}$ ，对于右侧的 $i$ 位置，需要加 $x\times (1-p)^{i-idx}$ 。

区间加等比数列并没有很好的处理方式。但这里的特殊性是幂次的底数一直是 $1-p$ 。

所以，考虑 $x\times (1-p)^{idx-i}=x(1-p)^{idx}\times (1-p)^{-i}$ 。前半部分是更新的位置，后半部分是查询的位置。所以我们可以更新的时候更新前半部分，查询的时候乘以后半部分。

上面的描述是不够精确的。我们可以用数据结构维护每个 $idx$ 上的 $x(1-p)^{idx}$ 的和。而当我们查询 $i$ 位置时，相当于要找它后面的 $idx$ 的 $x(1-p)^{idx}$ 的和，再乘以它自己的 $(1-p)^{-i}$ 。所以我们相当于是单点加，区间求和，所以可以用树状数组直接维护。

对于 $idx$ 后面的位置也可以用上面的方式进行分拆，只要 $x,idx$ 是在一个式子里的，因为这都是查询的参数。

时间复杂度为 $\mathcal{O}(n+q\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    mod = 10 ** 9 + 7
    
    n, q, p = LI()
    n = int(n)
    q = int(q)
    p = (1 - round(float(p) * 1000000) * pow(1000000, mod - 2, mod)) % mod
    
    pows = [1] * (n + 2)
    for i in range(1, n + 2):
        pows[i] = pows[i - 1] * p % mod
    
    revp = pow(p, mod - 2, mod)
    
    rev_pows = [1] * (n + 2)
    for i in range(1, n + 2):
        rev_pows[i] = rev_pows[i - 1] * revp % mod
    
    fen_pre = FenwickTree(n + 1)
    fen_suf = FenwickTree(n + 1)
    
    outs = []
    for _ in range(q):
        query = LI()
        
        if query[0] == '+':
            x = int(query[1])
            idx = int(query[2]) - 1
    
            fen_pre.add(idx, x * pows[idx] % mod)
            fen_suf.add(idx + 1, x * rev_pows[idx] % mod)
            
        elif query[0] == '-':
            x = int(query[1])
            idx = int(query[2]) - 1
            
            fen_pre.add(idx, -x * pows[idx] % mod)
            fen_suf.add(idx + 1, -x * rev_pows[idx] % mod)
        
        else:
            idx = int(query[1]) - 1
            
            ans = 0
            ans += fen_pre.rsum(idx, n) % mod * rev_pows[idx] % mod
            ans += fen_suf.rsum(0, idx) % mod * pows[idx] % mod
            
            outs.append(ans % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int mod = 1e9 + 7;

    int n, q;
    long double prob;
    cin >> n >> q >> prob;

    prob = (1 - prob) * 1000000;
    int p = prob + 0.3;

    p = 1ll * p * quickPow(1000000, mod - 2, mod) % mod;
    int revp = quickPow(p, mod - 2, mod);

    vector<int> pows(n + 2, 1), rev_pows(n + 2, 1);

    for (int i = 1; i < n + 2; i ++) {
        pows[i] = 1ll * pows[i - 1] * p % mod;
        rev_pows[i] = 1ll * rev_pows[i - 1] * revp % mod;
    }

    atcoder::fenwick_tree<long long> fen_pre(n + 1), fen_suf(n + 1);

    while (q --) {
        char op;
        cin >> op;

        if (op == '+') {
            int x, idx;
            cin >> x >> idx;
            idx --;
            fen_pre.add(idx, 1ll * x * pows[idx] % mod);
            fen_suf.add(idx + 1, 1ll * x * rev_pows[idx] % mod);
        }
        else if (op == '-') {
            int x, idx;
            cin >> x >> idx;
            idx --;
            fen_pre.add(idx, -(1ll * x * pows[idx] % mod));
            fen_suf.add(idx + 1, -(1ll * x * rev_pows[idx] % mod));
        }
        else {
            int idx;
            cin >> idx;
            idx --;

            int ans = 0;
            ans += fen_pre.sum(idx, n + 1) % mod * rev_pows[idx] % mod;
            ans += fen_suf.sum(0, idx + 1) % mod * pows[idx] % mod;
            cout << ans % mod << '\n';
        }
    }

    return 0;
}
```
