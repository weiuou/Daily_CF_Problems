**提示 1：** 很明显是个 DP 题。如何从小规模问题的解推出大规模的呢？

先识别出这是个 DP 计数问题。

设计状态——一个状态肯定是当前选了几个方块，而最后一个格子的颜色也是重要的，因为这关系到同个颜色会不会连续出现。

考虑如何计算用了 $i+1$ 个方块，且最后一个方块是红色的方块的方案数。

首先，对使用了 $i$ 个方块的方案数相加，相当于在这些方案最后加入了红色方块。

而这样多算了什么呢？多算了最后恰好出现 $kr+1$ 个红色方块的那些方案。

而在这一段红色方块前，一定是蓝色 / 绿色的方块。所以我们要减去 $i-kr$ 个方块且最后是蓝色 / 绿色的方块的方案数。

如果 $i+1$ 刚好等于 $kr+1$ ，要减去的方案数是 $1$ ，因为相当于减去了长度为 $0$ 的方案数。

其他两种颜色的分析是类似的。时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, kr, kg, kb = MII()
    
    dpr = [0] * (n + 1)
    dpg = [0] * (n + 1)
    dpb = [0] * (n + 1)
    
    dpr[1] = 1
    dpg[1] = 1
    dpb[1] = 1
    
    mod = 10 ** 9 + 7
    
    for i in range(2, n + 1):
        total = dpr[i - 1] + dpg[i - 1] + dpb[i - 1]
        
        dpr[i] = total
        if i > kr + 1: dpr[i] -= dpg[i - kr - 1] + dpb[i - kr - 1]
        elif i == kr + 1: dpr[i] -= 1
        
        dpg[i] = total
        if i > kg + 1: dpg[i] -= dpr[i - kg - 1] + dpb[i - kg - 1]
        elif i == kg + 1: dpg[i] -= 1
        
        dpb[i] = total
        if i > kb + 1: dpb[i] -= dpr[i - kb - 1] + dpg[i - kb - 1]
        elif i == kb + 1: dpb[i] -= 1
        
        dpr[i] %= mod
        dpg[i] %= mod
        dpb[i] %= mod
        
    
    print((dpr[n] + dpg[n] + dpb[n]) % mod)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int mod = 1e9 + 7;

    auto add = [&] (int &x, int y) -> void {
        x += y;
        if (x >= mod) x -= mod;
    };

    auto minus = [&] (int &x, int y) -> void {
        x -= y;
        if (x < 0) x += mod;
    };

    int n, kr, kg, kb;
    cin >> n >> kr >> kg >> kb;

    vector<int> dpr(n + 1, 0), dpg(n + 1, 0), dpb(n + 1, 0);

    dpr[1] = 1, dpg[1] = 1, dpb[1] = 1;

    for (int i = 2; i <= n; i ++) {
        int total = 0;
        add(total, dpr[i - 1]);
        add(total, dpg[i - 1]);
        add(total, dpb[i - 1]);

        dpr[i] = total;
        if (i > kr + 1) {
            minus(dpr[i], dpg[i - kr - 1]);
            minus(dpr[i], dpb[i - kr - 1]);
        }
        else if (i == kr + 1) minus(dpr[i], 1);

        dpg[i] = total;
        if (i > kg + 1) {
            minus(dpg[i], dpr[i - kg - 1]);
            minus(dpg[i], dpb[i - kg - 1]);
        }
        else if (i == kg + 1) minus(dpg[i], 1);

        dpb[i] = total;
        if (i > kb + 1) {
            minus(dpb[i], dpr[i - kb - 1]);
            minus(dpb[i], dpg[i - kb - 1]);
        }
        else if (i == kb + 1) minus(dpb[i], 1);
    }

    int ans = 0;
    add(ans, dpr[n]);
    add(ans, dpg[n]);
    add(ans, dpb[n]);

    cout << ans;

    return 0;
}
```
