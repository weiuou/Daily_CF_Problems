**提示 1：** 其实相当于加了一堆边，再跑最短路。

对于一组条件 $x,d,t,p$ ，相当于从 $x-p$ 向 $x+d$ 连边，用时（即边权）为 $p+t$ 。

其余的就是正常的在线段上走。所有在上述结点之外的地方都不可能转向。

所以存下所有的结点，所有相邻结点之间双向连边，边权等于两个点的距离就行，这样，任何两个点之间的行走都可以用这组边表示。

最后跑最短路，只需要记录下用的是哪条边就行。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, l = MII()
    rnd = random.getrandbits(30)

    us = []
    vs = []
    ws = []
    ids = []

    for i in range(1, n + 1):
        x, d, t, p = MII()
        if x >= p:
            x += rnd
            us.append(x - p)
            vs.append(x + d)
            ws.append(p + t)
            ids.append(i)

    positions = [rnd, rnd + l]
    positions.extend(us)
    positions.extend(vs)

    positions = sorted(set(positions))

    N = len(positions)
    path = [[] for _ in range(N)]

    def f(d, v):
        return d * N + v

    INF = 10 ** 9 + 5

    def e(idx, d, v):
        return (idx * INF + d) * N + v

    for i in range(1, N):
        d = positions[i] - positions[i - 1]
        path[i].append(e(0, d, i - 1))
        path[i - 1].append(e(0, d, i))

    M = len(us)

    for i in range(M):
        u = us[i]
        v = vs[i]
        w = ws[i]
        
        u_id = bisect.bisect_left(positions, u)
        v_id = bisect.bisect_left(positions, v)
        path[u_id].append(e(ids[i], w, v_id))

    inf = 10 ** 9 * 2

    dis = [inf] * N
    pre = [-1] * N

    pq = [f(0, 0)]
    dis[0] = 0

    while pq:
        d, u = divmod(heappop(pq), N)
        
        if dis[u] == d:
            for msk in path[u]:
                msk, v = divmod(msk, N)
                i, nd = divmod(msk, INF)
                
                if d + nd < dis[v]:
                    dis[v] = d + nd
                    pre[v] = f(i, u)
                    heappush(pq, f(dis[v], v))

    for i in range(N):
        if positions[i] == rnd + l:
            print(dis[i])
            
            ans = []
            cur = i
            while cur:
                msk = pre[cur]
                idx, cur = divmod(msk, N)
                if idx > 0: ans.append(idx)
            
            ans.reverse()
            print(len(ans))
            if len(ans): print(' '.join(map(str, ans)))
            break
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, l;
    cin >> n >> l;

    vector<int> pos = {0, l};
    vector<array<int, 3>> edges(n);

    for (int i = 0; i < n; i ++) {
        int x, d, t, p;
        cin >> x >> d >> t >> p;
        edges[i] = {x - p, x + d, p + t};
        if (x >= p) pos.emplace_back(x - p), pos.emplace_back(x + d);
    }

    sort(pos.begin(), pos.end());

    int N = unique(pos.begin(), pos.end()) - pos.begin();

    vector<vector<array<int, 3>>> path(N);
    for (int i = 1; i < N; i ++) {
        int d = pos[i] - pos[i - 1];
        path[i].push_back({0, i - 1, d});
        path[i - 1].push_back({0, i, d});
    }

    for (int i = 0; i < n; i ++) {
        auto [u, v, d] = edges[i];
        if (u < 0) continue;
        int pu = lower_bound(pos.begin(), pos.begin() + N - 1, u) - pos.begin();
        int pv = lower_bound(pos.begin(), pos.begin() + N - 1, v) - pos.begin();
        path[pu].push_back({i + 1, pv, d});
    }

    int inf = 2e9;

    vector<int> dis(N, inf);
    vector<pair<int, int>> pre(N);

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    dis[0] = 0;
    pq.push({0, 0});

    while (pq.size()) {
        auto [d, u] = pq.top();
        pq.pop();

        if (dis[u] == d) {
            for (auto &[eid, v, nd]: path[u]) {
                if (dis[v] > d + nd) {
                    dis[v] = d + nd;
                    pre[v] = {eid, u};
                    pq.push({dis[v], v});
                }
            }
        }
    }

    for (int i = 0; i < N; i ++) {
        if (pos[i] - pos[0] == l) {
            cout << dis[i] << '\n';

            int cur = i;
            vector<int> ans;

            while (cur) {
                auto [eid, ncur] = pre[cur];
                cur = ncur;
                if (eid) ans.emplace_back(eid);
            }
            
            reverse(ans.begin(), ans.end());
            cout << ans.size() << '\n';
            for (auto &v: ans) cout << v << ' ';

            break;
        }
    }

    return 0;
}
```