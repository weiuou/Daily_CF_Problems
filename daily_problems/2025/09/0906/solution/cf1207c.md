**提示 1：** 假设我们已经知道了前 $i$ 个位置的成本，那么到第 $i+1$ 个位置的成本怎么算？

先看提示。

第 $i$ 个位置的成本如果要推导到第 $i+1$ 个位置的成本，哪些信息是重要的？

发现第 $i$ 个位置的当前高度是重要的，因为需要跟第 $i+1$ 个位置的高度比较，如果两者不同，那么需要新增一单位的管道长度。于是将其加入 DP 的状态转移中。

考虑到第 $i$ 个位置为止，且当前高度为 $1/2$ 的最小成本为 $dp[i][1/2]$ ，只需枚举新的位置的高度，进行状态转移即可。 立柱的高度等于新位置的高度，管道长度等于横着的（固定为 $1$ ）加上竖着的（如果高度变化则需要 $1$ 的竖管）。

注意第一个位置和最后一个位置只能是 $1$ 。时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    inf = 10 ** 16
    
    for _ in range(t):
        n, a, b = MII()
        nums = [int(c) for c in I()]
        
        dp0, dp1 = b, inf
        
        for x in nums:
            if x:
                dp0, dp1 = inf, dp1 + a + 2 * b
            else:
                dp0, dp1 = fmin(dp0 + a + b, dp1 + 2 * a + b), fmin(dp1 + a + 2 * b, dp0 + 2 * a + 2 * b)
        
        outs.append(dp0)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    long long inf = 1e16;

    int t;
    cin >> t;

    while (t --) {
        int n, a, b;
        string s;

        cin >> n >> a >> b >> s;

        long long dp0 = b, dp1 = inf;
        for (auto &c: s) {
            if (c == '1')
                dp0 = inf, dp1 = dp1 + a + 2 * b;
            else {
                long long ndp0 = min(dp0 + a + b, dp1 + 2 * a + b);
                long long ndp1 = min(dp1 + a + 2 * b, dp0 + 2 * a + 2 * b);
                dp0 = ndp0, dp1 = ndp1;
            }
        }

        cout << dp0 << '\n';
    }

    return 0;
}
```