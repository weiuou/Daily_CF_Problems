**提示 1：** 从每个点都能走到最高点。为什么？

**提示 2：** 把题目缩小为更小范围的问题。

首先，我们从任何一个位置出发，我们每次选择其相邻的格子中比它大的格子，一步步走，直到找不到，我们就走到了一个极值点（一定会停下来，因为数值是严格递增的，每个格子最多走一遍），也就找到了答案。

但这样步数会超。怎么办呢？

我们考虑通过若干次查询把问题规模进一步缩小。

缩小的问题一定是一个子矩阵。所以考虑切割当前的矩阵。那我们肯定得查询一下中间的那条线。

于是我们找到一条切割矩阵的线。

这条线上，唯一重要的位置是最大值的位置，其他位置按照前面的逻辑走都可以走到这个最大值。下一步往哪走呢？

我们只需查询这个最大值相邻的位置，看是否大于这个位置的数值。如果有一侧更大，那么答案一定在这一侧。如果都不更大，那么这个位置就是答案了。

有没有可能两侧数字都更大呢？答案是否定的。考虑最大值位置往两边走的两条路径（第一段提到的），它们一定都到达最终的最大值点。而这两条路径一定会跨过中间的分割线。因此，从最大值出发，一定会通过向左 / 向右的一条路径再次到达分割线。因为路径上元素递增，所以到达的位置数值一定比出发点更大，但这和我们取的是分割线上最大值矛盾了。

所以我们可以通过一条分割线的查询，判断最大值点在左右的哪一个子矩形中。

此时把问题转化为规模更小的问题了吗？是也不是。

一方面，我们确实把问题变成了更小的矩形。

但另一方面，这个更小的矩形的极大值点唯一吗？似乎并不确定。怎么办呢？

我们不妨在整个矩形外侧添加一圈 $0$ ，这样我们的问题相当于在查询区域外侧的一圈都不是极值点的情况下，往内侧找最大值。

而考虑锁定的区域外圈的最大值点的路径，一定往里走，也就是最大值位置一定在内侧，在这种情况下，内侧不能有两个极大值点，因为这样就会产生矛盾了。这样我们就保证了问题一定转化为了规模更小的问题。

同时我们要保证我们子矩形的边缘一定有查询过的最大值，所以单独考虑中间的分割线就不够了，你还需要考虑原有的边缘，因为只有从边缘的最大值走，才能保证至多只有一个方向是下一步要走的。

我们只需不断挑选剩余矩形的更短的分割线进行问题规模的缩小就行，时间复杂度为 $n+(n/2+n/2)+(n/4+n/4)+\dots=3n$ 量级。

下面的代码是直接横着的中间线和竖着的中间线，把问题规模缩小为四个角中其中一个角。查询次数也可以接受。

整体而言，上面的逻辑类似于二分。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    cur_max = 0
    saved = {}
    
    def query(x, y):
        if x == 0 or x == n + 1: return 0
        if y == 0 or y == n + 1: return 0
        
        nonlocal cur_max
        
        if (x, y) in saved:
            return saved[(x, y)]
        
        print('?', x, y, flush=True)
        res = II()
        cur_max = fmax(cur_max, res)
        saved[(x, y)] = res
        
        return res
    
    def solve(xl, xr, yl, yr):
        xm = (xl + xr) // 2
        ym = (yl + yr) // 2
        
        val = 0
        vx, vy = -1, -1
        
        for x in range(xl, xr + 1):
            nval = query(x, ym)
            if nval > val:
                val = nval
                vx, vy = x, ym
            
            nval = query(x, yl - 1)
            if nval > val:
                val = nval
                vx, vy = x, yl - 1
            
            nval = query(x, yr + 1)
            if nval > val:
                val = nval
                vx, vy = x, yr + 1
        
        for y in range(yl, yr + 1):
            nval = query(xm, y)
            if nval > val:
                val = nval
                vx, vy = xm, y
            
            nval = query(xl - 1, y)
            if nval > val:
                val = nval
                vx, vy = xl - 1, y
            
            nval = query(xr + 1, y)
            if nval > val:
                val = nval
                vx, vy = xr + 1, y
        
        for dx, dy in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
            nx, ny = vx + dx, vy + dy
            if xl <= nx <= xr and yl <= ny <= yr and query(nx, ny) > val:
                if nx > xm:
                    if ny > ym: solve(xm + 1, xr, ym + 1, yr)
                    else: solve(xm + 1, xr, yl, ym - 1)
                else:
                    if ny > ym: solve(xl, xm - 1, ym + 1, yr)
                    else: solve(xl, xm - 1, yl, ym - 1)
    
    solve(1, n, 1, n)
    print('!', cur_max)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    int cur_max = 0;
    map<pair<int, int>, int> saved;

    auto query = [&] (int x, int y) -> int {
        if (x == 0 || x == n + 1) return 0;
        if (y == 0 || y == n + 1) return 0;

        if (saved.find({x, y}) != saved.end()) return saved[{x, y}];

        cout << "? " << x << ' ' << y << endl;
        int res;
        cin >> res;
        cur_max = max(cur_max, res);
        saved[{x, y}] = res;
        return res;
    };

    auto solve = [&] (auto &self, int xl, int xr, int yl, int yr) -> void {

        int xm = (xl + xr) / 2;
        int ym = (yl + yr) / 2;

        int val = 0, vx, vy;

        for (int x = xl; x <= xr; x ++) {
            int nval;
            nval = query(x, ym);
            if (nval > val) {
                val = nval;
                vx = x;
                vy = ym;
            }
            nval = query(x, yl - 1);
            if (nval > val) {
                val = nval;
                vx = x;
                vy = yl - 1;
            }
            nval = query(x, yr + 1);
            if (nval > val) {
                val = nval;
                vx = x;
                vy = yr + 1;
            }
        }

        for (int y = yl; y <= yr; y ++) {
            int nval;
            nval = query(xm, y);
            if (nval > val) {
                val = nval;
                vx = xm;
                vy = y;
            }
            nval = query(xl - 1, y);
            if (nval > val) {
                val = nval;
                vx = xl - 1;
                vy = y;
            }
            nval = query(xr + 1, y);
            if (nval > val) {
                val = nval;
                vx = xr + 1;
                vy = y;
            }
        }

        vector<pair<int, int>> dirs = {
            {-1, 0},
            {0, 1},
            {1, 0},
            {0, -1}
        };
        for (auto &[dx, dy]: dirs) {
            int nx = vx + dx, ny = vy + dy;
            if (nx >= xl && nx <= xr && ny >= yl && ny <= yr && query(nx, ny) > val) {
                if (nx > xm) {
                    if (ny > ym) self(self, xm + 1, xr, ym + 1, yr);
                    else self(self, xm + 1, xr, yl, ym - 1);
                }
                else {
                    if (ny > ym) self(self, xl, xm - 1, ym + 1, yr);
                    else self(self, xl, xm - 1, yl, ym - 1);
                }
            }
        }
    };

    solve(solve, 1, n, 1, n);
    cout << "! " << cur_max;

    return 0;
}
```
