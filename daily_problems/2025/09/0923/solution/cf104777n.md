**提示 1：** 我们可以根据题目推出 $a_1\mathrm{xor}a_i$ 的数值，我们只需求出一个符合要求的 $a_1$ 就行了。

**提示 2：** 找一个合适的检查指标。

首先，我们一旦第一个元素确定了，后面每个元素也都确定了，因为可以一个一个往后推。而后面的每个元素其实就是第一个元素异或上一个数。

我们最后要让数组变成 $0\sim n-1$ 的排列。

接下来需要一点注意力：我们无论 $a_1$ 取什么值，产生的 $n$ 个数都是不同的，所以只要最大的异或结果是 $n-1$ ，产生的数组就一定是个排列了，因为非负数只能这么取。

所以我们只需枚举 $a_1$ ，看最大的异或结果是否是 $n-1$ 就行。这件事可以通过 01-Trie （字典树）快速实现。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()
    
    trie = Trie01(n, n + 2)
    
    for i in range(1, n - 1):
        nums[i] ^= nums[i - 1]
    
    trie.insert(0)
    for x in nums:
        trie.insert(x)
    
    for i in range(n):
        if trie.findMaxXor(i) == n - 1:
            ans = [i] + [i ^ x for x in nums]
            print(' '.join(map(str, ans)))
            break
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> nums(n - 1);
    for (auto &v: nums) cin >> v;

    for (int i = 1; i < n - 1; i ++)
        nums[i] ^= nums[i - 1];

    Trie<int> trie(2 * n, n);
    trie.insert(0);
    for (auto &v: nums) trie.insert(v);

    for (int i = 0; i < n; i ++) {
        if (trie.findMaxXor(i) == n - 1) {
            cout << i;
            for (auto &x: nums) cout << ' ' << (i ^ x);
            break;
        }
    }

    return 0;
}
```
