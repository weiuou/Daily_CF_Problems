**提示 1：** 如果一个人拿了第 $u$ 张红牌和第 $v$ 张蓝牌，则 $u,v$ 连边。题目中的关系用图论表示是什么？

**提示 2：** 每个连通块有解的条件是什么？

考虑如果一个人拿了第 $u$ 张红牌和第 $v$ 张蓝牌，则 $u,v$ 连边。那么总共有 $n$ 条边，且每个点度数为 $2$ ，所以由一系列环组成。

每个环的每条边给了个条件，表示这条边对应的两个端点的数值之和如何。

首先，每个环内，所有边的数值之和得是偶数，因为所有边的数值之和相当于把每个点的权重都算了两次再加到一起。

而把每个环的结果加起来也是偶数，所以数组和是偶数的情况下，直接输出无法构造。

如果环的长度是偶数，那么将其边黑白间隔染色，同色边的数值和等于整个环上数值和，所以是相等的。

如果环的长度是奇数，那么我们可以列方程求解每个点的数值（可以使用消元法，最后得到 $x=v-x$ 形式的方程）。

所以综上，要么形成长度是奇数且和为偶数的环，要么形成长度是偶数的环且环上的边可以黑白染色后同色边权值和相等。

奇数边的总个数是偶数。

如果有一条偶数边，则加入进来后，就形成了长度是奇数且和为偶数的环，这个环是可构造的；对于剩余的偶数边，直接连成自环就完成构造了。

如果没有偶数边，那么假设形成了若干个环，每个环都是偶数条边（否则环内边权和是奇数），所以每个环都可以拆成黑白染色的同色边权和相等的边集。再把所有黑边 / 白边放到一起，这样就可以形成一个大环了。

因此只需判断能否用这些长度为奇数的边凑成一个大环就行，也就是是否存在一半的元素，和也为整体数值和的一半。这件事显然背包就解决了。这一部分的具体构造直接令第一项为 $0$ 就一定合法了。

时间复杂度为 $\mathcal{O}(n^3M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    outs = []
    t = 0
    
    while True:
        t += 1
        n = II()
        if n == 0:
            break
    
        nums = LII()
        
        if sum(nums) % 2: outs.append('No')
        else:
            ans = [0] * n
            
            idxs = []
            even_idx = -1
            
            for i in range(n):
                if nums[i] % 2:
                    idxs.append(i)
                elif even_idx == -1:
                    even_idx = i
                else:
                    ans[i] = nums[i] // 2
            
            if even_idx >= 0:
                outs.append('Yes')
                idxs.append(even_idx)
                
                cur = 0
                for i in idxs:
                    cur = nums[i] - cur
                
                cur //= 2
                for i in idxs:
                    ans[i] = cur
                    cur = nums[i] - cur
                
                outs.append(' '.join(map(str, ans)))
                outs.append(' '.join(map(str, (nums[i] - ans[i] for i in range(n)))))
            
            else:
                k = len(idxs)
                M = 300 * k // 2
                dp = [[-2] * (M + 1) for _ in range(k // 2 + 1)]
                dp[0][0] = -1
                
                for i in idxs:
                    for j in range(k // 2 - 1, -1, -1):
                        for v in range(M, -1, -1):
                            if dp[j][v] != -2 and v + 150 + nums[i] <= M and dp[j + 1][v + 150 + nums[i]] == -2:
                                dp[j + 1][v + 150 + nums[i]] = i
                
                total = sum(nums[idx] + 150 for idx in idxs) // 2
                if dp[k // 2][total] == -2:
                    outs.append('No')
                else:
                    outs.append('Yes')
                    vis = [0] * k
                    
                    i1 = []
                    i2 = []
                    cur = total
                    
                    for i in range(k // 2, 0, -1):
                        i1.append(dp[i][cur])
                        vis[dp[i][cur]] = 1
                        cur -= 150 + nums[dp[i][cur]]
                    
                    for i in range(k):
                        if not vis[i]:
                            i2.append(i)
    
                    cur = 0
                    for i in range(k // 2):
                        v1 = i1[i]
                        cur = nums[v1] - cur
                        ans[v1] = cur
                        v2 = i2[i]
                        cur = nums[v2] - cur
                        ans[v2] = cur
                    
                    outs.append(' '.join(map(str, ans)))
                    outs.append(' '.join(map(str, (nums[i] - ans[i] for i in range(n)))))
    
    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    while (true) {
        int n;
        cin >> n;
        if (!n) break;

        vector<int> nums(n);
        int total = 0;
        for (auto &v: nums)
            cin >> v, total += v;

        if (total & 1) cout << "No\n";
        else {
            vector<int> ans(n);

            vector<int> idxs;
            int even_idx = -1;

            for (int i = 0; i < n; i ++) {
                if (nums[i] & 1) idxs.emplace_back(i);
                else if (even_idx == -1) even_idx = i;
                else ans[i] = nums[i] / 2;
            }

            if (even_idx >= 0) {
                cout << "Yes\n";
                idxs.emplace_back(even_idx);

                int cur = 0;
                for (auto &i: idxs) cur = nums[i] - cur;

                cur /= 2;
                for (auto &i: idxs) {
                    ans[i] = cur;
                    cur = nums[i] - cur;
                }

                for (int i = 0; i < n; i ++)
                    cout << ans[i] << ' ';
                cout << '\n';
                for (int i = 0; i < n; i ++)
                    cout << nums[i] - ans[i] << ' ';
                cout << '\n';
            }
            else {
                int k = idxs.size(), M = 300 * k / 2;

                vector<vector<int>> dp(k / 2 + 1, vector<int>(M + 1, -2));
                dp[0][0] = -1;

                for (auto &i: idxs) {
                    for (int j = k / 2 - 1; j >= 0; j --) {
                        for (int v = M; v >= 0; v --) {
                            if (dp[j][v] != -2 && v + 150 + nums[i] <= M && dp[j + 1][v + 150 + nums[i]] == -2) {
                                dp[j + 1][v + 150 + nums[i]] = i;
                            }
                        }
                    }
                }

                total = 0;
                for (auto &idx: idxs)
                    total += 150 + nums[idx];
                total /= 2;

                if (dp[k / 2][total] == -2) cout << "No\n";
                else {
                    cout << "Yes\n";
                    vector<int> vis(k, 0), i1, i2;

                    int cur = total;
                    for (int i = k / 2; i > 0; i --) {
                        i1.emplace_back(dp[i][cur]);
                        vis[dp[i][cur]] = 1;
                        cur -= 150 + nums[dp[i][cur]];
                    }

                    for (int i = 0; i < k; i ++) {
                        if (!vis[i]) {
                            i2.emplace_back(i);
                        }
                    }

                    cur = 0;
                    for (int i = 0; i < k / 2; i ++) {
                        int v1 = i1[i];
                        cur = nums[v1] - cur;
                        ans[v1] = cur;
                        int v2 = i2[i];
                        cur = nums[v2] - cur;
                        ans[v2] = cur;
                    }
                    
                    for (int i = 0; i < n; i ++)
                        cout << ans[i] << ' ';
                    cout << '\n';
                    for (int i = 0; i < n; i ++)
                        cout << nums[i] - ans[i] << ' ';
                    cout << '\n';
                }
            }
        }
    }

    return 0;
}
```
