**提示 1：** 每棵子树有两种不同的状态。

**提示 2：** 状态转移——根节点的作用？

每棵子树不可能有两个元素不确定数值，不然的话只需要保持其和为某个目标值，总是符合查询要求的。

所以每棵子树，要么只有一个点不知道数值，要么都知道数值。分别记录方案数量为 $dp_0[i],dp_1[i]$ 。

则如果是叶子节点，两个值显然都是 $1$ 。

对于其他结点，我们先看子树而言，有几个结点是未知的。

考虑枚举到第 $c$ 棵子树 $v$ 时，假设未知数量为 $0/1$ 的方案数分别是 $v_0,v_1$ ，则 $v_0$ 应当更新为 $v_0\times dp_0[v]$ ， $v_1$ 应当更新为 $v_0\times dp_1[v]+v_1\times dp_0[v]$ 。

而最后，我们可以通过查询根节点，让那个未知的位置变成已知，所以：

$dp_0[i]=v_0, dp_1[i]=v_0+v_1$

注意如果你用了需要乘法逆元的解法的话可能会出问题，因为可能遇到 $0$ ，可以利用前后缀分解的方式来算除当前位置的乘积。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    mod = 10 ** 9 + 7
    
    parent = [-1] + LGMI()
    
    path = [[] for _ in range(n)]
    for i in range(1, n):
        path[parent[i]].append(i)
    
    que = [0]
    for i in que:
        for j in path[i]:
            que.append(j)
    
    que.reverse()
    
    dp0 = [1] * n
    dp1 = [1] * n
    
    for i in que:
        if len(path[i]) == 0:
            continue
        
        v0, v1 = 0, 1
        
        for j in path[i]:
            v0 = (v1 * dp0[j] + v0 * dp1[j]) % mod
            v1 = v1 * dp1[j] % mod
        
        dp0[i] = v0
        dp1[i] = (v0 + v1) % mod
        
    print(dp1[0])
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<vector<int>> path(n + 1);

    for (int i = 2; i <= n; i ++) {
        int p;
        cin >> p;
        path[p].emplace_back(i);
    }

    int mod = 1e9 + 7;

    auto dfs = [&] (auto &self, int u) -> pair<int, int> {
        if (path[u].size() == 0) return {1, 1};
        
        int v0 = 0, v1 = 1;

        for (auto &v: path[u]) {
            auto [x0, x1] = self(self, v);
            v0 = (1ll * v1 * x0 + 1ll * v0 * x1) % mod;
            v1 = 1ll * v1 * x1 % mod;
        }

        return {v0, (v0 + v1) % mod};
    };

    cout << dfs(dfs, 1).second;

    return 0;
}
```