**提示 1：** 如果把每个人的组别认为是一个变量的话，我们每个人的条件相当于一个方程。

假设每个人的分组有两种可能，一种是 $0$ 一种是 $1$ 。设每个人的状态是 $x_i$ 。

考虑一个人，要求他附近有奇数个人跟他同个类别。这个怎么用 $x_i$ 有关的方程表达呢？

我们就要保证，无论这个人是 $0$ 类还是 $1$ 类，我们列的方程总是成立的。设其朋友为 $t_1,t_2,\dots,t_k$ 。

如果这个人有偶数个朋友：

- 则要求有奇数个跟他同类，奇数个跟他不同类。

- 无论如何，其朋友都有奇数个是 $1$ 类。

- 所以 $x_{t_1}+x_{t_2}+\dots+x_{t_k}$ 是奇数。

如果这个人有奇数个朋友：

- 则要求奇数个跟他同类，偶数个跟他不同类。

- 此时如果算上他自己，则两类都是偶数个。

- 所以 $x_i+x_{t_1}+x_{t_2}+\dots+x_{t_k}$ 是偶数。

所以我们得到了 $n$ 组关于 $x_i$ 的 $\bmod 2$ 的方程组，进行高斯消元，看有没有解即可。有没有解等价于是不是解出来个 $0=1$ 。

当然 $\bmod 2$ 的方程组也有特殊性，其消元过程等价于求异或，所以可以使用大整数 / bitset 模拟，就可以进一步优化。整体的过程与异或基一致，只许看最后是否生成了 $0=1$ 的等价形式即可判断。

时间复杂度为 $\mathcal{O}(n^3/\omega)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    XorBase.n = n + 1
    base = XorBase()
    
    neighbor = [0] * n
    cnt = [0] * n
    
    for _ in range(m):
        u, v = GMI()
        neighbor[u] |= 1 << v + 1
        neighbor[v] |= 1 << u + 1
        cnt[u] ^= 1
        cnt[v] ^= 1
    
    for i in range(n):
        if cnt[i]: neighbor[i] |= 1 << i + 1
        else: neighbor[i] |= 1
    
    for x in neighbor:
        base.add(x)
    
    print('N' if base.check(1) else 'Y')
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<__int128_t> neighbors(n, 0);
    vector<int> cnt(n, 0);

    __int128_t one = 1;

    while (m --) {
        int u, v;
        cin >> u >> v;
        u --, v --;

        neighbors[u] |= one << v + 1;
        neighbors[v] |= one << u + 1;

        cnt[u] ^= 1;
        cnt[v] ^= 1;
    }

    for (int i = 0; i < n; i ++) {
        if (cnt[i]) neighbors[i] |= one << i + 1;
        else neighbors[i] |= 1;
    }

    vector<__int128_t> base(n + 1, 0);

    for (auto &x: neighbors) {
        for (int i = n; i >= 0; i --) {
            if (x >> i & 1) {
                if (base[i]) x ^= base[i];
                else {
                    base[i] = x;
                    break;
                }
            }
        }
    }

    cout << (base[0] ? 'N' : 'Y');

    return 0;
}
```