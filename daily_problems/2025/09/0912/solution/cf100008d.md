**提示 1：** 直接暴力是三次方复杂度，我们只需优化掉一个。

**提示 2：** 可以利用之前的计算结果。

本题的暴力可以通过枚举正方形的右下角，看最多能拓展出多大的正方形。这样做复杂度多了个 $n$ 。

我们只需优化掉这一点就行。考虑利用此前的计算结果。

对于 $(i,j)$ ，答案最多比 $(i-1,j-1)$ 大 $1$ ，因为如果答案超过了 $(i-1,j-1)$ 的答案加 $2$ ，则这个正方形的左上角边长已经超过了 $dp[i-1][j-1]+1$ ，且内部不符合要求的点不超过大正方形，意味着我们 $(i-1,j-1)$ 处的答案可以进一步增加，产生了矛盾。

所以从这个数为起点，一步步缩小正方形直至符合要求即可。

这么做复杂度怎么分析呢？

考虑每一条横纵坐标都加一的线。开始的答案是 $0/1$ ，之后每次增大都最多增加 $1$ ，考虑走遍这条线，每次最多加 $1$ ，且加 $\mathcal{O}(n)$ 次，同时每次减也减去 $1$ ，所以也进行 $\mathcal{O}(n)$ 次（因为不可能变成负数）。而 $+1,-1$ 的时间复杂度都是 $\mathcal{O}(n)$ 的，所以每条线时间复杂度为 $\mathcal{O}(n)$ 。

而总共有 $n$ 条线，所以时间复杂度为 $\mathcal{O}(n^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    for _ in range(t):
        n, w, l = MII()
        
        grid = [[0] * (n + 1) for _ in range(n + 1)]
        
        for _ in range(w):
            x, y = MII()
            grid[x][y] = 1
        
        for i in range(n):
            for j in range(n + 1):
                grid[i + 1][j] += grid[i][j]
        
        for i in range(n + 1):
            for j in range(n):
                grid[i][j + 1] += grid[i][j]
        
        ans = [[0] * (n + 1) for _ in range(n + 1)]
        res = 0
        
        for i in range(1, n + 1):
            for j in range(1, n + 1):
                v = ans[i - 1][j - 1] + 1
                
                while grid[i][j] - grid[i - v][j] - grid[i][j - v] + grid[i - v][j - v] > l:
                    v -= 1
                
                ans[i][j] = v
                res = fmax(res, v)
        
        outs.append(res * res)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int n, w, l;
        cin >> n >> w >> l;

        vector<vector<int>> grid(n + 1, vector<int>(n + 1, 0));

        while (w --) {
            int x, y;
            cin >> x >> y;
            grid[x][y] = 1;
        }

        for (int i = 0; i < n; i ++) {
            for (int j = 0; j <= n; j ++) {
                grid[i + 1][j] += grid[i][j];
            }
        }

        for (int i = 0; i <= n; i ++) {
            for (int j = 0; j < n; j ++) {
                grid[i][j + 1] += grid[i][j];
            }
        }

        vector<vector<int>> ans(n + 1, vector<int>(n + 1, 0));
        int res = 0;

        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= n; j ++) {
                int v = ans[i - 1][j - 1] + 1;

                while (grid[i][j] - grid[i - v][j] - grid[i][j - v] + grid[i - v][j - v] > l) v --;

                ans[i][j] = v, res = max(res, v);
            }
        }

        cout << res * res << '\n';
    }

    return 0;
}
```