**提示 1：** 考虑每辆车对应的时间-位移曲线。

每个车的运动过程都是一段段的匀速直线运动，且只受到前一辆车的影响。

于是考虑从最前面的车往后考虑。

每一辆车的运动的时间-位移图只需根据前一辆车确定。

- 如果初始速度已经比前面那辆车的最后速度更慢了，那无论如何撞不到前面的车，直接维护一条新的射线。

- 否则，我们考虑当前直线跟前一辆车的时间-位移曲线的交点，交点前面的部分是按照这辆车的时间-位移走，后面的部分按照前面那辆车的时间-位移走。

    - 我们相当于要删去前面那辆车的部分开头的折线。于是考虑从开头往后遍历每一段折线。这样新增一段和删去一段的复杂度都是 $\mathcal{O}(1)$ 的，这一部分的总复杂度就是 $\mathcal{O}(n)$ 的了。

    - 如果这段折线的速度已经更快了，直接删掉这一段。
    
    - 否则，计算下交点是否在这段上，如果不在，也直接弹出这一段。

    - 直到找到最后的一段，再把我们的这段新的线加上去。

其实整体维护了一个类似凸包的东西。

时间复杂度为 $\mathcal{O}(n\log n)$ ，因为你需要将所有车按照位置排序。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    xs = []
    vs = []
    
    for _ in range(n):
        x, v = MII()
        xs.append(x)
        vs.append(v)
    
    st_range = sorted(range(n), key=lambda x: -xs[x])
    
    stk_x = []
    stk_v = []
    
    ans = 0
    
    for i in st_range:
        x, v = xs[i], vs[i]
        
        while len(stk_x):
            if stk_v[-1] >= v: 
                stk_x.pop()
                stk_v.pop()
            elif len(stk_x) > 1:
                x1, v1 = stk_x[-1], stk_v[-1]
                x2, v2 = stk_x[-2], stk_v[-2]
                
                if (v - v2) * (x - x1) <= (v - v1) * (x - x2):
                    stk_x.pop()
                    stk_v.pop()
                else:
                    break
            else:
                break
        
        if len(stk_x):
            x1, v1 = stk_x[-1], stk_v[-1]
            ans = fmax(ans, -(x - x1) / (v - v1))
    
        stk_x.append(x)
        stk_v.append(v)
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<pair<int, int>> cars(n);
    for (auto &[x, y]: cars) cin >> x >> y;

    sort(cars.rbegin(), cars.rend());

    vector<pair<int, int>> stk;
    long double ans = 0;

    for (auto &[x, y]: cars) {
        while (!stk.empty()) {
            if (stk.back().second >= y) stk.pop_back();
            else if (stk.size() > 1) {
                auto [x1, y1] = stk[stk.size() - 1];
                auto [x2, y2] = stk[stk.size() - 2];

                if (1ll * (y - y2) * (x - x1) <= 1ll * (y - y1) * (x - x2)) stk.pop_back();
                else break;
            }
            else break;
        }

        if (!stk.empty()) {
            auto [x1, y1] = stk.back();
            ans = max(ans, - (long double)1 * (x - x1) / (y - y1));
        }

        stk.emplace_back(x, y);
    }

    cout << fixed << setprecision(10) << ans;

    return 0;
}
```