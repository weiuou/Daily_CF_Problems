**提示 1：** 从大到小考虑所有边权。

**提示 2：** 发现没多少边需要考虑。

正如求最小生成树的贪心，我们求最大生成树时，从大到小考虑各个边权。

先考虑所有边权为 $k$ 的边。假设从 $0$ 出发，只沿着这些边走可以走到哪些位置呢？

发现设 $g=\mathrm{gcd}(k,n)$ ， $0$ 可以走到任意 $g$ 的倍数的位置。因为我们可以走到任意 $k$ 的倍数 $\bmod n$ 的位置。

我们只需证明 $g$ 可达即可，于是只需说明 $a\times k-b\times n=g$ 有正整数解，即 $a\times k/g-b\times n/g=1$ 有正整数解。这个东西用裴蜀定理即可证明。

同样地可以从 $1,2,\dots,g-1$ 出发找到对应的 $n/g$ 个点形成的连通块。于是连出来的边数等于 $g\times(n/g-1)=n-g$ ，所以选用 $k$ 的边 $n-g$ 条。

而接下来从 $0$ 开始，走长度为 $k-1$ 的步长，走到 $(k-1)\bmod n,2(k-1)\bmod n,\dots,(g-1)(k-1)\bmod n$ 即可。可以注意到这些位置原先并不在一个连通块内，而相邻两个之间距离是 $k-1$ ，是小于 $k$ 的最大数。

（如果这些位置有两个在同个连通块内，则 $(i-j)(k-1)\bmod g=0$ ，又有 $k\gt 1$ 时， $\mathrm{gcd}(k,g)=1$ ，所以 $i-j\bmod g=0$ ，这也产生了矛盾，所以反证法可得。 $k=1$ 是显然的情况）

而 $n-g+g-1=n-1$ ，因此已经找到生成树，故答案是 $(n-g)k+(g-1)(k-1)$ 。时间复杂度为 $\mathcal{O}(\log M)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, k = MII()
    g = math.gcd(n, k)
    print((n - g) * k + (g - 1) * (k - 1))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, k;
    cin >> n >> k;

    int g = gcd(n, k);

    cout << 1ll * k * (n - g) + 1ll * (k - 1) * (g - 1);

    return 0;
}
```