**提示 1：** 什么情况下树几乎没法变？

发现 $h_i,h_{i+1}$ 中有一个是 $1$ 的情况下，这两层之间连边方式是唯一的。如果所有 $i$ 都满足这样的条件，则树唯一确定。

否则至少存在一组相邻的 $h_i,h_{i+1}$ ，且两者都大于 $1$ ，那么怎么构造出不同的两棵树呢？其实题中已经给了方案。

一种是让第 $i+1$ 层全部连前一层的一个点，一种是让 $i+1$ 层连前一层的多于一个点（其实只需要挑选一个点连到前一层的另一个点就行），这样这两棵树一定完全不同。

时间复杂度为 $\mathcal{O}(\sum h_i)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()
    
    for h in range(n):
        if nums[h] > 1 and nums[h + 1] > 1:
            print('ambiguous')
            
            total = sum(nums)
            
            depth = [0] * total
            chosen_node = [0] * (n + 1)
            
            pt = 0
            
            for i in range(total):
                while nums[pt] == 0: pt += 1
                depth[i] = pt
                nums[pt] -= 1
                chosen_node[depth[i]] = i
            
            ans = [0] * total
    
            for i in range(1, total):
                ans[i] = chosen_node[depth[i] - 1] + 1
            
            print(' '.join(map(str, ans)))
            
            for i in range(1, total):
                if depth[i] == h + 1:
                    ans[i] = chosen_node[depth[i] - 1]
                    break
            
            print(' '.join(map(str, ans)))
            
            exit()
    
    print('perfect')
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> nums(n + 1);
    for (auto &v: nums) cin >> v;

    for (int h = 0; h < n; h ++) {
        if (nums[h] > 1 && nums[h + 1] > 1) {
            cout << "ambiguous\n";

            int total = 0;
            for (auto &v: nums) total += v;

            vector<int> depth(total, 0), chosen_node(n + 1, 0);
            int pt = 0;

            for (int i = 0; i < total; i ++) {
                while (nums[pt] == 0) pt ++;
                depth[i] = pt, nums[pt] --, chosen_node[depth[i]] = i;
            }

            vector<int> ans(total, 0);

            for (int i = 1; i < total; i ++)
                ans[i] = chosen_node[depth[i] - 1] + 1;
            
            for (auto &v: ans) cout << v << ' '; cout << '\n';

            for (int i = 1; i < total; i ++) {
                if (depth[i] == h + 1) {
                    ans[i] = chosen_node[depth[i] - 1];
                    break;
                }
            }

            for (auto &v: ans) cout << v << ' '; cout << '\n';
            return 0;
        }
    }

    cout << "perfect";

    return 0;
}
```