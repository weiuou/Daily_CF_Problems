**提示 1：** 有些 $S$ 边是必须用到的。

我们先找到一些不得不用的 $S$ 边。

先连起来所有的 $M$ 边。则如果有一些 $S$ 边可以使得目前还没有连通的点连通，那么这两个点的连通性只能用 $S$ 边完成，因此应当选上它，并连接两个连通块。

这样我们找到了一系列 $S$ 边。如果 $S$ 数量还不够，我们继续连其他的 $S$ 边，只需保证 $S$ 边之间不成环即可。用第二个并查集实现就行。

如果此时 $S$ 边数量不对，直接输出不可行就行；否则枚举剩余的 $N$ 边把 $S$ 边连出来的连通块继续连接到一起就好。只需最后连接成连通块就符合要求。

当然，生成树边数是偶数意味着原图点数是奇数（树的点数等于边数加一），因此可以开头判掉这种不合法情况。

时间复杂度为 $\mathcal{O}(n+m)$ ，如果认为并查集的操作是 $\mathcal{O}(1)$ 的。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    us = []
    vs = []
    cs = []
    
    for _ in range(m):
        u, v, c = LI()
        u = int(u) - 1
        v = int(v) - 1
        c = 1 if c == 'S' else 0
        us.append(u)
        vs.append(v)
        cs.append(c)
    
    if n % 2 == 0: exit(print(-1))
    
    target = n // 2
    ans = []
    
    uf_base = UnionFind(n)
    real_uf = UnionFind(n)
    
    for i in range(m):
        if cs[i] == 0:
            uf_base.merge(us[i], vs[i])
    
    for i in range(m):
        if cs[i] and uf_base.merge(us[i], vs[i]):
            real_uf.merge(us[i], vs[i])
            ans.append(i)
    
    for i in range(m):
        if len(ans) < target and cs[i] and real_uf.merge(us[i], vs[i]):
            ans.append(i)
    
    if len(ans) != target: exit(print(-1))
    
    for i in range(m):
        if cs[i] == 0 and real_uf.merge(us[i], vs[i]):
            ans.append(i)
    
    if len(ans) == n - 1:
        print(len(ans))
        print(' '.join(str(x + 1) for x in ans))
    else:
        print(-1)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<array<int, 3>> edges(m);

    for (auto &[u, v, c]: edges) {
        char x;
        cin >> u >> v >> x;
        u --, v --;
        c = (x == 'S' ? 1 : 0);
    }

    if (n % 2 == 0) return cout << -1, 0;

    int target = n / 2;
    vector<int> ans;

    atcoder::dsu uf_base(n), real_uf(n);

    for (int i = 0; i < m; i ++) {
        auto [u, v, c] = edges[i];
        if (c == 0) uf_base.merge(u, v);
    }

    for (int i = 0; i < m; i ++) {
        auto [u, v, c] = edges[i];
        if (c && uf_base.merge(u, v)) {
            real_uf.merge(u, v);
            ans.emplace_back(i);
        }
    }

    for (int i = 0; i < m; i ++) {
        auto [u, v, c] = edges[i];
        if (ans.size() < target && c && real_uf.merge(u, v)) {
            ans.emplace_back(i);
        }
    }

    if (ans.size() != target) return cout << -1, 0;

    for (int i = 0; i < m; i ++) {
        auto [u, v, c] = edges[i];
        if (c == 0 && real_uf.merge(u, v)) {
            ans.emplace_back(i);
        }
    }

    if (ans.size() == n - 1) {
        cout << ans.size() << '\n';
        for (auto &x: ans) cout << x + 1 << ' ';
    }
    else cout << -1;

    return 0;
}
```