**提示 1：** 其实每个位置操作的数是多少是很容易算出来的。

考虑在 $(x,y)$ 位置变化数值是 $f(x,y)$ 。

在 $(x,y)$ 位置，有多少操作会影响到它呢？

考虑 $(x,y)$ 往右下角的所有位置的变化数值的总和，刚好就是 $A_{x,y}$ 。则 $f(x,y)=A_{x,y}-A_{x+1,y}-A_{x,y+1}+A_{x+1,y+1}$ ，因为 $A$ 是一个类似前缀和的数组，我们相当于用它恢复原数组。

于是只要这个 $f(x,y)$ 不是 $0$ ，这个位置就必须得操作，对答案 $+1$ 即可。

时间复杂度为 $\mathcal{O}(nm)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    grid = [[1 if c == 'B' else -1 for c in I()] for _ in range(n)]
    
    ans = 0
    
    for i in range(n):
        for j in range(m):
            v = grid[i][j]
            if i + 1 < n: v -= grid[i + 1][j]
            if j + 1 < m: v -= grid[i][j + 1]
            if i + 1 < n and j + 1 < m: v += grid[i + 1][j + 1]
            
            if v: ans += 1
    
    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<string> grid(n);
    for (auto &s: grid) cin >> s;

    int ans = 0;

    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < m; j ++) {
            int v = grid[i][j];
            if (i + 1 < n) v -= grid[i + 1][j];
            if (j + 1 < m) v -= grid[i][j + 1];
            if (i + 1 < n && j + 1 < m) v += grid[i + 1][j + 1];

            if (v) ans ++;
        }
    }

    cout << ans;

    return 0;
}
```