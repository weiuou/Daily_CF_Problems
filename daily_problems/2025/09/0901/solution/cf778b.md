**提示 1：** 每一位互不干扰，所以分别考虑就行。

位运算的每一个位是可以单独计算的。而最后的总和等于每一位的总和进行相加。

于是枚举每一位，再枚举 $?$ 在当前位是 $0$ 还是 $1$ ，最后模拟运算过程，看这一位取 $0$ 还是取 $1$ 的时候，所有变量当前位是 $1$ 的数量最多 / 最少就行。

但是模拟过程有点丑陋来着。

时间复杂度为 $\mathcal{O}(nm)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    d = {}
    n, m = MII()
    
    d = {'?': -1}
    
    flg = [0] * n
    tmp = [None] * n
    ops = [None] * n
    
    op_mapping = {
        'XOR': xor,
        'OR': ior,
        'AND': iand
    }
    
    for i in range(n):
        op = LI()
        
        d[op[0]] = i
        
        if len(op) == 3:
            tmp[i] = [int(c) for c in op[2]]
        else:
            flg[i] = 1
            ops[i] = d[op[2]], op_mapping[op[3]], d[op[4]]
    
    ans0 = []
    ans1 = []
    
    for i in range(m):
        cur0 = [0] * n
        cur1 = [0] * n
    
        for j in range(n):
            if flg[j]:
                a, o, b = ops[j]
                
                x0 = cur0[a] if a >= 0 else 0
                x1 = cur1[a] if a >= 0 else 1
                
                y0 = cur0[b] if b >= 0 else 0
                y1 = cur1[b] if b >= 0 else 1
                
                cur0[j] = o(x0, y0)
                cur1[j] = o(x1, y1)
            
            else:
                cur0[j] = tmp[j][i]
                cur1[j] = tmp[j][i]
        
        c0 = sum(cur0)
        c1 = sum(cur1)
        
        if c0 <= c1: ans0.append(0)
        else: ans0.append(1)
        
        if c0 >= c1: ans1.append(0)
        else: ans1.append(1)
    
    print(*ans0, sep='')
    print(*ans1, sep='')
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    map<string, int> mp;

    vector<int> flg(n, 0);
    vector<vector<int>> vals(n, vector<int>(m));
    vector<array<int, 3>> ops(n);

    mp["?"] = 0;

    for (int i = 1; i <= n; i ++) {
        string s;
        cin >> s;

        mp[s] = i;
        cin >> s >> s;

        if (s[0] == '0' || s[0] == '1') {
            for (int j = 0; j < m; j ++) 
                vals[i - 1][j] = s[j] - '0';
        }
        else {
            flg[i - 1] = 1;

            ops[i - 1][0] = mp[s];
            cin >> s;

            if (s[0] == 'X') ops[i - 1][1] = 0;
            else if (s[0] == 'O') ops[i - 1][1] = 1;
            else ops[i - 1][1] = 2;

            cin >> s;
            ops[i - 1][2] = mp[s];
        }
    }

    string ans0, ans1;

    for (int i = 0; i < m; i ++) {
        int c0 = 0, c1 = 0;
        vector<int> cur0(n), cur1(n);

        for (int j = 0; j < n; j ++) {
            if (flg[j]) {
                auto [x, o, y] = ops[j];

                int x0 = (x ? cur0[x - 1] : 0);
                int x1 = (x ? cur1[x - 1] : 1);

                int y0 = (y ? cur0[y - 1] : 0);
                int y1 = (y ? cur1[y - 1] : 1);

                if (o == 0) cur0[j] = x0 ^ y0, cur1[j] = x1 ^ y1;
                else if (o == 1) cur0[j] = x0 | y0, cur1[j] = x1 | y1;
                else cur0[j] = x0 & y0, cur1[j] = x1 & y1;
            }
            else cur0[j] = vals[j][i], cur1[j] = vals[j][i];

            c0 += cur0[j], c1 += cur1[j];
        }

        if (c0 <= c1) ans0 += '0';
        else ans0 += '1';

        if (c0 >= c1) ans1 += '0';
        else ans1 += '1';
    }

    cout << ans0 << '\n' << ans1;

    return 0;
}
```