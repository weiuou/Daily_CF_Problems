**提示 1：** 想另一个方式计算权值和。

下面的集合是可重的。

我们要对一个集合求其非空子集的元素乘积的和，

对于每个元素，都可以选择在子集中是否出现，两种情况下分别贡献为 $1$ 和 $a_i$ 。

因此，所有子集的元素积的和是 $(a_1+1)(a_2+1)\dots\(a_k+1)$ ，再去掉空集的 $1$ 即可。

于是，我们要用 $x_i$ 构造序列，使得序列的元素加一的乘积不超过 $L+1$ 。

为此直接使用 BFS / DFS 都行，起始状态是空序列，对应的乘积是 $1$ ，接下来每个状态尝试乘以 $x_i+1$ 进行搜索即可。

时间复杂度不超过输入是 $2,3,\dots,15$ 且 $L=10^{12}$ 的情况下能达到的答案，再乘以 $N$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, l = MII()
    l += 1
    
    nums = LII()
    nums = list(set(nums))
    
    vis = {1}
    que = [1]
    
    for x in que:
        for v in nums:
            nx = x * (v + 1)
            if nx <= l and nx not in vis:
                vis.add(nx)
                que.append(nx)
    
    print(len(vis) - 1)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    long long l;
    cin >> n >> l;
    l ++;

    vector<int> vals(16);
    while (n --) {
        int x;
        cin >> x;
        vals[x] = 1;
    }

    set<long long> vis = {1};

    auto dfs = [&] (auto &self, long long cur) -> void {
        for (int i = 2; i < 16; i ++) {
            if (vals[i]) {
                long long ncur = cur * (i + 1);
                if (ncur <= l && vis.find(ncur) == vis.end()) {
                    vis.insert(ncur);
                    self(self, ncur);
                }
            }
        }
    };

    dfs(dfs, 1);

    cout << vis.size() - 1;

    return 0;
}
```