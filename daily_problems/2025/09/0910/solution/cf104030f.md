**提示 1：** 在 $n$ 很大的情况下，有大量信息冗余，所以可以提取关键的。

**提示 2：** 还有什么情况？

在 $n$ 很大时， $s_1$ 出现在了 $\mathcal{O}(n)$ 个串中，因此其信息被重复出现，因此很多信息很可能是没必要的。

所以我们可以提取关键信息求解。

发现，只需提取字符串长度，在 $n=3$ 时，就足够用三元一次的三个方程形成方程组解出来每个字符串的长度，进而确定唯一可能的一组解。

$n\gt 3$ 时，可以根据前三个字符串的长度得到后面每个串的长度进而得到解（只需提取对应行的字符串的前缀就行）。

唯一剩下的情况就是 $n=2$ ，这相当于问我们 $s_1+s_2=A,s_2+s_1=B$ 的解。

这就相当于问 $A$ 的一个后缀加上前缀能否凑出来 $B$ ，我们只需在 $A+A$ 中寻找 $B$ 子串即可确认这件事。这个字符串匹配很显然 KMP 就能完成了。

时间复杂度为 $\mathcal{O}(\sum |s_{i,j}|)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    grid = [LI() for _ in range(n)]
    grid_len = [[len(c) for c in x] for x in grid]
    
    if n >= 3:
        c01 = grid_len[0][1]
        c02 = grid_len[0][2]
        c12 = grid_len[1][2]
        
        c012 = (c01 + c02 + c12) // 2
        
        cnt = [0] * n
        cnt[0] = c012 - c12
        cnt[1] = c012 - c02
        cnt[2] = c012 - c01
        
        for i in range(3, n):
            cnt[i] = grid_len[0][i] - cnt[0]
        
        for i in range(n):
            if cnt[i] <= 0:
                exit(print('NONE'))
        
        ans = [''] * n
        
        for i in range(n):
            ans[i] = grid[i][0 if i else 1][:cnt[i]]
        
        for i in range(n):
            for j in range(n):
                if i != j and ans[i] + ans[j] != grid[i][j]:
                    exit(print('NONE'))
        
        print('UNIQUE')
        print('\n'.join(ans))
    
    else:
        s01 = grid[0][1]
        s10 = grid[1][0]
        
        if len(s01) != len(s10):
            exit(print('NONE'))
        
        k = len(s01)
        
        tmp = s10 + '#' + s01 * 2
        kmp = prep(tmp)
        
        idxs = []
        
        for i in range(2 * k + 1, 3 * k):
            if kmp[i] == k:
                idxs.append(i - 2 * k)
        
        if len(idxs) > 1: print('MANY')
        elif len(idxs) == 0: print('NONE')
        else:
            idx = idxs[0]
            print('UNIQUE')
            print(s01[:idx])
            print(s01[idx:])
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<vector<string>> grid(n, vector<string>(n));
    vector<vector<int>> grid_len(n, vector<int>(n));

    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            cin >> grid[i][j];
            grid_len[i][j] = grid[i][j].size();
        }
    }

    if (n >= 3) {
        int c01 = grid_len[0][1];
        int c02 = grid_len[0][2];
        int c12 = grid_len[1][2];

        int c012 = (c01 + c02 + c12) / 2;
        
        vector<int> cnt(n);

        cnt[0] = c012 - c12;
        cnt[1] = c012 - c02;
        cnt[2] = c012 - c01;

        for (int i = 3; i < n; i ++)
            cnt[i] = grid_len[0][i] - cnt[0];
        
        for (int i = 0; i < n; i ++)
            if (cnt[i] <= 0)
                return cout << "NONE", 0;
        
        vector<string> ans(n);

        for (int i = 0; i < n; i ++)
            ans[i] = grid[i][i ? 0 : 1].substr(0, cnt[i]);
        
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < n; j ++) {
                if (i != j && ans[i] + ans[j] != grid[i][j]) {
                    return cout << "NONE", 0;
                }
            }
        }

        cout << "UNIQUE\n";
        for (auto &x: ans) cout << x << '\n';
    }
    else {
        string s01 = grid[0][1], s10 = grid[1][0];

        if (s01.size() != s10.size())
            return cout << "NONE", 0;
        
        int k = s01.size();

        string tmp = s10;
        tmp += '#';
        tmp += s01;
        tmp += s01;

        auto kmp = prep(tmp);

        vector<int> idxs;
        for (int i = 2 * k + 1; i < 3 * k; i ++) {
            if (kmp[i] == k) {
                idxs.emplace_back(i - 2 * k);
            }
        }

        if (idxs.size() > 1) cout << "MANY";
        else if (idxs.empty()) cout << "NONE";
        else {
            int idx = idxs[0];
            cout << "UNIQUE\n";
            cout << s01.substr(0, idx) << '\n' << s01.substr(idx);
        }
    }

    return 0;
}
```