**提示 1：** 先把问题想清楚。到底要求解什么最优化问题。

**提示 2：** 第一步没有那么影响第二步。

注意题目中的 some 是 “某个” 的意思，不要被骗。

我们枚举 A 操作的元素。接下来 B 要的是最大化数组的和。

A 操作后，数组只有一个元素改变了。

对于不变的元素，我们可以预处理得到操作它后数组和的变化情况。而除了 A 操作的元素外，相当于剩下了前后缀，所以可以在预处理后 $\mathcal{O}(1)$ 得到其他位置操作的最小影响情况。再算上操作当前元素的影响情况即可。

在枚举 A 的过程中顺便维护一下数组的当前和就行。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    for _ in range(t):
        n, x, y = MII()
        nums = LII()
        
        tmp = [v - (v & y) for v in nums]
        
        pref_min = [2 * 10 ** 9] * (n + 1)
        for i in range(n):
            pref_min[i + 1] = fmin(pref_min[i], tmp[i])
        
        suff_min = [2 * 10 ** 9] * (n + 1)
        for i in range(n - 1, -1, -1):
            suff_min[i] = fmin(suff_min[i + 1], tmp[i])
    
        total = sum(nums)
        ans = 10 ** 15
        
        for i in range(n):
            res = total - nums[i] + (nums[i] | x)
            to_delete = fmin(pref_min[i], suff_min[i + 1])
            to_delete = fmin(to_delete, (nums[i] | x) - ((nums[i] | x) & y))
            res -= to_delete
            ans = fmin(ans, res)
        
        outs.append(ans)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int n, x, y;
        cin >> n >> x >> y;

        vector<int> nums(n);
        for (auto &v: nums) cin >> v;

        int inf = 2e9;
        vector<int> pref_min(n + 1, inf), suff_min(n + 1, inf);

        for (int i = 0; i < n; i ++)
            pref_min[i + 1] = min(pref_min[i], nums[i] - (nums[i] & y));
        
        for (int i = n - 1; i >= 0; i --)
            suff_min[i] = min(suff_min[i + 1], nums[i] - (nums[i] & y));
        
        long long total = 0, ans = 1e15;
        for (auto &v: nums) total += v;

        for (int i = 0; i < n; i ++) {
            long long res = total - nums[i] + (nums[i] | x);
            int to_delete = min(pref_min[i], suff_min[i + 1]);
            to_delete = min(to_delete, (nums[i] | x) - ((nums[i] | x) & y));
            res -= to_delete;
            ans = min(ans, res);
        }

        cout << ans << '\n';
    }

    return 0;
}
```
