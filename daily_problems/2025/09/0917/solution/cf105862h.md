**提示 1：** 每个元素在计算中的出现次数是一样的。

我们考虑平移 $pos$ 从 $0$ 到 $n-1$ ，则每个位置都会被同样次数地选到。所以每个位置被算入求和的次数是一样的。

接下来考虑第一个位置会被算几次。

如果步长是 $x$ ，那么什么时候会陷入循环呢？假设 $k$ 步进入循环，则 $kx$ 需要是 $n$ 的倍数。满足这个条件的最小的 $k$ 是 $n/\mathrm{gcd}(n,x)$ 。

在这个循环中，所有位置都可以作为开始，所以每个元素都会被计算 $n/\mathrm{gcd}(n,x)$ 次。所以遍历所有可能的 $x$ ，求和即可得到每个元素可能被计算的总次数。

最后用数组和乘以总次数，再除以总情况数就是期望了。

时间复杂度为 $\mathcal{O}(n\log n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []
    
    mod = 10 ** 9 + 7
    
    for _ in range(t):
        n = II()
        nums = LII()
        
        total = sum(nums)
        times = 0
        for i in range(n):
            g = math.gcd(n, i)
            times += n // g
        
        rev_n = pow(n, -1, mod)
        outs.append(sum(nums) * times % mod * rev_n % mod * rev_n % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t, mod = 1e9 + 7;
    cin >> t;

    while (t --) {
        int n;
        cin >> n;

        int total = 0;
        for (int i = 0; i < n; i ++) {
            int x;
            cin >> x;
            total += x;
            if (total >= mod) total -= mod;
        }

        int times = 0;
        for (int i = 0; i < n; i ++) {
            times += n / gcd(i, n);
            if (times >= mod) times -= mod;
        }

        int revn = quickPow(n, mod - 2, mod);
        cout << 1ll * total * times % mod * revn % mod * revn % mod << '\n';
    }

    return 0;
}
```