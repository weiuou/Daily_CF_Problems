**提示 1：** 先估计一下答案的下界，可以构造出来吗？

首先，如果一个数组中本身存在 $cnt$ 组 $a_i\gt a_{i+1}$ ，那么无论这两个元素中插入了什么元素，中间一定有一对是逆序的，所以答案至少为 $cnt$ 。

于是，我们可以统计每一个序列的上述情形出现次数，取最大值，这就是答案的下界。

可以取到这个下界吗？答案是肯定的。

假设每个数组都有最多 $ans$ 个 $i$ 使得相邻两项是递减的，那么我们需要最后形成的归并数组也最多只有 $ans$ 个这样的位置。

假设这些位置把每个数组分为若干段，则不同段的元素在最终的数组中，也必须在不同的段。

所以不妨把第一段的元素放到答案的第一段中，第二段的元素放到答案的第二段中，以此类推。这样，分配给每一段的元素就一定是递增的一个子数组了，这些子数组一定可以利用类似归并排序的方式合并成没有逆序对的样子。

同时这里我们也无需模拟归并的过程，只需把所有元素取出来一起排序就行。

时间复杂度为 $\mathcal{O}(\sum k_i)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    ks = [0] * n
    a1s = [0] * n
    xs = [0] * n
    ys = [0] * n
    ms = [0] * n
    
    for i in range(n):
        ks[i], a1s[i], xs[i], ys[i], ms[i] = MII()
    
    sumk = sum(ks)
    tmp = [[] for _ in range(200005)]
    
    def f(i, j):
        return i * n + j
    
    ans = 0
    
    for i in range(n):
        k = ks[i]
        a = a1s[i]
        x = xs[i]
        y = ys[i]
        m = ms[i]
        
        vs = [a]
        
        for _ in range(1, k):
            a = (a * x + y) % m
            vs.append(a)
        
        c = 0
        for j in range(k):
            if j and vs[j] < vs[j - 1]:
                c += 1
            if sumk <= 200000:
                tmp[c].append(f(vs[j], i))
        
        ans = fmax(ans, c)
    
    print(ans)
    
    if sumk <= 200000:
        outs = []
        
        for x in tmp:
            x.sort()
            for v in x:
                val, idx = divmod(v, n)
                outs.append(f'{val} {idx + 1}')
        
        print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> ks(n), a1s(n), xs(n), ys(n), ms(n);
    int sumk = 0;

    for (int i = 0; i < n; i ++)
        cin >> ks[i] >> a1s[i] >> xs[i] >> ys[i] >> ms[i], sumk += ks[i];
    
    int ans = 0;
    vector<vector<pair<int, int>>> tmp(200005);

    for (int i = 0; i < n; i ++) {
        int k = ks[i], a = a1s[i], x = xs[i], y = ys[i], m = ms[i];

        vector<int> vs = {a};
        for (int i = 1; i < k; i ++) {
            a = (1ll * a * x + y) % m;
            vs.emplace_back(a);
        }
        
        int c = 0;
        for (int j = 0; j < k; j ++) {
            if (j && vs[j] < vs[j - 1]) c ++;
            if (sumk <= 200000) tmp[c].emplace_back(vs[j], i + 1);
        }

        ans = max(ans, c);
    }

    cout << ans << '\n';

    if (sumk <= 200000) {
        for (auto &v: tmp) {
            sort(v.begin(), v.end());
            for (auto &[x, y]: v)
                cout << x << ' ' << y << '\n';
        }
    }

    return 0;
}
```